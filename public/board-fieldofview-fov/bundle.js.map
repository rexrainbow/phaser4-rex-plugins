{
  "version": 3,
  "sources": ["node_modules/@phaserjs/phaser/GameInstance.js", "node_modules/@phaserjs/phaser/config/BackgroundColor.js", "node_modules/@phaserjs/phaser/config/Banner.js", "node_modules/@phaserjs/phaser/config/CanvasContext.js", "node_modules/@phaserjs/phaser/config/Size.js", "node_modules/@phaserjs/phaser/renderer/BindingQueue.js", "node_modules/@phaserjs/phaser/renderer/canvas/CanvasRenderer.js", "node_modules/@phaserjs/phaser/config/SetRenderer.js", "node_modules/@phaserjs/phaser/config/CanvasRenderer.js", "node_modules/@phaserjs/phaser/config/DefaultOrigin.js", "node_modules/@phaserjs/phaser/config/MaxTextures.js", "node_modules/@phaserjs/phaser/dom/GetElement.js", "node_modules/@phaserjs/phaser/config/Parent.js", "node_modules/@phaserjs/phaser/config/Scenes.js", "node_modules/@phaserjs/phaser/config/WebGLContext.js", "node_modules/@phaserjs/phaser/renderer/webgl1/fbo/FBOSystem.js", "node_modules/@phaserjs/phaser/renderer/webgl1/GL.js", "node_modules/@phaserjs/phaser/renderer/webgl1/colors/GetRGBArray.js", "node_modules/@phaserjs/phaser/math/matrix2d-funcs/ExactEquals.js", "node_modules/@phaserjs/phaser/renderer/webgl1/fbo/CreateFramebuffer.js", "node_modules/@phaserjs/phaser/renderer/webgl1/textures/CreateGLTexture.js", "node_modules/@phaserjs/phaser/renderer/webgl1/fbo/DeleteFramebuffer.js", "node_modules/@phaserjs/phaser/renderer/webgl1/textures/DeleteGLTexture.js", "node_modules/@phaserjs/phaser/math/pow2/IsSizePowerOfTwo.js", "node_modules/@phaserjs/phaser/renderer/webgl1/textures/SetGLTextureFilterMode.js", "node_modules/@phaserjs/phaser/renderer/webgl1/textures/UpdateGLTexture.js", "node_modules/@phaserjs/phaser/renderer/webgl1/textures/GLTextureBinding.js", "node_modules/@phaserjs/phaser/renderer/webgl1/buffers/IndexedBuffer.js", "node_modules/@phaserjs/phaser/textures/Frame.js", "node_modules/@phaserjs/phaser/textures/Texture.js", "node_modules/@phaserjs/phaser/renderer/webgl1/WebGLRendererInstance.js", "node_modules/@phaserjs/phaser/renderer/webgl1/shaders/SingleTextureQuadShader.js", "node_modules/@phaserjs/phaser/renderer/webgl1/shaders/MultiTextureQuadShader.js", "node_modules/@phaserjs/phaser/renderer/webgl1/cameras/Ortho.js", "node_modules/@phaserjs/phaser/renderer/webgl1/shaders/ShaderSystem.js", "node_modules/@phaserjs/phaser/renderer/webgl1/shaders/CheckShaderMaxIfStatements.js", "node_modules/@phaserjs/phaser/renderer/webgl1/textures/TextureSystem.js", "node_modules/@phaserjs/phaser/renderer/webgl1/WebGLRenderer.js", "node_modules/@phaserjs/phaser/config/WebGLRenderer.js", "node_modules/@phaserjs/phaser/config/index.js", "node_modules/@phaserjs/phaser/events/Emit.js", "node_modules/@phaserjs/phaser/dom/AddToDOM.js", "node_modules/@phaserjs/phaser/dom/DOMContentLoaded.js", "node_modules/@phaserjs/phaser/events/EventEmitter.js", "node_modules/@phaserjs/phaser/events/EventInstance.js", "node_modules/@phaserjs/phaser/events/On.js", "node_modules/@phaserjs/phaser/events/Once.js", "node_modules/@phaserjs/phaser/scenes/CreateSceneRenderData.js", "node_modules/@phaserjs/phaser/scenes/ResetSceneRenderData.js", "node_modules/@phaserjs/phaser/scenes/SceneManagerInstance.js", "node_modules/@phaserjs/phaser/scenes/SceneManager.js", "node_modules/@phaserjs/phaser/textures/CreateCanvas.js", "node_modules/@phaserjs/phaser/textures/TextureManagerInstance.js", "node_modules/@phaserjs/phaser/textures/TextureManager.js", "node_modules/@phaserjs/phaser/Game.js", "node_modules/@phaserjs/phaser/scenes/GetConfigValue.js", "node_modules/@phaserjs/phaser/scenes/Install.js", "node_modules/@phaserjs/phaser/scenes/Scene.js", "node_modules/@phaserjs/phaser/math/matrix2d/Matrix2D.js", "node_modules/@phaserjs/phaser/geom/rectangle/Contains.js", "node_modules/@phaserjs/phaser/geom/rectangle/Rectangle.js", "node_modules/@phaserjs/phaser/utils/NOOP.js", "node_modules/@phaserjs/phaser/math/vec2/Vec2Callback.js", "node_modules/@phaserjs/phaser/math/Wrap.js", "node_modules/@phaserjs/phaser/math/angle/WrapAngle.js", "node_modules/@phaserjs/phaser/camera/Camera.js", "node_modules/@phaserjs/phaser/camera/StaticCamera.js", "node_modules/@phaserjs/phaser/display/DepthFirstSearch.js", "node_modules/@phaserjs/phaser/display/GetChildIndex.js", "node_modules/@phaserjs/phaser/display/RemoveChildAt.js", "node_modules/@phaserjs/phaser/display/RemoveChild.js", "node_modules/@phaserjs/phaser/gameobjects/events/AddedToWorldEvent.js", "node_modules/@phaserjs/phaser/gameobjects/events/DestroyEvent.js", "node_modules/@phaserjs/phaser/gameobjects/events/PostUpdateEvent.js", "node_modules/@phaserjs/phaser/gameobjects/events/RemovedFromWorldEvent.js", "node_modules/@phaserjs/phaser/gameobjects/events/UpdateEvent.js", "node_modules/@phaserjs/phaser/display/SetWorld.js", "node_modules/@phaserjs/phaser/display/SetParent.js", "node_modules/@phaserjs/phaser/gameobjects/DIRTY_CONST.js", "node_modules/@phaserjs/phaser/display/RemoveChildrenBetween.js", "node_modules/@phaserjs/phaser/display/DestroyChildren.js", "node_modules/@phaserjs/phaser/display/RemoveChildren.js", "node_modules/@phaserjs/phaser/display/ReparentChildren.js", "node_modules/@phaserjs/phaser/events/Off.js", "node_modules/@phaserjs/phaser/gameobjects/components/transform/GetVertices.js", "node_modules/@phaserjs/phaser/gameobjects/components/bounds/BoundsComponent.js", "node_modules/@phaserjs/phaser/gameobjects/components/input/InputComponent.js", "node_modules/@phaserjs/phaser/math/vec2/Vec2.js", "node_modules/@phaserjs/phaser/gameobjects/components/transform/UpdateLocalTransform.js", "node_modules/@phaserjs/phaser/math/matrix2d/Copy.js", "node_modules/@phaserjs/phaser/gameobjects/components/transform/UpdateWorldTransform.js", "node_modules/@phaserjs/phaser/gameobjects/components/transform/TransformComponent.js", "node_modules/@phaserjs/phaser/gameobjects/GameObject.js", "node_modules/@phaserjs/phaser/world/events/WorldRenderEvent.js", "node_modules/@phaserjs/phaser/world/events/WorldShutdownEvent.js", "node_modules/@phaserjs/phaser/index-664c5328.js", "node_modules/@phaserjs/phaser/world/CalculateTotalRenderable.js", "node_modules/@phaserjs/phaser/world/HasDirtyChildren.js", "node_modules/@phaserjs/phaser/world/UpdateCachedLayers.js", "node_modules/@phaserjs/phaser/world/WorldDepthFirstSearch.js", "node_modules/@phaserjs/phaser/world/BuildRenderList.js", "node_modules/@phaserjs/phaser/world/MergeRenderData.js", "node_modules/@phaserjs/phaser/world/ResetWorldRenderData.js", "node_modules/@phaserjs/phaser/world/BaseWorld.js", "node_modules/@phaserjs/phaser/world/CreateWorldRenderData.js", "node_modules/@phaserjs/phaser/world/StaticWorld.js", "node_modules/@phaserjs/phaser/world/World.js", "node_modules/@phaserjs/phaser/world/index.js", "node_modules/@phaserjs/phaser/display/AddChild.js", "node_modules/@phaserjs/phaser/display/AddChildAt.js", "node_modules/@phaserjs/phaser/display/AddChildren.js", "node_modules/@phaserjs/phaser/display/AddChildrenAt.js", "node_modules/@phaserjs/phaser/display/AddPosition.js", "node_modules/@phaserjs/phaser/display/AddRotation.js", "node_modules/@phaserjs/phaser/display/AddScale.js", "node_modules/@phaserjs/phaser/display/AddSkew.js", "node_modules/@phaserjs/phaser/display/BringChildToTop.js", "node_modules/@phaserjs/phaser/display/DepthFirstSearchRecursiveNested.js", "node_modules/@phaserjs/phaser/display/ConsoleTreeChildren.js", "node_modules/@phaserjs/phaser/display/CountMatchingChildren.js", "node_modules/@phaserjs/phaser/display/DepthFirstSearchRecursive.js", "node_modules/@phaserjs/phaser/display/FindChildByName.js", "node_modules/@phaserjs/phaser/display/FindChildrenByName.js", "node_modules/@phaserjs/phaser/display/GetAllChildren.js", "node_modules/@phaserjs/phaser/display/GetChildAt.js", "node_modules/@phaserjs/phaser/display/GetChildren.js", "node_modules/@phaserjs/phaser/math/distance/DistanceBetweenPoints.js", "node_modules/@phaserjs/phaser/display/GetClosestChild.js", "node_modules/@phaserjs/phaser/display/GetFirstChild.js", "node_modules/@phaserjs/phaser/display/GetFurthestChild.js", "node_modules/@phaserjs/phaser/display/GetLastChild.js", "node_modules/@phaserjs/phaser/display/GetParents.js", "node_modules/@phaserjs/phaser/display/GetRandomChild.js", "node_modules/@phaserjs/phaser/display/MoveChildDown.js", "node_modules/@phaserjs/phaser/display/MoveChildTo.js", "node_modules/@phaserjs/phaser/display/MoveChildUp.js", "node_modules/@phaserjs/phaser/geom/intersects/RectangleToRectangle.js", "node_modules/@phaserjs/phaser/display/Overlap.js", "node_modules/@phaserjs/phaser/display/RemoveChildrenAt.js", "node_modules/@phaserjs/phaser/display/RotateChildrenLeft.js", "node_modules/@phaserjs/phaser/display/RotateChildrenRight.js", "node_modules/@phaserjs/phaser/display/SendChildToBack.js", "node_modules/@phaserjs/phaser/display/SetBounds.js", "node_modules/@phaserjs/phaser/display/SetChildrenValue.js", "node_modules/@phaserjs/phaser/display/SetName.js", "node_modules/@phaserjs/phaser/display/SetOrigin.js", "node_modules/@phaserjs/phaser/display/SetPosition.js", "node_modules/@phaserjs/phaser/display/SetRotation.js", "node_modules/@phaserjs/phaser/display/SetScale.js", "node_modules/@phaserjs/phaser/display/SetSize.js", "node_modules/@phaserjs/phaser/display/SetSkew.js", "node_modules/@phaserjs/phaser/display/SetType.js", "node_modules/@phaserjs/phaser/display/SetValue.js", "node_modules/@phaserjs/phaser/display/SetVisible.js", "node_modules/@phaserjs/phaser/display/ShuffleChildren.js", "node_modules/@phaserjs/phaser/display/SwapChildren.js", "node_modules/@phaserjs/phaser/display/index.js", "node_modules/@phaserjs/phaser/renderer/webgl1/draw/BatchTexturedQuad.js", "node_modules/@phaserjs/phaser/gameobjects/container/Container.js", "node_modules/@phaserjs/phaser/renderer/canvas/draw/DrawTexturedQuad.js", "node_modules/@phaserjs/phaser/renderer/webgl1/colors/PackColor.js", "node_modules/@phaserjs/phaser/renderer/webgl1/colors/PackColors.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/SetFrame.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/SetTexture.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/UpdateVertices.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/Sprite.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/SetAlpha.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/SetQuadAlpha.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/SetQuadTint.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/SetTint.js", "node_modules/@phaserjs/phaser/gameobjects/sprite/index.js", "src/board/board/boarddata/methods/Key.ts", "src/utils/struct/Stack.ts", "src/utils/pool/EmptyMap.ts", "src/board/board/boarddata/methods/ZMap.ts", "src/utils/pool/EmptySet.ts", "src/board/board/boarddata/methods/ChessSet.ts", "src/board/board/boarddata/methods/AddChess.ts", "src/board/board/boarddata/methods/GetChess.ts", "src/board/board/boarddata/methods/RemoveChess.ts", "src/board/board/boarddata/methods/HasChess.ts", "src/board/board/boarddata/methods/Contains.ts", "src/board/board/boarddata/methods/GetXYZ.ts", "src/board/board/boarddata/methods/GetMaxMinMapKey.ts", "src/board/board/boarddata/BoardData.ts", "src/board/board/boarddata/SetBoardHeight.ts", "src/board/board/boarddata/SetBoardWidth.ts", "src/board/board/boarddata/index.ts", "src/board/board/BaseBoard.ts", "src/board/board/tilexy/TileXYZToChess.ts", "src/utils/object/IsPlainObject.ts", "src/board/utils/IsTileXYZ.ts", "src/board/board/tilexy/ChessToTileXYZ.ts", "src/board/board/tilexy/Contains.ts", "src/board/board/chessdata/ChessData.ts", "src/board/board/chessdata/GetChessData.ts", "src/board/board/chess/GetAllChess.ts", "src/board/board/worldxy/TileXYToWorldXY.ts", "src/board/board/worldxy/GridAlign.ts", "src/board/board/chess/RemoveChess.ts", "src/board/board/chess/AddChess.ts", "src/utils/math/angle/Between.ts", "src/board/board/worldxy/AngleBetween.ts", "src/utils/math/Wrap.ts", "src/board/board/tilexy/GetWrapTileXY.ts", "src/board/board/tilexy/GetTileXYAtDirection.ts", "src/board/board/neighbors/GetNeighborTileXY.ts", "src/board/board/worldxy/AngleToward.ts", "src/utils/math/angle/RadToDeg.ts", "src/utils/math/angle/ShortestBetween.ts", "src/board/board/worldxy/AngleSnapToDirection.ts", "src/board/board/neighbors/GetNeighborTileDirection.ts", "src/board/board/neighbors/GetNeighborChessDirection.ts", "src/board/board/neighbors/AreNeighbors.ts", "src/board/board/tilexy/DirectionBetween.ts", "src/board/board/ring/RingToTileXYArray.ts", "src/board/board/ring/FilledRingToTileXYArray.ts", "src/board/board/transform/Offset.ts", "src/board/board/transform/Fit.ts", "src/board/board/tilexy/ForEachTileXY.ts", "src/board/board/tilexy/GetDistance.ts", "src/board/board/empty/GetEmptyTileXYArray.ts", "src/board/board/worldxy/GetGridPoints.ts", "src/board/board/tilexy/TileXYToChessArray.ts", "src/board/board/tilexy/TileXYArrayToChessArray.ts", "src/board/board/neighbors/GetNeighborChess.ts", "src/board/board/neighbors/GetNeighborTileXYAtAngle.ts", "src/board/board/tilexy/GetOppositeDirection.ts", "src/utils/math/RandomInt.ts", "src/utils/array/GetRandom.ts", "src/board/board/empty/GetRandomEmptyTileXY.ts", "src/board/board/blocker/HasBlocker.ts", "src/board/board/chess/HasChess.ts", "src/board/board/blocker/HasEdgeBlocker.ts", "src/utils/math/angle/Normalize.ts", "src/utils/math/fuzzy/Equal.ts", "src/board/board/worldxy/IsAngleInCone.ts", "src/board/board/tilexy/IsDirectionInCone.ts", "src/board/board/worldxy/WorldXYToTileXY.ts", "src/board/board/worldxy/IsOverlappingPoint.ts", "src/utils/math/distance/DistanceBetween.ts", "src/utils/math/Linear.ts", "src/board/board/shape/LineToTileXYArray.ts", "src/utils/types/VectorType.ts", "src/board/types.ts", "src/board/grid/IGrid.ts", "src/board/board/transform/Mirror.ts", "src/board/board/chess/RemoveAllChess.ts", "src/board/board/transform/Rotate.ts", "src/board/board/chess/SetTileZ.ts", "src/utils/types/BoundsType.ts", "src/utils/math/Clamp.ts", "src/board/board/shape/ShapeToTileXYArray.ts", "src/board/board/chess/SwapChess.ts", "src/board/board/tilexy/TileZToChessArray.ts", "src/board/board/worldxy/TileXYArrayToWorldXYArray.ts", "src/board/board/worldxy/WorldXYSnapToGrid.ts", "src/board/board/worldxy/WorldXYToChess.ts", "src/board/board/LogicBoard.ts", "src/board/board/Board.ts", "src/board/board/tilexy/index.ts", "src/board/board/worldxy/index.ts", "src/board/board/chess/index.ts", "src/board/board/blocker/index.ts", "src/board/board/empty/index.ts", "src/board/board/neighbors/index.ts", "src/board/board/transform/index.ts", "src/board/board/shape/index.ts", "src/board/board/ring/index.ts", "src/board/board/index.ts", "src/board/grid/quad/IQuadBase.ts", "src/board/grid/quad/QuadBase.ts", "src/board/grid/quad/DirectionBetween.ts", "src/board/grid/utils/DirectionNormalize.ts", "src/board/grid/quad/GetDistance.ts", "src/board/grid/utils/FillPositionArray.ts", "src/board/grid/quad/GetWorldXY.ts", "src/board/grid/quad/GetGridPoints.ts", "src/board/grid/quad/DirectionToDeltaXY.ts", "src/board/grid/quad/DeltaTileXYToDirection.ts", "src/board/grid/quad/GetNeighborTileDirection.ts", "src/board/grid/quad/GetTileXYAtDirection.ts", "src/board/grid/quad/GetNeighborTileXY.ts", "src/board/grid/quad/GetOppositeDirection.ts", "src/board/grid/quad/GetTileXY.ts", "src/board/grid/quad/Mirror.ts", "src/board/grid/quad/Offset.ts", "src/board/grid/quad/RingToTileXYArray.ts", "src/board/grid/quad/Rotate.ts", "src/board/grid/utils/SaveOrigin.ts", "src/board/grid/quad/Quad.ts", "src/board/grid/hexagon/IHexagonBase.ts", "src/board/grid/hexagon/HexagonBase.ts", "src/board/grid/hexagon/CubeTransfer.ts", "src/board/grid/hexagon/DirectionBetween.ts", "src/board/grid/hexagon/GetDistance.ts", "src/board/grid/hexagon/GetWorldXY.ts", "src/utils/math/angle/DegToRad.ts", "src/board/grid/hexagon/GetGridPoints.ts", "src/board/grid/hexagon/DirectionToDeltaTileXY.ts", "src/board/grid/hexagon/DeltaTileXYToDirection.ts", "src/board/grid/hexagon/GetParity.ts", "src/board/grid/hexagon/GetNeighborTileDirection.ts", "src/board/grid/hexagon/GetTileXYAtDirection.ts", "src/board/grid/hexagon/GetNeighborTileXY.ts", "src/board/grid/hexagon/GetOppositeDirection.ts", "src/board/grid/hexagon/GetTileXY.ts", "src/board/grid/hexagon/Mirror.ts", "src/board/grid/hexagon/Offset.ts", "src/board/grid/hexagon/RingToTileXYArray.ts", "src/board/grid/hexagon/Rotate.ts", "src/board/grid/hexagon/Hexagon.ts", "src/board/grid/index.ts", "src/utils/astar/types/PathMode.ts", "src/utils/astar/types/CreateNodeCallbackType.ts", "src/utils/astar/types/CostValueType.ts", "src/utils/astar/Const.ts", "src/utils/astar/IAStar.ts", "src/board/pathfinder/IPathFinder.ts", "src/utils/astar/NodeManager.ts", "src/utils/struct/BinaryHeap.ts", "src/utils/astar/Search.ts", "src/utils/astar/getnodepath/GetAStarNodePath.ts", "src/utils/astar/getnodepath/GetRandomNodePath.ts", "src/utils/astar/getnodepath/GetLineNodePath.ts", "src/utils/astar/getnodepath/GetDiagonalPath.ts", "src/utils/astar/getnodepath/GetStraightNodePath.ts", "src/utils/astar/getnodepath/GetNodePath.ts", "src/utils/astar/AStar.ts", "src/utils/astar/NodeBase.ts", "src/utils/array/Shuffle.ts", "src/board/utils/StringKey.ts", "src/board/pathfinder/astar/AStarNode.ts", "src/board/pathfinder/astar/CreateAStar.ts", "src/board/pathfinder/GetCost.ts", "src/board/utils/CopyTileXY.ts", "src/board/utils/CopyTileXYZ.ts", "src/board/utils/IsChess.ts", "src/board/utils/index.ts", "src/board/pathfinder/FindArea.ts", "src/board/pathfinder/GetPath.ts", "src/board/pathfinder/FindPath.ts", "src/board/pathfinder/TileXYToCost.ts", "src/board/pathfinder/PathFinder.ts", "src/board/pathfinder/index.ts", "src/board/match/MatchAtDir.ts", "src/board/match/MatchBoard.ts", "src/board/match/Group.ts", "src/board/match/Match.ts", "src/board/match/index.ts", "src/board/fieldofview/IFieldOfView.ts", "src/board/fieldofview/IsInCone.ts", "src/board/fieldofview/GetCost.ts", "src/board/fieldofview/IsPathVisible.ts", "src/board/fieldofview/IsInLOS.ts", "src/board/fieldofview/LOS.ts", "src/board/fieldofview/FindFOV.ts", "src/board/fieldofview/FieldOfView.ts", "src/board/fieldofview/index.ts", "src/board/hexagonmap/GetHexagonMap.ts", "src/board/hexagonmap/GetTriangleMap.ts", "src/board/hexagonmap/GetParallelogramMap.ts", "src/board/hexagonmap/index.ts", "src/board/index.ts", "node_modules/@phaserjs/phaser/textures/types/CanvasTexture.js", "src/texture/canvastexture/DrawCanvasTexture.ts", "src/utils/canvas/GetStyle.ts", "src/texture/canvastexture/CreateCircleTexture.ts", "src/texture/canvastexture/CreateRectangleTexture.ts", "src/texture/canvastexture/CreatePolygonTexture.ts", "src/texture/canvastexture/CreateTriangleTexture.ts", "src/texture/canvastexture/index.ts", "examples/board-fieldofview/fov.ts"],
  "sourcesContent": ["let instance;\r\nlet frame = 0;\r\nlet elapsed = 0;\r\nconst GameInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (game) => {\r\n        instance = game;\r\n    },\r\n    getFrame: () => {\r\n        return frame;\r\n    },\r\n    setFrame: (current) => {\r\n        frame = current;\r\n    },\r\n    getElapsed: () => {\r\n        return elapsed;\r\n    },\r\n    setElapsed: (current) => {\r\n        elapsed = current;\r\n    }\r\n};\n\nexport { GameInstance, elapsed, frame, instance };\n", "let bgColor = 0;\r\nfunction BackgroundColor(color = 0) {\r\n    return () => {\r\n        bgColor = color;\r\n    };\r\n}\r\nfunction GetBackgroundColor() {\r\n    return bgColor;\r\n}\n\nexport { BackgroundColor, GetBackgroundColor };\n", "import { GameInstance } from '../GameInstance.js';\n\nlet title = 'Phaser';\r\nlet url = 'https://phaser4.io';\r\nlet color = '#fff';\r\nlet background = 'linear-gradient(#3e0081 40%, #00bcc3)';\r\nfunction Banner(gameTitle = '', gameURL = '', textColor, textBackground) {\r\n    return () => {\r\n        title = gameTitle;\r\n        url = gameURL;\r\n        if (textColor) {\r\n            color = textColor;\r\n        }\r\n        if (textBackground) {\r\n            background = textBackground;\r\n        }\r\n    };\r\n}\r\nfunction GetBanner() {\r\n    if (title !== '') {\r\n        const game = GameInstance.get();\r\n        const version = (title === 'Phaser') ? ' v' + game.VERSION : '';\r\n        console.log(`%c${title}${version}%c ${url}`, `padding: 4px 16px; color: ${color}; background: ${background}`, '');\r\n    }\r\n}\n\nexport { Banner, GetBanner };\n", "let _contextAttributes = {\r\n    alpha: false,\r\n    desynchronized: false\r\n};\r\nfunction CanvasContext(contextAttributes) {\r\n    return () => {\r\n        _contextAttributes = contextAttributes;\r\n    };\r\n}\r\nfunction GetCanvasContext() {\r\n    return _contextAttributes;\r\n}\n\nexport { CanvasContext, GetCanvasContext };\n", "let _width = 800;\r\nlet _height = 600;\r\nlet _resolution = 1;\r\nfunction Size(width = 800, height = 600, resolution = 1) {\r\n    if (resolution === 0) {\r\n        resolution = window.devicePixelRatio;\r\n    }\r\n    return () => {\r\n        _width = width;\r\n        _height = height;\r\n        _resolution = resolution;\r\n    };\r\n}\r\nfunction GetWidth() {\r\n    return _width;\r\n}\r\nfunction GetHeight() {\r\n    return _height;\r\n}\r\nfunction GetResolution() {\r\n    return _resolution;\r\n}\n\nexport { GetHeight, GetResolution, GetWidth, Size };\n", "const queue = [];\r\nconst BindingQueue = {\r\n    add: (texture) => {\r\n        queue.push(texture);\r\n    },\r\n    get: () => {\r\n        return queue;\r\n    },\r\n    clear: () => {\r\n        queue.length = 0;\r\n    }\r\n};\n\nexport { BindingQueue };\n", "import { GetBackgroundColor } from '../../config/BackgroundColor.js';\nimport { GetCanvasContext } from '../../config/CanvasContext.js';\nimport { GetWidth, GetHeight, GetResolution } from '../../config/Size.js';\nimport { BindingQueue } from '../BindingQueue.js';\n\nclass CanvasRenderer {\r\n    constructor() {\r\n        this.clearBeforeRender = true;\r\n        this.optimizeRedraw = true;\r\n        this.autoResize = true;\r\n        this.width = GetWidth();\r\n        this.height = GetHeight();\r\n        this.resolution = GetResolution();\r\n        this.setBackgroundColor(GetBackgroundColor());\r\n        const canvas = document.createElement('canvas');\r\n        this.canvas = canvas;\r\n        this.initContext();\r\n    }\r\n    initContext() {\r\n        const ctx = this.canvas.getContext('2d', GetCanvasContext());\r\n        this.ctx = ctx;\r\n        this.resize(this.width, this.height, this.resolution);\r\n    }\r\n    resize(width, height, resolution = 1) {\r\n        this.width = width * resolution;\r\n        this.height = height * resolution;\r\n        this.resolution = resolution;\r\n        const canvas = this.canvas;\r\n        canvas.width = this.width;\r\n        canvas.height = this.height;\r\n        if (this.autoResize) {\r\n            canvas.style.width = (this.width / resolution).toString() + 'px';\r\n            canvas.style.height = (this.height / resolution).toString() + 'px';\r\n        }\r\n    }\r\n    setBackgroundColor(color) {\r\n        const r = color >> 16 & 0xFF;\r\n        const g = color >> 8 & 0xFF;\r\n        const b = color & 0xFF;\r\n        const a = (color > 16777215) ? color >>> 24 : 255;\r\n        this.clearColor = `rgba(${r}, ${g}, ${b}, ${a})`;\r\n        return this;\r\n    }\r\n    reset() {\r\n        const ctx = this.ctx;\r\n        ctx.globalAlpha = 1;\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n    }\r\n    render(renderData) {\r\n        BindingQueue.clear();\r\n        const ctx = this.ctx;\r\n        if (this.optimizeRedraw && renderData.numDirtyFrames === 0 && renderData.numDirtyCameras === 0) {\r\n            return;\r\n        }\r\n        this.reset();\r\n        if (this.clearBeforeRender) {\r\n            ctx.clearRect(0, 0, this.width, this.height);\r\n            ctx.fillStyle = this.clearColor;\r\n            ctx.fillRect(0, 0, this.width, this.height);\r\n        }\r\n        const worlds = renderData.worldData;\r\n        for (let i = 0; i < worlds.length; i++) {\r\n            const { camera, renderList, numRendered } = worlds[i];\r\n            const { a, b, c, d, tx, ty } = camera.worldTransform;\r\n            ctx.setTransform(a, b, c, d, tx, ty);\r\n        }\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { CanvasRenderer };\n", "let instance;\r\nfunction SetRenderer(renderer) {\r\n    instance = renderer;\r\n}\r\nfunction GetRenderer() {\r\n    return instance;\r\n}\n\nexport { GetRenderer, SetRenderer };\n", "import './BackgroundColor.js';\nimport './CanvasContext.js';\nimport './Size.js';\nimport '../renderer/BindingQueue.js';\nimport { CanvasRenderer as CanvasRenderer$1 } from '../renderer/canvas/CanvasRenderer.js';\nimport { SetRenderer } from './SetRenderer.js';\n\nfunction CanvasRenderer() {\r\n    return () => {\r\n        SetRenderer(CanvasRenderer$1);\r\n    };\r\n}\n\nexport { CanvasRenderer };\n", "let originX = 0.5;\r\nlet originY = 0.5;\r\nfunction DefaultOrigin(x = 0.5, y = x) {\r\n    return () => {\r\n        originX = x;\r\n        originY = y;\r\n    };\r\n}\n\nexport { DefaultOrigin, originX, originY };\n", "let maxTextures = 0;\r\nfunction MaxTextures(max = 0) {\r\n    return () => {\r\n        maxTextures = max;\r\n    };\r\n}\r\nfunction SetMaxTextures(max) {\r\n    maxTextures = max;\r\n}\r\nfunction GetMaxTextures() {\r\n    return maxTextures;\r\n}\n\nexport { GetMaxTextures, MaxTextures, SetMaxTextures };\n", "function GetElement(target) {\r\n    let element;\r\n    if (target) {\r\n        if (typeof target === 'string') {\r\n            element = document.getElementById(target);\r\n        }\r\n        else if (typeof target === 'object' && target.nodeType === 1) {\r\n            element = target;\r\n        }\r\n    }\r\n    if (!element) {\r\n        element = document.body;\r\n    }\r\n    return element;\r\n}\n\nexport { GetElement };\n", "import { GetElement } from '../dom/GetElement.js';\n\nlet parent;\r\nfunction Parent(parentElement) {\r\n    return () => {\r\n        if (parentElement) {\r\n            parent = GetElement(parentElement);\r\n        }\r\n    };\r\n}\r\nfunction GetParent() {\r\n    return parent;\r\n}\n\nexport { GetParent, Parent };\n", "let _scenes = [];\r\nfunction Scenes(scenes) {\r\n    return () => {\r\n        _scenes = [].concat(scenes);\r\n    };\r\n}\r\nfunction GetScenes() {\r\n    return _scenes;\r\n}\n\nexport { GetScenes, Scenes };\n", "let _contextAttributes = {\r\n    alpha: false,\r\n    antialias: false,\r\n    depth: false,\r\n    premultipliedAlpha: false\r\n};\r\nfunction WebGLContext(contextAttributes) {\r\n    return () => {\r\n        _contextAttributes = contextAttributes;\r\n    };\r\n}\r\nfunction GetWebGLContext() {\r\n    return _contextAttributes;\r\n}\n\nexport { GetWebGLContext, WebGLContext };\n", "class FBOSystem {\r\n    constructor(renderer) {\r\n        this.stack = [];\r\n        this.current = null;\r\n        this.renderer = renderer;\r\n    }\r\n    reset() {\r\n        this.stack = [];\r\n        this.current = null;\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.viewport(0, 0, renderer.width, renderer.height);\r\n    }\r\n    add(framebuffer, clear = true, width = 0, height = 0) {\r\n        this.stack.push({ framebuffer, width, height });\r\n        this.set(framebuffer, clear, width, height);\r\n    }\r\n    set(framebuffer, clear = true, width = 0, height = 0) {\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        if (clear) {\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n        if (width > 0) {\r\n            gl.viewport(0, 0, width, height);\r\n        }\r\n        this.current = framebuffer;\r\n    }\r\n    pop() {\r\n        this.stack.pop();\r\n        const len = this.stack.length;\r\n        if (len > 0) {\r\n            const entry = this.stack[len - 1];\r\n            this.set(entry.framebuffer, false, entry.width, entry.height);\r\n        }\r\n        else {\r\n            this.reset();\r\n        }\r\n    }\r\n    rebind() {\r\n        const gl = this.renderer.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.current);\r\n    }\r\n    destroy() {\r\n        this.stack = [];\r\n    }\r\n}\n\nexport { FBOSystem };\n", "let gl;\r\nconst GL = {\r\n    get: () => {\r\n        return gl;\r\n    },\r\n    set: (context) => {\r\n        gl = context;\r\n    }\r\n};\n\nexport { GL };\n", "function GetRGBArray(color, output = []) {\r\n    const r = color >> 16 & 0xFF;\r\n    const g = color >> 8 & 0xFF;\r\n    const b = color & 0xFF;\r\n    const a = (color > 16777215) ? color >>> 24 : 255;\r\n    output[0] = r / 255;\r\n    output[1] = g / 255;\r\n    output[2] = b / 255;\r\n    output[3] = a / 255;\r\n    return output;\r\n}\n\nexport { GetRGBArray };\n", "function ExactEquals(a, b) {\r\n    return (a.a === b.a &&\r\n        a.b === b.b &&\r\n        a.c === b.c &&\r\n        a.d === b.d &&\r\n        a.tx === b.tx &&\r\n        a.ty === b.ty);\r\n}\n\nexport { ExactEquals };\n", "import { GL } from '../GL.js';\n\nfunction CreateFramebuffer(texture, attachment) {\r\n    const gl = GL.get();\r\n    if (!attachment) {\r\n        attachment = gl.COLOR_ATTACHMENT0;\r\n    }\r\n    const framebuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, 0);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    return framebuffer;\r\n}\n\nexport { CreateFramebuffer };\n", "import { GL } from '../GL.js';\n\nfunction CreateGLTexture(binding) {\r\n    const gl = GL.get();\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const { parent, flipY, unpackPremultiplyAlpha, minFilter, magFilter, wrapS, wrapT, generateMipmap, isPOT } = binding;\r\n    const source = parent.image;\r\n    let width = parent.width;\r\n    let height = parent.height;\r\n    const glTexture = gl.createTexture();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\r\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, unpackPremultiplyAlpha);\r\n    if (source) {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n        width = source.width;\r\n        height = source.height;\r\n    }\r\n    else {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n    }\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n    if (generateMipmap && isPOT) {\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    binding.texture = glTexture;\r\n    return glTexture;\r\n}\n\nexport { CreateGLTexture };\n", "import { GL } from '../GL.js';\n\nfunction DeleteFramebuffer(framebuffer) {\r\n    const gl = GL.get();\r\n    if (gl && gl.isFramebuffer(framebuffer)) {\r\n        gl.deleteFramebuffer(framebuffer);\r\n    }\r\n}\n\nexport { DeleteFramebuffer };\n", "import { GL } from '../GL.js';\n\nfunction DeleteGLTexture(texture) {\r\n    const gl = GL.get();\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    if (gl.isTexture(texture)) {\r\n        gl.deleteTexture(texture);\r\n    }\r\n}\n\nexport { DeleteGLTexture };\n", "function IsSizePowerOfTwo(width, height) {\r\n    if (width < 1 || height < 1) {\r\n        return false;\r\n    }\r\n    return ((width & (width - 1)) === 0) && ((height & (height - 1)) === 0);\r\n}\n\nexport { IsSizePowerOfTwo };\n", "import { GL } from '../GL.js';\n\nfunction SetGLTextureFilterMode(texture, linear = true) {\r\n    const gl = GL.get();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    const mode = (linear) ? gl.LINEAR : gl.NEAREST;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);\r\n}\n\nexport { SetGLTextureFilterMode };\n", "import { GL } from '../GL.js';\n\nfunction UpdateGLTexture(binding) {\r\n    const gl = GL.get();\r\n    const source = binding.parent.image;\r\n    const width = source.width;\r\n    const height = source.height;\r\n    if (width > 0 && height > 0) {\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, binding.flipY);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n    }\r\n    return binding.texture;\r\n}\n\nexport { UpdateGLTexture };\n", "import { GL } from '../GL.js';\nimport { CreateGLTexture } from './CreateGLTexture.js';\nimport { DeleteFramebuffer } from '../fbo/DeleteFramebuffer.js';\nimport { DeleteGLTexture } from './DeleteGLTexture.js';\nimport { IsSizePowerOfTwo } from '../../../math/pow2/IsSizePowerOfTwo.js';\nimport { SetGLTextureFilterMode } from './SetGLTextureFilterMode.js';\nimport { UpdateGLTexture } from './UpdateGLTexture.js';\n\nclass GLTextureBinding {\r\n    constructor(parent, config = {}) {\r\n        this.index = 0;\r\n        this.indexCounter = -1;\r\n        this.dirtyIndex = true;\r\n        this.unpackPremultiplyAlpha = true;\r\n        this.flipY = false;\r\n        this.isPOT = false;\r\n        this.generateMipmap = false;\r\n        const gl = GL.get();\r\n        this.parent = parent;\r\n        this.isPOT = IsSizePowerOfTwo(parent.width, parent.height);\r\n        const { texture = null, framebuffer = null, unpackPremultiplyAlpha = true, minFilter = gl.LINEAR, magFilter = gl.LINEAR, wrapS = gl.CLAMP_TO_EDGE, wrapT = gl.CLAMP_TO_EDGE, generateMipmap = this.isPOT, flipY = false } = config;\r\n        this.minFilter = minFilter;\r\n        this.magFilter = magFilter;\r\n        this.wrapS = wrapS;\r\n        this.wrapT = wrapT;\r\n        this.generateMipmap = generateMipmap;\r\n        this.flipY = flipY;\r\n        this.unpackPremultiplyAlpha = unpackPremultiplyAlpha;\r\n        if (framebuffer) {\r\n            this.framebuffer = framebuffer;\r\n        }\r\n        if (texture) {\r\n            this.texture = texture;\r\n        }\r\n        else {\r\n            CreateGLTexture(this);\r\n        }\r\n    }\r\n    setFilter(linear) {\r\n        if (this.texture) {\r\n            SetGLTextureFilterMode(this.texture, linear);\r\n        }\r\n    }\r\n    create() {\r\n        const texture = this.texture;\r\n        if (texture) {\r\n            DeleteGLTexture(texture);\r\n        }\r\n        return CreateGLTexture(this);\r\n    }\r\n    update() {\r\n        const texture = this.texture;\r\n        if (!texture) {\r\n            return CreateGLTexture(this);\r\n        }\r\n        else {\r\n            return UpdateGLTexture(this);\r\n        }\r\n    }\r\n    setIndex(index) {\r\n        this.dirtyIndex = (index !== this.index);\r\n        this.index = index;\r\n    }\r\n    destroy() {\r\n        DeleteGLTexture(this.texture);\r\n        DeleteFramebuffer(this.framebuffer);\r\n        this.parent = null;\r\n        this.texture = null;\r\n        this.framebuffer = null;\r\n    }\r\n}\n\nexport { GLTextureBinding };\n", "import { GL } from '../GL.js';\n\nclass IndexedBuffer {\r\n    constructor(batchSize, dataSize, indexSize, vertexElementSize, quadIndexSize) {\r\n        this.batchSize = batchSize;\r\n        this.dataSize = dataSize;\r\n        this.indexSize = indexSize;\r\n        this.vertexElementSize = vertexElementSize;\r\n        this.quadIndexSize = quadIndexSize;\r\n        this.vertexByteSize = vertexElementSize * dataSize;\r\n        this.quadByteSize = this.vertexByteSize * 4;\r\n        this.quadElementSize = vertexElementSize * 4;\r\n        this.bufferByteSize = batchSize * this.quadByteSize;\r\n        this.create();\r\n    }\r\n    create() {\r\n        let ibo = [];\r\n        for (let i = 0; i < (this.batchSize * this.indexSize); i += this.indexSize) {\r\n            ibo.push(i + 0, i + 1, i + 2, i + 2, i + 3, i + 0);\r\n        }\r\n        this.data = new ArrayBuffer(this.bufferByteSize);\r\n        this.index = new Uint16Array(ibo);\r\n        this.vertexViewF32 = new Float32Array(this.data);\r\n        this.vertexViewU32 = new Uint32Array(this.data);\r\n        const gl = GL.get();\r\n        this.vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);\r\n        this.indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.index, gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        ibo = [];\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { IndexedBuffer };\n", "class Frame {\r\n    constructor(texture, key, x, y, width, height) {\r\n        this.trimmed = false;\r\n        this.texture = texture;\r\n        this.key = key;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.updateUVs();\r\n    }\r\n    setPivot(x, y) {\r\n        this.pivot = { x, y };\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.updateUVs();\r\n    }\r\n    setSourceSize(width, height) {\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n    }\r\n    setTrim(width, height, x, y, w, h) {\r\n        this.trimmed = true;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.spriteSourceSizeX = x;\r\n        this.spriteSourceSizeY = y;\r\n        this.spriteSourceSizeWidth = w;\r\n        this.spriteSourceSizeHeight = h;\r\n    }\r\n    getExtent(originX, originY) {\r\n        const sourceSizeWidth = this.sourceSizeWidth;\r\n        const sourceSizeHeight = this.sourceSizeHeight;\r\n        let left;\r\n        let right;\r\n        let top;\r\n        let bottom;\r\n        if (this.trimmed) {\r\n            left = this.spriteSourceSizeX - (originX * sourceSizeWidth);\r\n            right = left + this.spriteSourceSizeWidth;\r\n            top = this.spriteSourceSizeY - (originY * sourceSizeHeight);\r\n            bottom = top + this.spriteSourceSizeHeight;\r\n        }\r\n        else {\r\n            left = -originX * sourceSizeWidth;\r\n            right = left + sourceSizeWidth;\r\n            top = -originY * sourceSizeHeight;\r\n            bottom = top + sourceSizeHeight;\r\n        }\r\n        return { left, right, top, bottom };\r\n    }\r\n    setExtent(child) {\r\n        const transform = child.transform;\r\n        const originX = transform.origin.x;\r\n        const originY = transform.origin.y;\r\n        const sourceSizeWidth = this.sourceSizeWidth;\r\n        const sourceSizeHeight = this.sourceSizeHeight;\r\n        let x;\r\n        let y;\r\n        let width;\r\n        let height;\r\n        if (this.trimmed) {\r\n            x = this.spriteSourceSizeX - (originX * sourceSizeWidth);\r\n            y = this.spriteSourceSizeY - (originY * sourceSizeHeight);\r\n            width = this.spriteSourceSizeWidth;\r\n            height = this.spriteSourceSizeHeight;\r\n        }\r\n        else {\r\n            x = -originX * sourceSizeWidth;\r\n            y = -originY * sourceSizeHeight;\r\n            width = sourceSizeWidth;\r\n            height = sourceSizeHeight;\r\n        }\r\n        transform.setExtent(x, y, width, height);\r\n    }\r\n    updateUVs() {\r\n        const { x, y, width, height } = this;\r\n        const baseTextureWidth = this.texture.width;\r\n        const baseTextureHeight = this.texture.height;\r\n        this.u0 = x / baseTextureWidth;\r\n        this.v0 = y / baseTextureHeight;\r\n        this.u1 = (x + width) / baseTextureWidth;\r\n        this.v1 = (y + height) / baseTextureHeight;\r\n    }\r\n}\n\nexport { Frame };\n", "import { BindingQueue } from '../renderer/BindingQueue.js';\nimport { Frame } from './Frame.js';\n\nclass Texture {\r\n    constructor(image, width, height) {\r\n        this.key = '';\r\n        if (image) {\r\n            width = image.width;\r\n            height = image.height;\r\n        }\r\n        this.image = image;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.frames = new Map();\r\n        this.data = {};\r\n        this.addFrame('__BASE', 0, 0, width, height);\r\n        BindingQueue.add(this);\r\n    }\r\n    addFrame(key, x, y, width, height) {\r\n        if (this.frames.has(key)) {\r\n            return null;\r\n        }\r\n        const frame = new Frame(this, key, x, y, width, height);\r\n        this.frames.set(key, frame);\r\n        if (!this.firstFrame || this.firstFrame.key === '__BASE') {\r\n            this.firstFrame = frame;\r\n        }\r\n        return frame;\r\n    }\r\n    getFrame(key) {\r\n        if (!key) {\r\n            return this.firstFrame;\r\n        }\r\n        if (key instanceof Frame) {\r\n            key = key.key;\r\n        }\r\n        let frame = this.frames.get(key);\r\n        if (!frame) {\r\n            console.warn(`Frame missing: ${key}`);\r\n            frame = this.firstFrame;\r\n        }\r\n        return frame;\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        const frame = this.frames.get('__BASE');\r\n        frame.setSize(width, height);\r\n    }\r\n    destroy() {\r\n        if (this.binding) {\r\n            this.binding.destroy();\r\n        }\r\n        this.frames.clear();\r\n        this.data = null;\r\n        this.image = null;\r\n        this.firstFrame = null;\r\n    }\r\n}\n\nexport { Texture };\n", "let instance;\r\nconst WebGLRendererInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (renderer) => {\r\n        instance = renderer;\r\n    }\r\n};\n\nexport { WebGLRendererInstance, instance };\n", "import { GetWidth, GetHeight, GetResolution } from '../../../config/Size.js';\nimport '../../BindingQueue.js';\nimport '../GL.js';\nimport { CreateFramebuffer } from '../fbo/CreateFramebuffer.js';\nimport '../textures/CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport '../textures/DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport '../textures/SetGLTextureFilterMode.js';\nimport '../textures/UpdateGLTexture.js';\nimport { GLTextureBinding } from '../textures/GLTextureBinding.js';\nimport { IndexedBuffer } from '../buffers/IndexedBuffer.js';\nimport '../../../textures/Frame.js';\nimport { Texture } from '../../../textures/Texture.js';\nimport { WebGLRendererInstance } from '../WebGLRendererInstance.js';\n\nconst shaderSource = {\r\n    fragmentShader: `\r\n#define SHADER_NAME SINGLE_QUAD_FRAG\r\n\r\nprecision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nuniform sampler2D uTexture;\r\n\r\nvoid main (void)\r\n{\r\n    vec4 color = texture2D(uTexture, vTextureCoord);\r\n\r\n    gl_FragColor = color * vec4(vTintColor.bgr * vTintColor.a, vTintColor.a);\r\n}`,\r\n    vertexShader: `\r\n#define SHADER_NAME SINGLE_QUAD_VERT\r\n\r\nprecision highp float;\r\n\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute float aTextureId;\r\nattribute vec4 aTintColor;\r\n\r\nuniform mat4 uProjectionMatrix;\r\nuniform mat4 uCameraMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nvoid main (void)\r\n{\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vTintColor = aTintColor;\r\n\r\n    gl_Position = uProjectionMatrix * uCameraMatrix * vec4(aVertexPosition, 0.0, 1.0);\r\n}`\r\n};\r\nclass SingleTextureQuadShader {\r\n    constructor(config = {}) {\r\n        this.attribs = { aVertexPosition: 0, aTextureCoord: 0, aTextureId: 0, aTintColor: 0 };\r\n        this.uniforms = { uProjectionMatrix: 0, uCameraMatrix: 0, uTexture: 0, uTime: 0, uResolution: 0 };\r\n        this.renderToFBO = false;\r\n        this.renderer = WebGLRendererInstance.get();\r\n        const { batchSize = 4096, dataSize = 4, indexSize = 4, vertexElementSize = 6, quadIndexSize = 6, fragmentShader = shaderSource.fragmentShader, vertexShader = shaderSource.vertexShader, width = GetWidth(), height = GetHeight(), resolution = GetResolution(), renderToFBO = false } = config;\r\n        this.buffer = new IndexedBuffer(batchSize, dataSize, indexSize, vertexElementSize, quadIndexSize);\r\n        this.createShaders(fragmentShader, vertexShader);\r\n        this.count = 0;\r\n        this.renderToFBO = renderToFBO;\r\n        const texture = new Texture(null, width * resolution, height * resolution);\r\n        const binding = new GLTextureBinding(texture);\r\n        texture.binding = binding;\r\n        binding.framebuffer = CreateFramebuffer(binding.texture);\r\n        this.texture = texture;\r\n        this.framebuffer = binding.framebuffer;\r\n    }\r\n    createShaders(fragmentShaderSource, vertexShaderSource) {\r\n        const gl = this.renderer.gl;\r\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n        gl.compileShader(fragmentShader);\r\n        let failed = false;\r\n        let message = gl.getShaderInfoLog(fragmentShader);\r\n        if (message.length > 0) {\r\n            failed = true;\r\n            console.error(message);\r\n        }\r\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertexShader, vertexShaderSource);\r\n        gl.compileShader(vertexShader);\r\n        message = gl.getShaderInfoLog(fragmentShader);\r\n        if (message.length > 0) {\r\n            failed = true;\r\n            console.error(message);\r\n        }\r\n        if (failed) {\r\n            return;\r\n        }\r\n        const program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n        gl.useProgram(program);\r\n        this.program = program;\r\n        for (const key of Object.keys(this.attribs)) {\r\n            const location = gl.getAttribLocation(program, key);\r\n            gl.enableVertexAttribArray(location);\r\n            this.attribs[key] = location;\r\n        }\r\n        for (const key of Object.keys(this.uniforms)) {\r\n            this.uniforms[key] = gl.getUniformLocation(program, key);\r\n        }\r\n    }\r\n    bind(projectionMatrix, cameraMatrix, textureID) {\r\n        if (!this.program) {\r\n            return false;\r\n        }\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        const uniforms = this.uniforms;\r\n        gl.useProgram(this.program);\r\n        gl.uniformMatrix4fv(uniforms.uProjectionMatrix, false, projectionMatrix);\r\n        gl.uniformMatrix4fv(uniforms.uCameraMatrix, false, cameraMatrix);\r\n        gl.uniform1i(uniforms.uTexture, renderer.textures.textureIndex[textureID]);\r\n        gl.uniform1f(uniforms.uTime, performance.now());\r\n        gl.uniform2f(uniforms.uResolution, renderer.width, renderer.height);\r\n        this.bindBuffers(this.buffer.indexBuffer, this.buffer.vertexBuffer);\r\n        return true;\r\n    }\r\n    bindBuffers(indexBuffer, vertexBuffer) {\r\n        const gl = this.renderer.gl;\r\n        const stride = this.buffer.vertexByteSize;\r\n        const attribs = this.attribs;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.vertexAttribPointer(attribs.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\r\n        gl.vertexAttribPointer(attribs.aTextureCoord, 2, gl.FLOAT, false, stride, 8);\r\n        gl.vertexAttribPointer(attribs.aTextureId, 1, gl.FLOAT, false, stride, 16);\r\n        gl.vertexAttribPointer(attribs.aTintColor, 4, gl.UNSIGNED_BYTE, true, stride, 20);\r\n        this.count = 0;\r\n    }\r\n    draw(count) {\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        const buffer = this.buffer;\r\n        if (count === buffer.batchSize) {\r\n            gl.bufferData(gl.ARRAY_BUFFER, buffer.data, gl.DYNAMIC_DRAW);\r\n        }\r\n        else {\r\n            const view = buffer.vertexViewF32.subarray(0, count * buffer.quadElementSize);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\r\n        }\r\n        if (this.renderToFBO) {\r\n            renderer.fbo.add(this.framebuffer, true);\r\n        }\r\n        gl.drawElements(gl.TRIANGLES, count * buffer.quadIndexSize, gl.UNSIGNED_SHORT, 0);\r\n        if (this.renderToFBO) {\r\n            renderer.fbo.pop();\r\n        }\r\n    }\r\n    flush() {\r\n        const count = this.count;\r\n        if (count === 0) {\r\n            return false;\r\n        }\r\n        this.draw(count);\r\n        this.prevCount = count;\r\n        this.count = 0;\r\n        return true;\r\n    }\r\n}\n\nexport { SingleTextureQuadShader };\n", "import '../../../config/Size.js';\nimport '../../BindingQueue.js';\nimport { GetMaxTextures } from '../../../config/MaxTextures.js';\nimport '../GL.js';\nimport '../fbo/CreateFramebuffer.js';\nimport '../textures/CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport '../textures/DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport '../textures/SetGLTextureFilterMode.js';\nimport '../textures/UpdateGLTexture.js';\nimport '../textures/GLTextureBinding.js';\nimport '../buffers/IndexedBuffer.js';\nimport '../../../textures/Frame.js';\nimport '../../../textures/Texture.js';\nimport '../WebGLRendererInstance.js';\nimport { SingleTextureQuadShader } from './SingleTextureQuadShader.js';\n\nconst fragmentShader = `\r\n#define SHADER_NAME MULTI_QUAD_FRAG\r\n\r\nprecision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nuniform sampler2D uTexture[%count%];\r\n\r\nvoid main (void)\r\n{\r\n    vec4 color;\r\n\r\n    %forloop%\r\n\r\n    gl_FragColor = color * vec4(vTintColor.bgr * vTintColor.a, vTintColor.a);\r\n}`;\r\nclass MultiTextureQuadShader extends SingleTextureQuadShader {\r\n    constructor(config = { fragmentShader }) {\r\n        super(config);\r\n    }\r\n    createShaders(fragmentShaderSource, vertexShaderSource) {\r\n        const maxTextures = GetMaxTextures();\r\n        let src = '';\r\n        for (let i = 1; i < maxTextures; i++) {\r\n            if (i > 1) {\r\n                src += '\\n\\telse ';\r\n            }\r\n            if (i < maxTextures - 1) {\r\n                src += `if (vTextureId < ${i}.5)`;\r\n            }\r\n            src += '\\n\\t{';\r\n            src += `\\n\\t\\tcolor = texture2D(uTexture[${i}], vTextureCoord);`;\r\n            src += '\\n\\t}';\r\n        }\r\n        fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, `${maxTextures}`);\r\n        fragmentShaderSource = fragmentShaderSource.replace(/%forloop%/gi, src);\r\n        super.createShaders(fragmentShaderSource, vertexShaderSource);\r\n    }\r\n    bind(projectionMatrix, cameraMatrix) {\r\n        if (!this.program) {\r\n            return false;\r\n        }\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        const uniforms = this.uniforms;\r\n        gl.useProgram(this.program);\r\n        gl.uniformMatrix4fv(uniforms.uProjectionMatrix, false, projectionMatrix);\r\n        gl.uniformMatrix4fv(uniforms.uCameraMatrix, false, cameraMatrix);\r\n        gl.uniform1iv(uniforms.uTexture, renderer.textures.textureIndex);\r\n        gl.uniform1f(uniforms.uTime, performance.now());\r\n        gl.uniform2f(uniforms.uResolution, renderer.width, renderer.height);\r\n        this.bindBuffers(this.buffer.indexBuffer, this.buffer.vertexBuffer);\r\n        return true;\r\n    }\r\n}\n\nexport { MultiTextureQuadShader };\n", "function Ortho(width, height, near = -1, far = 1) {\r\n    const m00 = -2 * (1 / -width);\r\n    const m11 = -2 * (1 / height);\r\n    const m22 = 2 * (1 / (near - far));\r\n    return new Float32Array([m00, 0, 0, 0, 0, m11, 0, 0, 0, 0, m22, 0, -1, 1, 0, 1]);\r\n}\n\nexport { Ortho };\n", "import '../../../config/Size.js';\nimport '../../BindingQueue.js';\nimport '../GL.js';\nimport '../fbo/CreateFramebuffer.js';\nimport '../textures/CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport '../textures/DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport '../textures/SetGLTextureFilterMode.js';\nimport '../textures/UpdateGLTexture.js';\nimport '../textures/GLTextureBinding.js';\nimport '../buffers/IndexedBuffer.js';\nimport '../../../textures/Frame.js';\nimport '../../../textures/Texture.js';\nimport '../WebGLRendererInstance.js';\nimport { SingleTextureQuadShader } from './SingleTextureQuadShader.js';\n\nclass ShaderSystem {\r\n    constructor(renderer, currentShader) {\r\n        this.renderer = renderer;\r\n        const stackEntry = {\r\n            shader: new currentShader()\r\n        };\r\n        this.stack = [stackEntry];\r\n        this.currentEntry = stackEntry;\r\n        this.current = stackEntry.shader;\r\n        this.singleQuadShader = new SingleTextureQuadShader();\r\n    }\r\n    add(shader, textureID) {\r\n        const stackEntry = { shader, textureID };\r\n        this.stack.push(stackEntry);\r\n        return stackEntry;\r\n    }\r\n    set(shader, textureID) {\r\n        this.flush();\r\n        const renderer = this.renderer;\r\n        const projectionMatrix = renderer.projectionMatrix;\r\n        const cameraMatrix = renderer.currentCamera.matrix;\r\n        const success = shader.bind(projectionMatrix, cameraMatrix, textureID);\r\n        if (success) {\r\n            const entry = this.add(shader, textureID);\r\n            this.currentEntry = entry;\r\n            this.current = shader;\r\n        }\r\n        return success;\r\n    }\r\n    setDefault(textureID) {\r\n        this.set(this.singleQuadShader, textureID);\r\n    }\r\n    pop() {\r\n        this.flush();\r\n        const stack = this.stack;\r\n        if (stack.length > 1) {\r\n            stack.pop();\r\n        }\r\n        this.currentEntry = stack[stack.length - 1];\r\n        this.current = this.currentEntry.shader;\r\n    }\r\n    reset() {\r\n        this.pop();\r\n        this.rebind();\r\n    }\r\n    flush() {\r\n        if (this.current.flush()) {\r\n            this.renderer.flushTotal++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    rebind() {\r\n        const renderer = this.renderer;\r\n        const projectionMatrix = renderer.projectionMatrix;\r\n        const cameraMatrix = renderer.currentCamera.matrix;\r\n        const current = this.currentEntry;\r\n        current.shader.bind(projectionMatrix, cameraMatrix, current.textureID);\r\n    }\r\n    popAndRebind() {\r\n        this.pop();\r\n        this.rebind();\r\n    }\r\n    clear() {\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { ShaderSystem };\n", "const fragTemplate = [\r\n    'precision mediump float;',\r\n    'void main(void){',\r\n    'float test = 0.1;',\r\n    '%forloop%',\r\n    'gl_FragColor = vec4(0.0);',\r\n    '}'\r\n].join('\\n');\r\nfunction GenerateSrc(maxIfs) {\r\n    let src = '';\r\n    for (let i = 0; i < maxIfs; ++i) {\r\n        if (i > 0) {\r\n            src += '\\nelse ';\r\n        }\r\n        if (i < maxIfs - 1) {\r\n            src += `if(test == ${i}.0){}`;\r\n        }\r\n    }\r\n    return src;\r\n}\r\nfunction CheckShaderMaxIfStatements(maxIfs, gl) {\r\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    while (true) {\r\n        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxIfs));\r\n        gl.shaderSource(shader, fragmentSrc);\r\n        gl.compileShader(shader);\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            maxIfs = (maxIfs / 2) | 0;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return maxIfs;\r\n}\n\nexport { CheckShaderMaxIfStatements };\n", "import { BindingQueue } from '../../BindingQueue.js';\nimport { SetMaxTextures, GetMaxTextures } from '../../../config/MaxTextures.js';\nimport '../GL.js';\nimport './CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport './DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport './SetGLTextureFilterMode.js';\nimport './UpdateGLTexture.js';\nimport { GLTextureBinding } from './GLTextureBinding.js';\nimport { CheckShaderMaxIfStatements } from '../shaders/CheckShaderMaxIfStatements.js';\n\nclass TextureSystem {\r\n    constructor(renderer) {\r\n        this.startActiveTexture = 0;\r\n        this.renderer = renderer;\r\n        this.tempTextures = [];\r\n        this.textureIndex = [];\r\n    }\r\n    init() {\r\n        const gl = this.renderer.gl;\r\n        let maxGPUTextures = CheckShaderMaxIfStatements(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), gl);\r\n        const maxConfigTextures = GetMaxTextures();\r\n        if (maxConfigTextures === 0 || (maxConfigTextures > 0 && maxConfigTextures > maxGPUTextures)) {\r\n            SetMaxTextures(maxGPUTextures);\r\n        }\r\n        else if (maxConfigTextures > 0 && maxConfigTextures < maxGPUTextures) {\r\n            maxGPUTextures = Math.max(8, maxConfigTextures);\r\n        }\r\n        const tempTextures = this.tempTextures;\r\n        if (tempTextures.length) {\r\n            tempTextures.forEach(texture => {\r\n                gl.deleteTexture(texture);\r\n            });\r\n        }\r\n        const index = [];\r\n        for (let texturesIndex = 0; texturesIndex < maxGPUTextures; texturesIndex++) {\r\n            const tempTexture = gl.createTexture();\r\n            gl.activeTexture(gl.TEXTURE0 + texturesIndex);\r\n            gl.bindTexture(gl.TEXTURE_2D, tempTexture);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n            tempTextures[texturesIndex] = tempTexture;\r\n            index.push(texturesIndex);\r\n        }\r\n        this.maxTextures = maxGPUTextures;\r\n        this.textureIndex = index;\r\n        this.currentActiveTexture = 1;\r\n    }\r\n    update() {\r\n        const queue = BindingQueue.get();\r\n        for (let i = 0; i < queue.length; i++) {\r\n            const texture = queue[i];\r\n            if (!texture.binding) {\r\n                texture.binding = new GLTextureBinding(texture);\r\n            }\r\n        }\r\n        BindingQueue.clear();\r\n    }\r\n    reset() {\r\n        const gl = this.renderer.gl;\r\n        const temp = this.tempTextures;\r\n        for (let i = 0; i < temp.length; i++) {\r\n            gl.activeTexture(gl.TEXTURE0 + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, temp[i]);\r\n        }\r\n        this.currentActiveTexture = 1;\r\n        this.startActiveTexture++;\r\n    }\r\n    bind(texture, index = 0) {\r\n        const gl = this.renderer.gl;\r\n        const binding = texture.binding;\r\n        binding.setIndex(index);\r\n        gl.activeTexture(gl.TEXTURE0 + index);\r\n        gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n    }\r\n    unbind(index = 0) {\r\n        const gl = this.renderer.gl;\r\n        gl.activeTexture(gl.TEXTURE0 + index);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.tempTextures[index]);\r\n        if (index > 0) {\r\n            this.startActiveTexture++;\r\n        }\r\n    }\r\n    request(texture) {\r\n        const gl = this.renderer.gl;\r\n        const binding = texture.binding;\r\n        const currentActiveTexture = this.currentActiveTexture;\r\n        if (binding.indexCounter >= this.startActiveTexture) {\r\n            return false;\r\n        }\r\n        binding.indexCounter = this.startActiveTexture;\r\n        if (currentActiveTexture < this.maxTextures) {\r\n            binding.setIndex(currentActiveTexture);\r\n            gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);\r\n            gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n            this.currentActiveTexture++;\r\n        }\r\n        else {\r\n            this.renderer.flush();\r\n            this.startActiveTexture++;\r\n            binding.indexCounter = this.startActiveTexture;\r\n            binding.setIndex(1);\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n            this.currentActiveTexture = 2;\r\n        }\r\n        return true;\r\n    }\r\n}\n\nexport { TextureSystem };\n", "import { GetBackgroundColor } from '../../config/BackgroundColor.js';\nimport { GetWidth, GetHeight, GetResolution } from '../../config/Size.js';\nimport '../BindingQueue.js';\nimport '../../config/MaxTextures.js';\nimport { GetWebGLContext } from '../../config/WebGLContext.js';\nimport { FBOSystem } from './fbo/FBOSystem.js';\nimport { GL } from './GL.js';\nimport { GetRGBArray } from './colors/GetRGBArray.js';\nimport { ExactEquals } from '../../math/matrix2d-funcs/ExactEquals.js';\nimport './fbo/CreateFramebuffer.js';\nimport './textures/CreateGLTexture.js';\nimport './fbo/DeleteFramebuffer.js';\nimport './textures/DeleteGLTexture.js';\nimport '../../math/pow2/IsSizePowerOfTwo.js';\nimport './textures/SetGLTextureFilterMode.js';\nimport './textures/UpdateGLTexture.js';\nimport './textures/GLTextureBinding.js';\nimport './buffers/IndexedBuffer.js';\nimport '../../textures/Frame.js';\nimport '../../textures/Texture.js';\nimport { WebGLRendererInstance } from './WebGLRendererInstance.js';\nimport './shaders/SingleTextureQuadShader.js';\nimport { MultiTextureQuadShader } from './shaders/MultiTextureQuadShader.js';\nimport { Ortho } from './cameras/Ortho.js';\nimport { ShaderSystem } from './shaders/ShaderSystem.js';\nimport './shaders/CheckShaderMaxIfStatements.js';\nimport { TextureSystem } from './textures/TextureSystem.js';\n\nclass WebGLRenderer {\r\n    constructor() {\r\n        this.clearColor = [0, 0, 0, 1];\r\n        this.flushTotal = 0;\r\n        this.clearBeforeRender = true;\r\n        this.optimizeRedraw = false;\r\n        this.autoResize = true;\r\n        this.contextLost = false;\r\n        this.currentCamera = null;\r\n        this.width = GetWidth();\r\n        this.height = GetHeight();\r\n        this.resolution = GetResolution();\r\n        this.setBackgroundColor(GetBackgroundColor());\r\n        const canvas = document.createElement('canvas');\r\n        canvas.addEventListener('webglcontextlost', (event) => this.onContextLost(event), false);\r\n        canvas.addEventListener('webglcontextrestored', () => this.onContextRestored(), false);\r\n        this.canvas = canvas;\r\n        this.fbo = new FBOSystem(this);\r\n        this.textures = new TextureSystem(this);\r\n        this.initContext();\r\n        WebGLRendererInstance.set(this);\r\n        this.shaders = new ShaderSystem(this, MultiTextureQuadShader);\r\n    }\r\n    initContext() {\r\n        const gl = this.canvas.getContext('webgl', GetWebGLContext());\r\n        GL.set(gl);\r\n        this.gl = gl;\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n        this.resize(this.width, this.height, this.resolution);\r\n        this.textures.init();\r\n    }\r\n    resize(width, height, resolution = 1) {\r\n        this.width = width * resolution;\r\n        this.height = height * resolution;\r\n        this.resolution = resolution;\r\n        const canvas = this.canvas;\r\n        canvas.width = this.width;\r\n        canvas.height = this.height;\r\n        if (this.autoResize) {\r\n            canvas.style.width = (this.width / resolution).toString() + 'px';\r\n            canvas.style.height = (this.height / resolution).toString() + 'px';\r\n        }\r\n        this.gl.viewport(0, 0, this.width, this.height);\r\n        this.projectionMatrix = Ortho(width, height);\r\n    }\r\n    onContextLost(event) {\r\n        event.preventDefault();\r\n        this.contextLost = true;\r\n    }\r\n    onContextRestored() {\r\n        this.contextLost = false;\r\n        this.initContext();\r\n    }\r\n    setBackgroundColor(color) {\r\n        GetRGBArray(color, this.clearColor);\r\n        return this;\r\n    }\r\n    reset(framebuffer = null, width = this.width, height = this.height) {\r\n        const gl = this.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        gl.viewport(0, 0, width, height);\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        this.flushTotal = 0;\r\n        this.currentCamera = null;\r\n        this.textures.update();\r\n    }\r\n    render(renderData) {\r\n        if (this.contextLost) {\r\n            return;\r\n        }\r\n        this.reset();\r\n        if (this.optimizeRedraw && renderData.numDirtyFrames === 0 && renderData.numDirtyCameras === 0) {\r\n            return;\r\n        }\r\n        const gl = this.gl;\r\n        if (this.clearBeforeRender) {\r\n            const cls = this.clearColor;\r\n            gl.clearColor(cls[0], cls[1], cls[2], cls[3]);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n        const worlds = renderData.worldData;\r\n        for (let i = 0; i < worlds.length; i++) {\r\n            const { camera, renderList } = worlds[i];\r\n            if (!this.currentCamera || !ExactEquals(camera.worldTransform, this.currentCamera.worldTransform)) {\r\n                this.flush();\r\n                this.currentCamera = camera;\r\n                this.shaders.rebind();\r\n            }\r\n            renderList.forEach(entry => {\r\n                if (entry.children.length) {\r\n                    this.renderNode(entry);\r\n                }\r\n                else {\r\n                    entry.node.renderGL(this);\r\n                }\r\n            });\r\n        }\r\n        this.flush();\r\n    }\r\n    renderNode(entry) {\r\n        entry.node.renderGL(this);\r\n        entry.children.forEach(child => {\r\n            if (child.children.length > 0) {\r\n                this.renderNode(child);\r\n            }\r\n            else {\r\n                child.node.renderGL(this);\r\n            }\r\n        });\r\n        entry.node.postRenderGL(this);\r\n    }\r\n    flush() {\r\n        this.shaders.flush();\r\n    }\r\n    destroy() {\r\n        WebGLRendererInstance.set(undefined);\r\n    }\r\n}\n\nexport { WebGLRenderer };\n", "import './BackgroundColor.js';\nimport './Size.js';\nimport '../renderer/BindingQueue.js';\nimport { SetRenderer } from './SetRenderer.js';\nimport './MaxTextures.js';\nimport './WebGLContext.js';\nimport '../renderer/webgl1/fbo/FBOSystem.js';\nimport '../renderer/webgl1/GL.js';\nimport '../renderer/webgl1/colors/GetRGBArray.js';\nimport '../math/matrix2d-funcs/ExactEquals.js';\nimport '../renderer/webgl1/fbo/CreateFramebuffer.js';\nimport '../renderer/webgl1/textures/CreateGLTexture.js';\nimport '../renderer/webgl1/fbo/DeleteFramebuffer.js';\nimport '../renderer/webgl1/textures/DeleteGLTexture.js';\nimport '../math/pow2/IsSizePowerOfTwo.js';\nimport '../renderer/webgl1/textures/SetGLTextureFilterMode.js';\nimport '../renderer/webgl1/textures/UpdateGLTexture.js';\nimport '../renderer/webgl1/textures/GLTextureBinding.js';\nimport '../renderer/webgl1/buffers/IndexedBuffer.js';\nimport '../textures/Frame.js';\nimport '../textures/Texture.js';\nimport '../renderer/webgl1/WebGLRendererInstance.js';\nimport '../renderer/webgl1/shaders/SingleTextureQuadShader.js';\nimport '../renderer/webgl1/shaders/MultiTextureQuadShader.js';\nimport '../renderer/webgl1/cameras/Ortho.js';\nimport '../renderer/webgl1/shaders/ShaderSystem.js';\nimport '../renderer/webgl1/shaders/CheckShaderMaxIfStatements.js';\nimport '../renderer/webgl1/textures/TextureSystem.js';\nimport { WebGLRenderer as WebGLRenderer$1 } from '../renderer/webgl1/WebGLRenderer.js';\n\nfunction WebGLRenderer() {\r\n    return () => {\r\n        SetRenderer(WebGLRenderer$1);\r\n    };\r\n}\n\nexport { WebGLRenderer };\n", "import '../GameInstance.js';\nexport { BackgroundColor, GetBackgroundColor } from './BackgroundColor.js';\nexport { Banner, GetBanner } from './Banner.js';\nexport { CanvasContext, GetCanvasContext } from './CanvasContext.js';\nexport { GetHeight, GetResolution, GetWidth, Size } from './Size.js';\nimport '../renderer/BindingQueue.js';\nimport '../renderer/canvas/CanvasRenderer.js';\nexport { GetRenderer, SetRenderer } from './SetRenderer.js';\nexport { CanvasRenderer } from './CanvasRenderer.js';\nexport { DefaultOrigin, originX, originY } from './DefaultOrigin.js';\nexport { GetMaxTextures, MaxTextures, SetMaxTextures } from './MaxTextures.js';\nimport '../dom/GetElement.js';\nexport { GetParent, Parent } from './Parent.js';\nexport { GetScenes, Scenes } from './Scenes.js';\nexport { GetWebGLContext, WebGLContext } from './WebGLContext.js';\nimport '../renderer/webgl1/fbo/FBOSystem.js';\nimport '../renderer/webgl1/GL.js';\nimport '../renderer/webgl1/colors/GetRGBArray.js';\nimport '../math/matrix2d-funcs/ExactEquals.js';\nimport '../renderer/webgl1/fbo/CreateFramebuffer.js';\nimport '../renderer/webgl1/textures/CreateGLTexture.js';\nimport '../renderer/webgl1/fbo/DeleteFramebuffer.js';\nimport '../renderer/webgl1/textures/DeleteGLTexture.js';\nimport '../math/pow2/IsSizePowerOfTwo.js';\nimport '../renderer/webgl1/textures/SetGLTextureFilterMode.js';\nimport '../renderer/webgl1/textures/UpdateGLTexture.js';\nimport '../renderer/webgl1/textures/GLTextureBinding.js';\nimport '../renderer/webgl1/buffers/IndexedBuffer.js';\nimport '../textures/Frame.js';\nimport '../textures/Texture.js';\nimport '../renderer/webgl1/WebGLRendererInstance.js';\nimport '../renderer/webgl1/shaders/SingleTextureQuadShader.js';\nimport '../renderer/webgl1/shaders/MultiTextureQuadShader.js';\nimport '../renderer/webgl1/cameras/Ortho.js';\nimport '../renderer/webgl1/shaders/ShaderSystem.js';\nimport '../renderer/webgl1/shaders/CheckShaderMaxIfStatements.js';\nimport '../renderer/webgl1/textures/TextureSystem.js';\nimport '../renderer/webgl1/WebGLRenderer.js';\nexport { WebGLRenderer } from './WebGLRenderer.js';\n", "function Emit(emitter, event, ...args) {\r\n    if (emitter.events.size === 0 || !emitter.events.has(event)) {\r\n        return false;\r\n    }\r\n    const listeners = emitter.events.get(event);\r\n    for (const ee of listeners) {\r\n        ee.callback.apply(ee.context, args);\r\n        if (ee.once) {\r\n            listeners.delete(ee);\r\n        }\r\n    }\r\n    if (listeners.size === 0) {\r\n        emitter.events.delete(event);\r\n    }\r\n    return true;\r\n}\n\nexport { Emit };\n", "import { GetElement } from './GetElement.js';\n\nfunction AddToDOM(element, parent) {\r\n    const target = GetElement(parent);\r\n    target.appendChild(element);\r\n    return element;\r\n}\n\nexport { AddToDOM };\n", "function DOMContentLoaded(callback) {\r\n    const readyState = document.readyState;\r\n    if (readyState === 'complete' || readyState === 'interactive') {\r\n        callback();\r\n        return;\r\n    }\r\n    const check = () => {\r\n        document.removeEventListener('deviceready', check, true);\r\n        document.removeEventListener('DOMContentLoaded', check, true);\r\n        window.removeEventListener('load', check, true);\r\n        callback();\r\n    };\r\n    if (!document.body) {\r\n        window.setTimeout(check, 20);\r\n    }\r\n    else if (window.hasOwnProperty('cordova')) {\r\n        document.addEventListener('deviceready', check, true);\r\n    }\r\n    else {\r\n        document.addEventListener('DOMContentLoaded', check, true);\r\n        window.addEventListener('load', check, true);\r\n    }\r\n}\n\nexport { DOMContentLoaded };\n", "class EventEmitter {\r\n    constructor() {\r\n        this.events = new Map();\r\n    }\r\n}\n\nexport { EventEmitter };\n", "class EventInstance {\r\n    constructor(callback, context, once = false) {\r\n        this.callback = callback;\r\n        this.context = context;\r\n        this.once = once;\r\n    }\r\n}\n\nexport { EventInstance };\n", "import { EventInstance } from './EventInstance.js';\n\nfunction On(emitter, event, callback, context = emitter, once = false) {\r\n    if (typeof callback !== 'function') {\r\n        throw new TypeError('Listener not a function');\r\n    }\r\n    const listener = new EventInstance(callback, context, once);\r\n    const listeners = emitter.events.get(event);\r\n    if (!listeners) {\r\n        emitter.events.set(event, new Set([listener]));\r\n    }\r\n    else {\r\n        listeners.add(listener);\r\n    }\r\n    return listener;\r\n}\n\nexport { On };\n", "import './EventInstance.js';\nimport { On } from './On.js';\n\nfunction Once(emitter, event, callback, context = emitter) {\r\n    return On(emitter, event, callback, context, true);\r\n}\n\nexport { Once };\n", "function CreateSceneRenderData() {\r\n    return {\r\n        gameFrame: 0,\r\n        numTotalFrames: 0,\r\n        numDirtyFrames: 0,\r\n        numDirtyCameras: 0,\r\n        worldData: []\r\n    };\r\n}\n\nexport { CreateSceneRenderData };\n", "function ResetSceneRenderData(renderData, gameFrame = 0) {\r\n    renderData.gameFrame = gameFrame;\r\n    renderData.numTotalFrames = 0;\r\n    renderData.numDirtyFrames = 0;\r\n    renderData.numDirtyCameras = 0;\r\n    renderData.worldData.length = 0;\r\n}\n\nexport { ResetSceneRenderData };\n", "let instance;\r\nconst SceneManagerInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (manager) => {\r\n        instance = manager;\r\n    }\r\n};\n\nexport { SceneManagerInstance };\n", "import { GameInstance } from '../GameInstance.js';\nimport { GetScenes } from '../config/Scenes.js';\nimport { Emit } from '../events/Emit.js';\nimport '../events/EventInstance.js';\nimport '../events/On.js';\nimport { Once } from '../events/Once.js';\nimport { CreateSceneRenderData } from './CreateSceneRenderData.js';\nimport { ResetSceneRenderData } from './ResetSceneRenderData.js';\nimport { SceneManagerInstance } from './SceneManagerInstance.js';\n\nclass SceneManager {\r\n    constructor() {\r\n        this.scenes = new Map();\r\n        this.sceneIndex = 0;\r\n        this.flush = false;\r\n        this.renderResult = CreateSceneRenderData();\r\n        this.game = GameInstance.get();\r\n        SceneManagerInstance.set(this);\r\n        Once(this.game, 'boot', () => this.boot());\r\n    }\r\n    boot() {\r\n        GetScenes().forEach(scene => new scene());\r\n    }\r\n    update(delta, time) {\r\n        for (const scene of this.scenes.values()) {\r\n            Emit(scene, 'update', delta, time);\r\n        }\r\n    }\r\n    render(gameFrame) {\r\n        const results = this.renderResult;\r\n        ResetSceneRenderData(results, gameFrame);\r\n        for (const scene of this.scenes.values()) {\r\n            Emit(scene, 'render', results);\r\n        }\r\n        if (this.flush) {\r\n            results.numDirtyFrames++;\r\n            this.flush = false;\r\n        }\r\n        return results;\r\n    }\r\n}\n\nexport { SceneManager };\n", "function CreateCanvas(width, height) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas.getContext('2d');\r\n}\n\nexport { CreateCanvas };\n", "let instance;\r\nconst TextureManagerInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (manager) => {\r\n        instance = manager;\r\n    }\r\n};\n\nexport { TextureManagerInstance };\n", "import '../renderer/BindingQueue.js';\nimport './Frame.js';\nimport { Texture } from './Texture.js';\nimport { CreateCanvas } from './CreateCanvas.js';\nimport { TextureManagerInstance } from './TextureManagerInstance.js';\n\nclass TextureManager {\r\n    constructor() {\r\n        this.textures = new Map();\r\n        this.createDefaultTextures();\r\n        TextureManagerInstance.set(this);\r\n    }\r\n    createDefaultTextures() {\r\n        this.add('__BLANK', new Texture(CreateCanvas(32, 32).canvas));\r\n        const missing = CreateCanvas(32, 32);\r\n        missing.strokeStyle = '#0f0';\r\n        missing.moveTo(0, 0);\r\n        missing.lineTo(32, 32);\r\n        missing.stroke();\r\n        missing.strokeRect(0.5, 0.5, 31, 31);\r\n        this.add('__MISSING', new Texture(missing.canvas));\r\n    }\r\n    get(key) {\r\n        const textures = this.textures;\r\n        if (textures.has(key)) {\r\n            return textures.get(key);\r\n        }\r\n        else {\r\n            return textures.get('__MISSING');\r\n        }\r\n    }\r\n    has(key) {\r\n        return this.textures.has(key);\r\n    }\r\n    add(key, source) {\r\n        let texture;\r\n        const textures = this.textures;\r\n        if (!textures.has(key)) {\r\n            if (source instanceof Texture) {\r\n                texture = source;\r\n            }\r\n            else {\r\n                texture = new Texture(source);\r\n            }\r\n            texture.key = key;\r\n            textures.set(key, texture);\r\n        }\r\n        return texture;\r\n    }\r\n}\n\nexport { TextureManager };\n", "import { GameInstance } from './GameInstance.js';\nimport { GetBanner } from './config/Banner.js';\nimport './renderer/BindingQueue.js';\nimport { GetRenderer } from './config/SetRenderer.js';\nimport './dom/GetElement.js';\nimport { GetParent } from './config/Parent.js';\nimport './config/Scenes.js';\nimport './textures/Frame.js';\nimport './textures/Texture.js';\nimport { Emit } from './events/Emit.js';\nimport { AddToDOM } from './dom/AddToDOM.js';\nimport { DOMContentLoaded } from './dom/DOMContentLoaded.js';\nimport { EventEmitter } from './events/EventEmitter.js';\nimport './events/EventInstance.js';\nimport './events/On.js';\nimport './events/Once.js';\nimport './scenes/CreateSceneRenderData.js';\nimport './scenes/ResetSceneRenderData.js';\nimport './scenes/SceneManagerInstance.js';\nimport { SceneManager } from './scenes/SceneManager.js';\nimport './textures/CreateCanvas.js';\nimport './textures/TextureManagerInstance.js';\nimport { TextureManager } from './textures/TextureManager.js';\n\nclass Game extends EventEmitter {\r\n    constructor(...settings) {\r\n        super();\r\n        this.VERSION = '4.0.0-beta1';\r\n        this.isBooted = false;\r\n        this.isPaused = false;\r\n        this.willUpdate = true;\r\n        this.willRender = true;\r\n        this.lastTick = 0;\r\n        this.elapsed = 0;\r\n        this.frame = 0;\r\n        GameInstance.set(this);\r\n        DOMContentLoaded(() => this.boot(settings));\r\n    }\r\n    boot(settings) {\r\n        settings.forEach(setting => setting());\r\n        const renderer = GetRenderer();\r\n        this.renderer = new renderer();\r\n        this.textureManager = new TextureManager();\r\n        this.sceneManager = new SceneManager();\r\n        const parent = GetParent();\r\n        if (parent) {\r\n            AddToDOM(this.renderer.canvas, parent);\r\n        }\r\n        this.isBooted = true;\r\n        GetBanner();\r\n        Emit(this, 'boot');\r\n        this.lastTick = performance.now();\r\n        this.step(this.lastTick);\r\n    }\r\n    pause() {\r\n        this.isPaused = true;\r\n    }\r\n    resume() {\r\n        this.isPaused = false;\r\n        this.lastTick = performance.now();\r\n    }\r\n    step(time) {\r\n        const delta = time - this.lastTick;\r\n        this.lastTick = time;\r\n        this.elapsed += delta;\r\n        if (!this.isPaused) {\r\n            if (this.willUpdate) {\r\n                this.sceneManager.update(delta, time);\r\n                Emit(this, 'update', delta, time);\r\n            }\r\n            if (this.willRender) {\r\n                this.renderer.render(this.sceneManager.render(this.frame));\r\n            }\r\n        }\r\n        this.frame++;\r\n        GameInstance.setFrame(this.frame);\r\n        GameInstance.setElapsed(this.elapsed);\r\n        requestAnimationFrame(now => this.step(now));\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { Game };\n", "function GetConfigValue(config, property, defaultValue) {\r\n    if (Object.prototype.hasOwnProperty.call(config, property)) {\r\n        return config[property];\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\n\nexport { GetConfigValue };\n", "import { SceneManagerInstance } from './SceneManagerInstance.js';\nimport { GetConfigValue } from './GetConfigValue.js';\n\nfunction Install(scene, config = {}) {\r\n    const sceneManager = SceneManagerInstance.get();\r\n    const size = sceneManager.scenes.size;\r\n    const sceneIndex = sceneManager.sceneIndex;\r\n    const firstScene = (size === 0);\r\n    if (typeof config === 'string') {\r\n        scene.key = config;\r\n    }\r\n    else if (config || (!config && firstScene)) {\r\n        scene.key = GetConfigValue(config, 'key', 'scene' + sceneIndex.toString());\r\n    }\r\n    if (sceneManager.scenes.has(scene.key)) {\r\n        console.warn('Scene key already in use: ' + scene.key);\r\n    }\r\n    else {\r\n        sceneManager.scenes.set(scene.key, scene);\r\n        sceneManager.flush = true;\r\n        sceneManager.sceneIndex++;\r\n    }\r\n}\n\nexport { Install };\n", "import { GameInstance } from '../GameInstance.js';\nimport './SceneManagerInstance.js';\nimport './GetConfigValue.js';\nimport { Install } from './Install.js';\n\nclass Scene {\r\n    constructor(config) {\r\n        this.game = GameInstance.get();\r\n        this.events = new Map();\r\n        Install(this, config);\r\n    }\r\n}\n\nexport { Scene };\n", "class Matrix2D {\r\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.set(a, b, c, d, tx, ty);\r\n    }\r\n    set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n        return this;\r\n    }\r\n    identity() {\r\n        return this.set();\r\n    }\r\n    toArray() {\r\n        return [this.a, this.b, this.c, this.d, this.tx, this.ty];\r\n    }\r\n    fromArray(src) {\r\n        return this.set(src[0], src[1], src[2], src[3], src[4], src[5]);\r\n    }\r\n}\n\nexport { Matrix2D };\n", "function Contains(rect, x, y) {\r\n    if (rect.width <= 0 || rect.height <= 0) {\r\n        return false;\r\n    }\r\n    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);\r\n}\n\nexport { Contains };\n", "import { Contains } from './Contains.js';\n\nclass Rectangle {\r\n    constructor(x = 0, y = 0, width = 0, height = 0) {\r\n        this.set(x, y, width, height);\r\n    }\r\n    set(x = 0, y = 0, width = 0, height = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    contains(x, y) {\r\n        return Contains(this, x, y);\r\n    }\r\n    set right(value) {\r\n        if (value <= this.x) {\r\n            this.width = 0;\r\n        }\r\n        else {\r\n            this.width = value - this.x;\r\n        }\r\n    }\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    set bottom(value) {\r\n        if (value <= this.y) {\r\n            this.height = 0;\r\n        }\r\n        else {\r\n            this.height = value - this.y;\r\n        }\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n}\n\nexport { Rectangle };\n", "function NOOP() {\r\n}\n\nexport { NOOP };\n", "import { NOOP } from '../../utils/NOOP.js';\n\nclass Vec2Callback {\r\n    constructor(callback, x = 0, y = 0, compareValue = false) {\r\n        this.compareValue = false;\r\n        this._x = x;\r\n        this._y = y;\r\n        this.callback = callback;\r\n        this.compareValue = compareValue;\r\n    }\r\n    set(x = 0, y = 0) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this.callback(this);\r\n        return this;\r\n    }\r\n    destroy() {\r\n        this.callback = NOOP;\r\n    }\r\n    set x(value) {\r\n        if (!this.compareValue || (this.compareValue && value !== this._x)) {\r\n            this._x = value;\r\n            this.callback(this);\r\n        }\r\n    }\r\n    get x() {\r\n        return this._x;\r\n    }\r\n    set y(value) {\r\n        if (!this.compareValue || (this.compareValue && value !== this._x)) {\r\n            this._y = value;\r\n            this.callback(this);\r\n        }\r\n    }\r\n    get y() {\r\n        return this._y;\r\n    }\r\n}\n\nexport { Vec2Callback };\n", "function Wrap(value, min, max) {\r\n    const range = max - min;\r\n    return (min + ((((value - min) % range) + range) % range));\r\n}\n\nexport { Wrap };\n", "import { Wrap } from '../Wrap.js';\n\nfunction WrapAngle(angle) {\r\n    return Wrap(angle, -Math.PI, Math.PI);\r\n}\n\nexport { WrapAngle };\n", "import { GameInstance } from '../GameInstance.js';\nimport { Matrix2D } from '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport { Rectangle } from '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport { Vec2Callback } from '../math/vec2/Vec2Callback.js';\nimport '../math/Wrap.js';\nimport { WrapAngle } from '../math/angle/WrapAngle.js';\n\nclass Camera {\r\n    constructor() {\r\n        this._rotation = 0;\r\n        this.type = 'Camera';\r\n        this.dirtyRender = true;\r\n        const game = GameInstance.get();\r\n        this.renderer = game.renderer;\r\n        this.matrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);\r\n        this.bounds = new Rectangle();\r\n        this.worldTransform = new Matrix2D();\r\n        this.position = new Vec2Callback(() => this.updateTransform(), 0, 0);\r\n        this.scale = new Vec2Callback(() => this.updateTransform(), 1, 1);\r\n        this.origin = new Vec2Callback(() => this.updateTransform(), 0.5, 0.5);\r\n        this.reset();\r\n    }\r\n    updateTransform() {\r\n        const matrix = this.matrix;\r\n        const px = this.position.x;\r\n        const py = this.position.y;\r\n        const sx = this.scale.x;\r\n        const sy = this.scale.y;\r\n        const ox = -px + (this.width * this.origin.x);\r\n        const oy = -py + (this.height * this.origin.y);\r\n        const z = Math.sin(this.rotation);\r\n        const w = Math.cos(this.rotation);\r\n        const z2 = z + z;\r\n        const zz = z * z2;\r\n        const wz = w * z2;\r\n        const out0 = (1 - zz) * sx;\r\n        const out1 = wz * sx;\r\n        const out4 = -wz * sy;\r\n        const out5 = (1 - zz) * sy;\r\n        matrix[0] = out0;\r\n        matrix[1] = out1;\r\n        matrix[4] = out4;\r\n        matrix[5] = out5;\r\n        matrix[12] = px + ox - (out0 * ox + out4 * oy);\r\n        matrix[13] = py + oy - (out1 * ox + out5 * oy);\r\n        this.worldTransform.set(w * sx, z * sx, -z * sy, w * sy, -px, -py);\r\n        const bw = this.width * (1 / sx);\r\n        const bh = this.height * (1 / sy);\r\n        this.bounds.set(ox - (bw / 2), oy - (bh / 2), bw, bh);\r\n        this.dirtyRender = true;\r\n    }\r\n    reset() {\r\n        const width = this.renderer.width;\r\n        const height = this.renderer.height;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.bounds.set(0, 0, width, height);\r\n    }\r\n    set rotation(value) {\r\n        if (value !== this._rotation) {\r\n            this._rotation = WrapAngle(value);\r\n            this.updateTransform();\r\n        }\r\n    }\r\n    get rotation() {\r\n        return this._rotation;\r\n    }\r\n    destroy() {\r\n        this.position.destroy();\r\n        this.scale.destroy();\r\n        this.origin.destroy();\r\n        this.world = null;\r\n        this.worldTransform = null;\r\n        this.renderer = null;\r\n        this.matrix = null;\r\n        this.bounds = null;\r\n    }\r\n}\n\nexport { Camera };\n", "import { GameInstance } from '../GameInstance.js';\nimport { Matrix2D } from '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport { Rectangle } from '../geom/rectangle/Rectangle.js';\n\nclass StaticCamera {\r\n    constructor() {\r\n        this.type = 'StaticCamera';\r\n        this.dirtyRender = true;\r\n        const game = GameInstance.get();\r\n        this.renderer = game.renderer;\r\n        this.matrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n        this.bounds = new Rectangle();\r\n        this.worldTransform = new Matrix2D();\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        const width = this.renderer.width;\r\n        const height = this.renderer.height;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.bounds.set(0, 0, width, height);\r\n    }\r\n    destroy() {\r\n        this.world = null;\r\n        this.worldTransform = null;\r\n        this.renderer = null;\r\n        this.matrix = null;\r\n        this.bounds = null;\r\n    }\r\n}\n\nexport { StaticCamera };\n", "function DepthFirstSearch(parent) {\r\n    const stack = [parent];\r\n    const output = [];\r\n    while (stack.length > 0) {\r\n        const node = stack.shift();\r\n        output.push(node);\r\n        const numChildren = node.numChildren;\r\n        if (numChildren > 0) {\r\n            for (let i = numChildren - 1; i >= 0; i--) {\r\n                stack.unshift(node.children[i]);\r\n            }\r\n        }\r\n    }\r\n    output.shift();\r\n    return output;\r\n}\n\nexport { DepthFirstSearch };\n", "function GetChildIndex(parent, child) {\r\n    return parent.children.indexOf(child);\r\n}\n\nexport { GetChildIndex };\n", "function RemoveChildAt(parent, index) {\r\n    const children = parent.children;\r\n    let child;\r\n    if (index >= 0 && index < children.length) {\r\n        const removed = children.splice(index, 1);\r\n        if (removed[0]) {\r\n            child = removed[0];\r\n            child.parent = null;\r\n        }\r\n    }\r\n    return child;\r\n}\n\nexport { RemoveChildAt };\n", "import { GetChildIndex } from './GetChildIndex.js';\nimport { RemoveChildAt } from './RemoveChildAt.js';\n\nfunction RemoveChild(parent, child) {\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex > -1) {\r\n        RemoveChildAt(parent, currentIndex);\r\n    }\r\n    return child;\r\n}\n\nexport { RemoveChild };\n", "const AddedToWorldEvent = 'addedtoworld';\n\nexport { AddedToWorldEvent };\n", "const DestroyEvent = 'destroy';\n\nexport { DestroyEvent };\n", "const PostUpdateEvent = 'postupdate';\n\nexport { PostUpdateEvent };\n", "const RemovedFromWorldEvent = 'removedfromworld';\n\nexport { RemovedFromWorldEvent };\n", "const UpdateEvent = 'update';\n\nexport { UpdateEvent };\n", "import { AddedToWorldEvent } from '../gameobjects/events/AddedToWorldEvent.js';\nimport { RemovedFromWorldEvent } from '../gameobjects/events/RemovedFromWorldEvent.js';\nimport { Emit } from '../events/Emit.js';\n\nfunction SetWorld(world, ...children) {\r\n    children.forEach(child => {\r\n        if (child.world) {\r\n            Emit(child.world, RemovedFromWorldEvent, child, child.world);\r\n            Emit(child, RemovedFromWorldEvent, child, child.world);\r\n        }\r\n        child.world = world;\r\n        Emit(world, AddedToWorldEvent, child, world);\r\n        Emit(child, AddedToWorldEvent, child, world);\r\n    });\r\n    return children;\r\n}\n\nexport { SetWorld };\n", "import { DepthFirstSearch } from './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport { RemoveChild } from './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport { SetWorld } from './SetWorld.js';\n\nfunction SetParent(parent, ...children) {\r\n    children.forEach(child => {\r\n        if (child.parent) {\r\n            RemoveChild(child.parent, child);\r\n        }\r\n        child.parent = parent;\r\n    });\r\n    const parentWorld = parent.world;\r\n    if (parentWorld) {\r\n        SetWorld(parentWorld, ...DepthFirstSearch(parent));\r\n    }\r\n    return children;\r\n}\n\nexport { SetParent };\n", "const DIRTY_CONST = {\r\n    CLEAR: 0,\r\n    TRANSFORM: 1,\r\n    UPDATE: 2,\r\n    CHILD_CACHE: 4,\r\n    POST_RENDER: 8,\r\n    COLORS: 16,\r\n    BOUNDS: 32,\r\n    TEXTURE: 64,\r\n    FRAME: 128,\r\n    ALPHA: 256,\r\n    CHILD: 512,\r\n    DEFAULT: 1 + 2 + 16 + 32,\r\n    USER1: 536870912,\r\n    USER2: 1073741824,\r\n    USER3: 2147483648,\r\n    USER4: 4294967296\r\n};\n\nexport { DIRTY_CONST };\n", "function RemoveChildrenBetween(parent, beginIndex = 0, endIndex) {\r\n    const children = parent.children;\r\n    if (endIndex === undefined) {\r\n        endIndex = children.length;\r\n    }\r\n    const range = endIndex - beginIndex;\r\n    if (range > 0 && range <= endIndex) {\r\n        const removed = children.splice(beginIndex, range);\r\n        removed.forEach(child => {\r\n            child.parent = null;\r\n        });\r\n        return removed;\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\n\nexport { RemoveChildrenBetween };\n", "import { RemoveChildrenBetween } from './RemoveChildrenBetween.js';\n\nfunction DestroyChildren(parent, beginIndex = 0, endIndex) {\r\n    const removed = RemoveChildrenBetween(parent, beginIndex, endIndex);\r\n    removed.forEach(child => {\r\n        child.destroy();\r\n    });\r\n}\n\nexport { DestroyChildren };\n", "import './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport { RemoveChild } from './RemoveChild.js';\n\nfunction RemoveChildren(parent, ...children) {\r\n    children.forEach(child => {\r\n        RemoveChild(parent, child);\r\n    });\r\n    return children;\r\n}\n\nexport { RemoveChildren };\n", "import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport { SetParent } from './SetParent.js';\nimport { RemoveChildrenBetween } from './RemoveChildrenBetween.js';\n\nfunction ReparentChildren(parent, newParent, beginIndex = 0, endIndex) {\r\n    const moved = RemoveChildrenBetween(parent, beginIndex, endIndex);\r\n    SetParent(newParent, ...moved);\r\n    moved.forEach(child => {\r\n        child.transform.updateWorld();\r\n    });\r\n    return moved;\r\n}\n\nexport { ReparentChildren };\n", "import { EventInstance } from './EventInstance.js';\n\nfunction Off(emitter, event, callback, context, once) {\r\n    const events = emitter.events;\r\n    const listeners = events.get(event);\r\n    if (!callback) {\r\n        events.delete(event);\r\n    }\r\n    else if (callback instanceof EventInstance) {\r\n        listeners.delete(callback);\r\n    }\r\n    else {\r\n        const hasContext = !context;\r\n        const hasOnce = (once !== undefined);\r\n        for (const listener of listeners) {\r\n            if ((listener.callback === callback) &&\r\n                (hasContext && listener.context === context) &&\r\n                (hasOnce && listener.once === once)) {\r\n                listeners.delete(listener);\r\n            }\r\n        }\r\n    }\r\n    if (listeners.size === 0) {\r\n        events.delete(event);\r\n    }\r\n    return emitter;\r\n}\n\nexport { Off };\n", "function GetVertices(transform) {\r\n    const { a, b, c, d, tx, ty } = transform.world;\r\n    const { x, y, right, bottom } = transform.extent;\r\n    const x0 = (x * a) + (y * c) + tx;\r\n    const y0 = (x * b) + (y * d) + ty;\r\n    const x1 = (x * a) + (bottom * c) + tx;\r\n    const y1 = (x * b) + (bottom * d) + ty;\r\n    const x2 = (right * a) + (bottom * c) + tx;\r\n    const y2 = (right * b) + (bottom * d) + ty;\r\n    const x3 = (right * a) + (y * c) + tx;\r\n    const y3 = (right * b) + (y * d) + ty;\r\n    return { x0, y0, x1, y1, x2, y2, x3, y3 };\r\n}\n\nexport { GetVertices };\n", "import '../../../geom/rectangle/Contains.js';\nimport { Rectangle } from '../../../geom/rectangle/Rectangle.js';\nimport { DIRTY_CONST } from '../../DIRTY_CONST.js';\nimport { GetVertices } from '../transform/GetVertices.js';\n\nclass BoundsComponent {\r\n    constructor(entity) {\r\n        this.fixed = false;\r\n        this.includeChildren = true;\r\n        this.visibleOnly = true;\r\n        this.entity = entity;\r\n        this.area = new Rectangle();\r\n    }\r\n    set(x, y, width, height) {\r\n        this.area.set(x, y, width, height);\r\n    }\r\n    get() {\r\n        if (this.entity.isDirty(DIRTY_CONST.BOUNDS) && !this.fixed) {\r\n            this.update();\r\n        }\r\n        return this.area;\r\n    }\r\n    updateLocal() {\r\n        const { x0, y0, x1, y1, x2, y2, x3, y3 } = GetVertices(this.entity.transform);\r\n        const x = Math.min(x0, x1, x2, x3);\r\n        const y = Math.min(y0, y1, y2, y3);\r\n        const right = Math.max(x0, x1, x2, x3);\r\n        const bottom = Math.max(y0, y1, y2, y3);\r\n        return this.area.set(x, y, right - x, bottom - y);\r\n    }\r\n    update() {\r\n        const bounds = this.updateLocal();\r\n        this.entity.clearDirty(DIRTY_CONST.BOUNDS);\r\n        if (!this.includeChildren || !this.entity.numChildren) {\r\n            return bounds;\r\n        }\r\n        const visibleOnly = this.visibleOnly;\r\n        const children = this.entity.children;\r\n        let x = bounds.x;\r\n        let y = bounds.y;\r\n        let right = bounds.right;\r\n        let bottom = bounds.bottom;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            if (!child || (visibleOnly && !child.visible)) {\r\n                continue;\r\n            }\r\n            const childBounds = child.bounds.get();\r\n            if (childBounds.x < x) {\r\n                x = childBounds.x;\r\n            }\r\n            if (childBounds.y < y) {\r\n                y = childBounds.y;\r\n            }\r\n            if (childBounds.right > right) {\r\n                right = childBounds.right;\r\n            }\r\n            if (childBounds.bottom > bottom) {\r\n                bottom = childBounds.bottom;\r\n            }\r\n        }\r\n        return bounds.set(x, y, right - x, bottom - y);\r\n    }\r\n    destroy() {\r\n        this.entity = null;\r\n        this.area = null;\r\n    }\r\n}\n\nexport { BoundsComponent };\n", "class InputComponent {\r\n    constructor(entity) {\r\n        this.enabled = false;\r\n        this.enabledChildren = true;\r\n        this.entity = entity;\r\n    }\r\n    destroy() {\r\n        this.entity = null;\r\n        this.hitArea = null;\r\n    }\r\n}\n\nexport { InputComponent };\n", "class Vec2 {\r\n    constructor(x = 0, y = 0) {\r\n        this.set(x, y);\r\n    }\r\n    set(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    getArray() {\r\n        return [this.x, this.y];\r\n    }\r\n    fromArray(src) {\r\n        return this.set(src[0], src[1]);\r\n    }\r\n    toString() {\r\n        return `[x=${this.x}, y=${this.y}]`;\r\n    }\r\n}\n\nexport { Vec2 };\n", "function UpdateLocalTransform(transform) {\r\n    const local = transform.local;\r\n    const x = transform.position.x;\r\n    const y = transform.position.y;\r\n    const rotation = transform.rotation;\r\n    const scaleX = transform.scale.x;\r\n    const scaleY = transform.scale.y;\r\n    const skewX = transform.skew.x;\r\n    const skewY = transform.skew.y;\r\n    local.set(Math.cos(rotation + skewY) * scaleX, Math.sin(rotation + skewY) * scaleX, -Math.sin(rotation - skewX) * scaleY, Math.cos(rotation - skewX) * scaleY, x, y);\r\n}\n\nexport { UpdateLocalTransform };\n", "function Copy(src, target) {\r\n    return target.set(src.a, src.b, src.c, src.d, src.tx, src.ty);\r\n}\n\nexport { Copy };\n", "import { Copy } from '../../../math/matrix2d/Copy.js';\n\nfunction UpdateWorldTransform(gameObject) {\r\n    const parent = gameObject.parent;\r\n    const transform = gameObject.transform;\r\n    const lt = transform.local;\r\n    const wt = transform.world;\r\n    if (!parent) {\r\n        Copy(lt, wt);\r\n    }\r\n    else if (transform.passthru) {\r\n        Copy(parent.transform.world, wt);\r\n    }\r\n    else {\r\n        const { a, b, c, d, tx, ty } = lt;\r\n        const { a: pa, b: pb, c: pc, d: pd, tx: ptx, ty: pty } = parent.transform.world;\r\n        wt.set(a * pa + b * pc, a * pb + b * pd, c * pa + d * pc, c * pb + d * pd, tx * pa + ty * pc + ptx, tx * pb + ty * pd + pty);\r\n    }\r\n}\n\nexport { UpdateWorldTransform };\n", "import { Matrix2D } from '../../../math/matrix2d/Matrix2D.js';\nimport '../../../geom/rectangle/Contains.js';\nimport { Rectangle } from '../../../geom/rectangle/Rectangle.js';\nimport '../../../utils/NOOP.js';\nimport { Vec2Callback } from '../../../math/vec2/Vec2Callback.js';\nimport { originX, originY } from '../../../config/DefaultOrigin.js';\nimport { DIRTY_CONST } from '../../DIRTY_CONST.js';\nimport { Vec2 } from '../../../math/vec2/Vec2.js';\nimport { UpdateLocalTransform } from './UpdateLocalTransform.js';\nimport '../../../math/matrix2d/Copy.js';\nimport { UpdateWorldTransform } from './UpdateWorldTransform.js';\n\nclass TransformComponent {\r\n    constructor(entity, x = 0, y = 0) {\r\n        this.passthru = false;\r\n        this._rotation = 0;\r\n        this.entity = entity;\r\n        this.local = new Matrix2D();\r\n        this.world = new Matrix2D();\r\n        this.position = new Vec2Callback(() => this.update(), x, y);\r\n        this.scale = new Vec2Callback(() => this.update(), 1, 1, true);\r\n        this.skew = new Vec2Callback(() => this.update(), 0, 0, true);\r\n        this.origin = new Vec2Callback(() => this.updateExtent(), originX, originY);\r\n        this.extent = new Rectangle();\r\n    }\r\n    update() {\r\n        this.updateLocal();\r\n        this.updateWorld();\r\n    }\r\n    updateLocal() {\r\n        this.entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n        UpdateLocalTransform(this);\r\n    }\r\n    updateWorld() {\r\n        const entity = this.entity;\r\n        entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n        UpdateWorldTransform(entity);\r\n        if (entity.numChildren) {\r\n            this.updateChildren();\r\n        }\r\n    }\r\n    updateChildren() {\r\n        const children = this.entity.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            child.transform.updateWorld();\r\n        }\r\n    }\r\n    globalToLocal(x, y, out = new Vec2()) {\r\n        const { a, b, c, d, tx, ty } = this.world;\r\n        const id = 1 / ((a * d) + (c * -b));\r\n        out.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\r\n        out.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\r\n        return out;\r\n    }\r\n    localToGlobal(x, y, out = new Vec2()) {\r\n        const { a, b, c, d, tx, ty } = this.world;\r\n        out.x = (a * x) + (c * y) + tx;\r\n        out.y = (b * x) + (d * y) + ty;\r\n        return out;\r\n    }\r\n    setExtent(x, y, width, height) {\r\n        this.extent.set(x, y, width, height);\r\n        this.entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n    }\r\n    updateExtent(width, height) {\r\n        const extent = this.extent;\r\n        const entity = this.entity;\r\n        if (width !== undefined) {\r\n            extent.width = width;\r\n        }\r\n        if (height !== undefined) {\r\n            extent.height = height;\r\n        }\r\n        extent.x = -(this.origin.x) * extent.width;\r\n        extent.y = -(this.origin.y) * extent.height;\r\n        entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n    }\r\n    set rotation(value) {\r\n        if (value !== this._rotation) {\r\n            this._rotation = value;\r\n            this.update();\r\n        }\r\n    }\r\n    get rotation() {\r\n        return this._rotation;\r\n    }\r\n    destroy() {\r\n        this.position.destroy();\r\n        this.scale.destroy();\r\n        this.skew.destroy();\r\n        this.origin.destroy();\r\n        this.entity = null;\r\n        this.local = null;\r\n        this.world = null;\r\n        this.position = null;\r\n        this.scale = null;\r\n        this.skew = null;\r\n        this.origin = null;\r\n        this.extent = null;\r\n    }\r\n}\n\nexport { TransformComponent };\n", "import { GameInstance } from '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport './events/AddedToWorldEvent.js';\nimport { DestroyEvent } from './events/DestroyEvent.js';\nimport './events/RemovedFromWorldEvent.js';\nimport { Emit } from '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport { DIRTY_CONST } from './DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport { DestroyChildren } from '../display/DestroyChildren.js';\nimport { ReparentChildren } from '../display/ReparentChildren.js';\nimport './components/transform/GetVertices.js';\nimport { BoundsComponent } from './components/bounds/BoundsComponent.js';\nimport { InputComponent } from './components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport './components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport './components/transform/UpdateWorldTransform.js';\nimport { TransformComponent } from './components/transform/TransformComponent.js';\n\nclass GameObject {\r\n    constructor(x = 0, y = 0) {\r\n        this.type = 'GameObject';\r\n        this.name = '';\r\n        this.willUpdate = true;\r\n        this.willUpdateChildren = true;\r\n        this.willRender = true;\r\n        this.willRenderChildren = true;\r\n        this.willCacheChildren = false;\r\n        this.dirty = 0;\r\n        this.dirtyFrame = 0;\r\n        this.visible = true;\r\n        this.children = [];\r\n        this.events = new Map();\r\n        this.transform = new TransformComponent(this, x, y);\r\n        this.bounds = new BoundsComponent(this);\r\n        this.input = new InputComponent(this);\r\n        this.dirty = DIRTY_CONST.DEFAULT;\r\n        this.transform.update();\r\n    }\r\n    isRenderable() {\r\n        return (this.visible && this.willRender);\r\n    }\r\n    isDirty(flag) {\r\n        return (this.dirty & flag) !== 0;\r\n    }\r\n    clearDirty(flag) {\r\n        if (this.isDirty(flag)) {\r\n            this.dirty ^= flag;\r\n        }\r\n        return this;\r\n    }\r\n    setDirty(flag, flag2) {\r\n        if (!this.isDirty(flag)) {\r\n            this.dirty ^= flag;\r\n            this.dirtyFrame = GameInstance.getFrame();\r\n        }\r\n        if (!this.isDirty(flag2)) {\r\n            this.dirty ^= flag2;\r\n        }\r\n        return this;\r\n    }\r\n    update(delta, time) {\r\n        if (this.willUpdateChildren) {\r\n            const children = this.children;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child && child.willUpdate) {\r\n                    child.update(delta, time);\r\n                }\r\n            }\r\n        }\r\n        this.postUpdate(delta, time);\r\n    }\r\n    postUpdate(delta, time) {\r\n    }\r\n    renderGL(renderer) {\r\n    }\r\n    renderCanvas(renderer) {\r\n    }\r\n    postRenderGL(renderer) {\r\n    }\r\n    postRenderCanvas(renderer) {\r\n    }\r\n    get numChildren() {\r\n        return this.children.length;\r\n    }\r\n    destroy(reparentChildren) {\r\n        if (reparentChildren) {\r\n            ReparentChildren(this, reparentChildren);\r\n        }\r\n        else {\r\n            DestroyChildren(this);\r\n        }\r\n        Emit(this, DestroyEvent, this);\r\n        this.transform.destroy();\r\n        this.bounds.destroy();\r\n        this.input.destroy();\r\n        this.events.clear();\r\n        this.world = null;\r\n        this.parent = null;\r\n        this.children = null;\r\n    }\r\n}\n\nexport { GameObject };\n", "const WorldRenderEvent = 'worldrender';\n\nexport { WorldRenderEvent };\n", "const WorldShutdownEvent = 'worldshutdown';\n\nexport { WorldShutdownEvent };\n", "import { WorldRenderEvent } from './world/events/WorldRenderEvent.js';\nimport { WorldShutdownEvent } from './world/events/WorldShutdownEvent.js';\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    WorldRenderEvent: WorldRenderEvent,\n    WorldShutdownEvent: WorldShutdownEvent\n});\n\nexport { index as i };\n", "function CalculateTotalRenderable(entry, renderData) {\r\n    renderData.numRendered++;\r\n    renderData.numRenderable++;\r\n    if (entry.node.dirtyFrame >= renderData.gameFrame) {\r\n        renderData.dirtyFrame++;\r\n    }\r\n    entry.children.forEach(child => {\r\n        if (child.children.length > 0) {\r\n            CalculateTotalRenderable(child, renderData);\r\n        }\r\n    });\r\n}\n\nexport { CalculateTotalRenderable };\n", "import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction HasDirtyChildren(parent) {\r\n    if (parent.node.isDirty(DIRTY_CONST.CHILD_CACHE)) {\r\n        return true;\r\n    }\r\n    const stack = [parent];\r\n    while (stack.length > 0) {\r\n        const entry = stack.pop();\r\n        if (entry.node.isDirty(DIRTY_CONST.TRANSFORM)) {\r\n            return true;\r\n        }\r\n        const numChildren = entry.children.length;\r\n        if (numChildren > 0) {\r\n            for (let i = 0; i < numChildren; i++) {\r\n                stack.push(entry.children[i]);\r\n            }\r\n        }\r\n    }\r\n    stack.length = 0;\r\n    return false;\r\n}\n\nexport { HasDirtyChildren };\n", "import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\nimport { HasDirtyChildren } from './HasDirtyChildren.js';\n\nfunction UpdateCachedLayers(cachedLayers, dirtyCamera) {\r\n    cachedLayers.forEach(layer => {\r\n        if (dirtyCamera || HasDirtyChildren(layer)) {\r\n            layer.node.setDirty(DIRTY_CONST.CHILD_CACHE);\r\n        }\r\n        else {\r\n            layer.children.length = 0;\r\n        }\r\n    });\r\n}\n\nexport { UpdateCachedLayers };\n", "function WorldDepthFirstSearch(cachedLayers, parent, output = []) {\r\n    for (let i = 0; i < parent.numChildren; i++) {\r\n        const node = parent.children[i];\r\n        if (node.isRenderable()) {\r\n            const children = [];\r\n            const entry = { node, children };\r\n            output.push(entry);\r\n            if (node.willRenderChildren && node.numChildren > 0) {\r\n                if (node.willCacheChildren) {\r\n                    cachedLayers.push(entry);\r\n                }\r\n                WorldDepthFirstSearch(cachedLayers, node, children);\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}\n\nexport { WorldDepthFirstSearch };\n", "import '../gameobjects/DIRTY_CONST.js';\nimport { CalculateTotalRenderable } from './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport { UpdateCachedLayers } from './UpdateCachedLayers.js';\nimport { WorldDepthFirstSearch } from './WorldDepthFirstSearch.js';\n\nfunction BuildRenderList(world) {\r\n    const cachedLayers = [];\r\n    const stack = [];\r\n    const entries = WorldDepthFirstSearch(cachedLayers, world, stack);\r\n    const renderData = world.renderData;\r\n    if (cachedLayers.length > 0) {\r\n        UpdateCachedLayers(cachedLayers, world.camera.dirtyRender);\r\n    }\r\n    entries.forEach(entry => {\r\n        if (entry.children.length) {\r\n            CalculateTotalRenderable(entry, renderData);\r\n        }\r\n        else {\r\n            renderData.numRendered++;\r\n            renderData.numRenderable++;\r\n            if (entry.node.dirtyFrame >= renderData.gameFrame) {\r\n                renderData.dirtyFrame++;\r\n            }\r\n        }\r\n    });\r\n    renderData.renderList = entries;\r\n    if (world.forceRefresh) {\r\n        renderData.dirtyFrame++;\r\n        world.forceRefresh = false;\r\n    }\r\n}\n\nexport { BuildRenderList };\n", "function MergeRenderData(sceneRenderData, worldRenderData) {\r\n    sceneRenderData.numDirtyFrames += worldRenderData.dirtyFrame;\r\n    sceneRenderData.numTotalFrames += worldRenderData.numRendered;\r\n    if (worldRenderData.camera.dirtyRender) {\r\n        sceneRenderData.numDirtyCameras++;\r\n    }\r\n    sceneRenderData.worldData.push(worldRenderData);\r\n}\n\nexport { MergeRenderData };\n", "function ResetWorldRenderData(renderData, gameFrame) {\r\n    renderData.gameFrame = gameFrame;\r\n    renderData.dirtyFrame = 0;\r\n    renderData.numRendered = 0;\r\n    renderData.numRenderable = 0;\r\n    renderData.renderList.length = 0;\r\n}\n\nexport { ResetWorldRenderData };\n", "import '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport { DestroyEvent } from '../gameobjects/events/DestroyEvent.js';\nimport { PostUpdateEvent } from '../gameobjects/events/PostUpdateEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport { UpdateEvent } from '../gameobjects/events/UpdateEvent.js';\nimport { Emit } from '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport '../gameobjects/DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport '../display/DestroyChildren.js';\nimport { RemoveChildren } from '../display/RemoveChildren.js';\nimport '../display/ReparentChildren.js';\nimport '../events/EventInstance.js';\nimport { Off } from '../events/Off.js';\nimport { On } from '../events/On.js';\nimport { Once } from '../events/Once.js';\nimport '../gameobjects/components/transform/GetVertices.js';\nimport '../gameobjects/components/bounds/BoundsComponent.js';\nimport '../gameobjects/components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport '../gameobjects/components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport '../gameobjects/components/transform/UpdateWorldTransform.js';\nimport '../gameobjects/components/transform/TransformComponent.js';\nimport { GameObject } from '../gameobjects/GameObject.js';\nimport { WorldRenderEvent } from './events/WorldRenderEvent.js';\nimport { WorldShutdownEvent } from './events/WorldShutdownEvent.js';\nimport './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport './UpdateCachedLayers.js';\nimport './WorldDepthFirstSearch.js';\nimport { BuildRenderList } from './BuildRenderList.js';\nimport { MergeRenderData } from './MergeRenderData.js';\nimport { ResetWorldRenderData } from './ResetWorldRenderData.js';\n\nclass BaseWorld extends GameObject {\r\n    constructor(scene) {\r\n        super();\r\n        this.forceRefresh = false;\r\n        this.type = 'BaseWorld';\r\n        this.scene = scene;\r\n        this.world = this;\r\n        this.events = new Map();\r\n        this._updateListener = On(scene, 'update', (delta, time) => this.update(delta, time));\r\n        this._renderListener = On(scene, 'render', (renderData) => this.render(renderData));\r\n        this._shutdownListener = On(scene, 'shutdown', () => this.shutdown());\r\n        Once(scene, 'destroy', () => this.destroy());\r\n    }\r\n    update(delta, time) {\r\n        if (!this.willUpdate) {\r\n            return;\r\n        }\r\n        Emit(this, UpdateEvent, delta, time, this);\r\n        super.update(delta, time);\r\n    }\r\n    postUpdate(delta, time) {\r\n        Emit(this, PostUpdateEvent, delta, time, this);\r\n    }\r\n    render(sceneRenderData) {\r\n        const renderData = this.renderData;\r\n        ResetWorldRenderData(renderData, sceneRenderData.gameFrame);\r\n        if (!this.willRender || !this.visible) {\r\n            return;\r\n        }\r\n        BuildRenderList(this);\r\n        Emit(this, WorldRenderEvent, renderData, this);\r\n        MergeRenderData(sceneRenderData, renderData);\r\n        if (this.camera) {\r\n            this.camera.dirtyRender = false;\r\n        }\r\n    }\r\n    shutdown() {\r\n        const scene = this.scene;\r\n        Off(scene, 'update', this._updateListener);\r\n        Off(scene, 'render', this._renderListener);\r\n        Off(scene, 'shutdown', this._shutdownListener);\r\n        RemoveChildren(this);\r\n        Emit(this, WorldShutdownEvent, this);\r\n        ResetWorldRenderData(this.renderData, 0);\r\n        if (this.camera) {\r\n            this.camera.reset();\r\n        }\r\n    }\r\n    destroy(reparentChildren) {\r\n        super.destroy(reparentChildren);\r\n        Emit(this, DestroyEvent, this);\r\n        ResetWorldRenderData(this.renderData, 0);\r\n        if (this.camera) {\r\n            this.camera.destroy();\r\n        }\r\n        this.events.clear();\r\n        this.camera = null;\r\n        this.renderData = null;\r\n        this.events = null;\r\n    }\r\n}\n\nexport { BaseWorld };\n", "function CreateWorldRenderData(camera) {\r\n    return {\r\n        camera,\r\n        gameFrame: 0,\r\n        dirtyFrame: 0,\r\n        numRendered: 0,\r\n        numRenderable: 0,\r\n        renderList: []\r\n    };\r\n}\n\nexport { CreateWorldRenderData };\n", "import '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport { StaticCamera } from '../camera/StaticCamera.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/DestroyEvent.js';\nimport '../gameobjects/events/PostUpdateEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../gameobjects/events/UpdateEvent.js';\nimport '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport '../gameobjects/DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport '../display/DestroyChildren.js';\nimport '../display/RemoveChildren.js';\nimport '../display/ReparentChildren.js';\nimport '../events/EventInstance.js';\nimport '../events/Off.js';\nimport '../events/On.js';\nimport '../events/Once.js';\nimport '../gameobjects/components/transform/GetVertices.js';\nimport '../gameobjects/components/bounds/BoundsComponent.js';\nimport '../gameobjects/components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport '../gameobjects/components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport '../gameobjects/components/transform/UpdateWorldTransform.js';\nimport '../gameobjects/components/transform/TransformComponent.js';\nimport '../gameobjects/GameObject.js';\nimport './events/WorldRenderEvent.js';\nimport './events/WorldShutdownEvent.js';\nimport './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport './UpdateCachedLayers.js';\nimport './WorldDepthFirstSearch.js';\nimport './BuildRenderList.js';\nimport './MergeRenderData.js';\nimport './ResetWorldRenderData.js';\nimport { BaseWorld } from './BaseWorld.js';\nimport { CreateWorldRenderData } from './CreateWorldRenderData.js';\n\nclass StaticWorld extends BaseWorld {\r\n    constructor(scene) {\r\n        super(scene);\r\n        this.type = 'StaticWorld';\r\n        this.camera = new StaticCamera();\r\n        this.renderData = CreateWorldRenderData(this.camera);\r\n    }\r\n}\n\nexport { StaticWorld };\n", "import '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport '../math/Wrap.js';\nimport '../math/angle/WrapAngle.js';\nimport { Camera } from '../camera/Camera.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/DestroyEvent.js';\nimport '../gameobjects/events/PostUpdateEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../gameobjects/events/UpdateEvent.js';\nimport '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport '../gameobjects/DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport '../display/DestroyChildren.js';\nimport '../display/RemoveChildren.js';\nimport '../display/ReparentChildren.js';\nimport '../events/EventInstance.js';\nimport '../events/Off.js';\nimport '../events/On.js';\nimport '../events/Once.js';\nimport '../gameobjects/components/transform/GetVertices.js';\nimport '../gameobjects/components/bounds/BoundsComponent.js';\nimport '../gameobjects/components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport '../gameobjects/components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport '../gameobjects/components/transform/UpdateWorldTransform.js';\nimport '../gameobjects/components/transform/TransformComponent.js';\nimport '../gameobjects/GameObject.js';\nimport './events/WorldRenderEvent.js';\nimport './events/WorldShutdownEvent.js';\nimport './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport './UpdateCachedLayers.js';\nimport './WorldDepthFirstSearch.js';\nimport './BuildRenderList.js';\nimport './MergeRenderData.js';\nimport './ResetWorldRenderData.js';\nimport { BaseWorld } from './BaseWorld.js';\nimport { CreateWorldRenderData } from './CreateWorldRenderData.js';\n\nclass World extends BaseWorld {\r\n    constructor(scene) {\r\n        super(scene);\r\n        this.enableCameraCull = true;\r\n        this.type = 'World';\r\n        this.camera = new Camera();\r\n        this.renderData = CreateWorldRenderData(this.camera);\r\n    }\r\n}\n\nexport { World };\n", "import '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport '../math/Wrap.js';\nimport '../math/angle/WrapAngle.js';\nimport '../camera/Camera.js';\nimport '../camera/StaticCamera.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/DestroyEvent.js';\nimport '../gameobjects/events/PostUpdateEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../gameobjects/events/UpdateEvent.js';\nimport '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport '../gameobjects/DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport '../display/DestroyChildren.js';\nimport '../display/RemoveChildren.js';\nimport '../display/ReparentChildren.js';\nimport '../events/EventInstance.js';\nimport '../events/Off.js';\nimport '../events/On.js';\nimport '../events/Once.js';\nimport '../gameobjects/components/transform/GetVertices.js';\nimport '../gameobjects/components/bounds/BoundsComponent.js';\nimport '../gameobjects/components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport '../gameobjects/components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport '../gameobjects/components/transform/UpdateWorldTransform.js';\nimport '../gameobjects/components/transform/TransformComponent.js';\nimport '../gameobjects/GameObject.js';\nimport './events/WorldRenderEvent.js';\nimport './events/WorldShutdownEvent.js';\nexport { i as Events } from '../index-664c5328.js';\nexport { CalculateTotalRenderable } from './CalculateTotalRenderable.js';\nexport { HasDirtyChildren } from './HasDirtyChildren.js';\nexport { UpdateCachedLayers } from './UpdateCachedLayers.js';\nexport { WorldDepthFirstSearch } from './WorldDepthFirstSearch.js';\nexport { BuildRenderList } from './BuildRenderList.js';\nexport { MergeRenderData } from './MergeRenderData.js';\nexport { ResetWorldRenderData } from './ResetWorldRenderData.js';\nexport { BaseWorld } from './BaseWorld.js';\nexport { CreateWorldRenderData } from './CreateWorldRenderData.js';\nexport { StaticWorld } from './StaticWorld.js';\nexport { World } from './World.js';\n", "import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport { SetParent } from './SetParent.js';\n\nfunction AddChild(parent, child) {\r\n    parent.children.push(child);\r\n    SetParent(parent, child);\r\n    child.transform.updateWorld();\r\n    return child;\r\n}\n\nexport { AddChild };\n", "import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport { SetParent } from './SetParent.js';\n\nfunction AddChildAt(parent, index, child) {\r\n    const children = parent.children;\r\n    if (index >= 0 && index <= children.length) {\r\n        SetParent(parent, child);\r\n        children.splice(index, 0, child);\r\n        child.transform.updateWorld();\r\n    }\r\n    return child;\r\n}\n\nexport { AddChildAt };\n", "import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport './SetParent.js';\nimport { AddChild } from './AddChild.js';\n\nfunction AddChildren(parent, ...children) {\r\n    children.forEach(child => {\r\n        AddChild(parent, child);\r\n    });\r\n    return children;\r\n}\n\nexport { AddChildren };\n", "import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport { SetParent } from './SetParent.js';\n\nfunction AddChildrenAt(parent, index, ...children) {\r\n    const parentChildren = parent.children;\r\n    if (index >= 0 && index <= parentChildren.length) {\r\n        children.reverse().forEach(child => {\r\n            children.splice(index, 0, child);\r\n            SetParent(parent, child);\r\n            child.transform.updateWorld();\r\n        });\r\n    }\r\n    return children;\r\n}\n\nexport { AddChildrenAt };\n", "function AddPosition(x, y, ...children) {\r\n    children.forEach(child => {\r\n        child.x += x;\r\n        child.y += y;\r\n    });\r\n    return children;\r\n}\n\nexport { AddPosition };\n", "function AddRotation(rotation, ...children) {\r\n    children.forEach(child => {\r\n        child.rotation += rotation;\r\n    });\r\n    return children;\r\n}\n\nexport { AddRotation };\n", "function AddScale(scaleX, scaleY, ...children) {\r\n    children.forEach(child => {\r\n        child.scaleX += scaleX;\r\n        child.scaleY += scaleY;\r\n    });\r\n    return children;\r\n}\n\nexport { AddScale };\n", "function AddSkew(skewX, skewY, ...children) {\r\n    children.forEach(child => {\r\n        child.skewX += skewX;\r\n        child.skewY += skewY;\r\n    });\r\n    return children;\r\n}\n\nexport { AddSkew };\n", "import { GetChildIndex } from './GetChildIndex.js';\nimport { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction BringChildToTop(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex !== -1 && currentIndex < parentChildren.length) {\r\n        parentChildren.splice(currentIndex, 1);\r\n        parentChildren.push(child);\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { BringChildToTop };\n", "function DepthFirstSearchRecursiveNested(parent, output = []) {\r\n    for (let i = 0; i < parent.numChildren; i++) {\r\n        const node = parent.children[i];\r\n        const children = [];\r\n        output.push({ node, children });\r\n        if (node.numChildren > 0) {\r\n            DepthFirstSearchRecursiveNested(node, children);\r\n        }\r\n    }\r\n    return output;\r\n}\n\nexport { DepthFirstSearchRecursiveNested };\n", "import { DepthFirstSearchRecursiveNested } from './DepthFirstSearchRecursiveNested.js';\n\nfunction GetInfo(entry) {\r\n    const legend = (entry.numChildren > 0) ? 'Parent' : 'Child';\r\n    return `${legend} [ type=${entry.type}, name=${entry.name} ]`;\r\n}\r\nfunction LogChildren(entry) {\r\n    console.group(GetInfo(entry.node));\r\n    entry.children.forEach(child => {\r\n        if (child.children.length > 0) {\r\n            LogChildren(child);\r\n        }\r\n        else {\r\n            console.log(GetInfo(child.node));\r\n        }\r\n    });\r\n    console.groupEnd();\r\n}\r\nfunction ConsoleTreeChildren(parent) {\r\n    const entries = DepthFirstSearchRecursiveNested(parent);\r\n    if (parent.world === parent) {\r\n        console.group('World');\r\n    }\r\n    else {\r\n        console.group(GetInfo(parent));\r\n    }\r\n    entries.forEach(entry => {\r\n        if (entry.children.length) {\r\n            LogChildren(entry);\r\n        }\r\n        else {\r\n            console.log(GetInfo(entry.node));\r\n        }\r\n    });\r\n    console.groupEnd();\r\n}\n\nexport { ConsoleTreeChildren };\n", "function CountMatchingChildren(parent, property, value) {\r\n    const children = parent.children;\r\n    let total = 0;\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            total++;\r\n        }\r\n    });\r\n    return total;\r\n}\n\nexport { CountMatchingChildren };\n", "function DepthFirstSearchRecursive(parent, output = []) {\r\n    for (let i = 0; i < parent.numChildren; i++) {\r\n        const child = parent.children[i];\r\n        output.push(child);\r\n        if (child.numChildren > 0) {\r\n            DepthFirstSearchRecursive(child, output);\r\n        }\r\n    }\r\n    return output;\r\n}\n\nexport { DepthFirstSearchRecursive };\n", "import { DepthFirstSearch } from './DepthFirstSearch.js';\n\nfunction FindChildByName(parent, searchString) {\r\n    const children = DepthFirstSearch(parent);\r\n    const regex = RegExp(searchString);\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (regex.test(child.name)) {\r\n            return child;\r\n        }\r\n    }\r\n}\n\nexport { FindChildByName };\n", "import { DepthFirstSearch } from './DepthFirstSearch.js';\n\nfunction FindChildrenByName(parent, searchString) {\r\n    const children = DepthFirstSearch(parent);\r\n    const regex = RegExp(searchString);\r\n    const results = [];\r\n    children.forEach(child => {\r\n        if (regex.test(child.name)) {\r\n            results.push(child);\r\n        }\r\n    });\r\n    return results;\r\n}\n\nexport { FindChildrenByName };\n", "import { DepthFirstSearch } from './DepthFirstSearch.js';\n\nfunction GetAllChildren(parent, property, value) {\r\n    const children = DepthFirstSearch(parent);\r\n    if (!property) {\r\n        return children;\r\n    }\r\n    const results = [];\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            results.push(child);\r\n        }\r\n    });\r\n    return results;\r\n}\n\nexport { GetAllChildren };\n", "function GetChildAt(parent, index) {\r\n    const children = parent.children;\r\n    if (index < 0 || index > children.length) {\r\n        throw new Error(`Index out of bounds: ${index}`);\r\n    }\r\n    return children[index];\r\n}\n\nexport { GetChildAt };\n", "function GetChildren(parent, property, value) {\r\n    const children = parent.children;\r\n    if (!property) {\r\n        return [...children];\r\n    }\r\n    const results = [];\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            results.push(child);\r\n        }\r\n    });\r\n    return results;\r\n}\n\nexport { GetChildren };\n", "function DistanceBetweenPoints(a, b) {\r\n    const dx = a.x - b.x;\r\n    const dy = a.y - b.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\n\nexport { DistanceBetweenPoints };\n", "import { DistanceBetweenPoints } from '../math/distance/DistanceBetweenPoints.js';\n\nfunction GetClosestChild(parent, point) {\r\n    const children = parent.children;\r\n    let closest = null;\r\n    let distance = 0;\r\n    children.forEach(child => {\r\n        const childDistance = DistanceBetweenPoints(point, child.transform.position);\r\n        if (!closest || childDistance < distance) {\r\n            closest = child;\r\n            distance = childDistance;\r\n        }\r\n    });\r\n    return closest;\r\n}\n\nexport { GetClosestChild };\n", "function GetFirstChild(parent, property, value) {\r\n    const children = parent.children;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            return child;\r\n        }\r\n    }\r\n}\n\nexport { GetFirstChild };\n", "import { DistanceBetweenPoints } from '../math/distance/DistanceBetweenPoints.js';\n\nfunction GetFurthestChild(parent, point) {\r\n    const children = parent.children;\r\n    let furthest = null;\r\n    let distance = 0;\r\n    children.forEach(child => {\r\n        const childDistance = DistanceBetweenPoints(point, child.transform.position);\r\n        if (!furthest || childDistance > distance) {\r\n            furthest = child;\r\n            distance = childDistance;\r\n        }\r\n    });\r\n    return furthest;\r\n}\n\nexport { GetFurthestChild };\n", "function GetLastChild(parent, property, value) {\r\n    const children = parent.children;\r\n    for (let i = children.length - 1; i >= 0; i--) {\r\n        const child = children[i];\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            return child;\r\n        }\r\n    }\r\n}\n\nexport { GetLastChild };\n", "function GetParents(child) {\r\n    const parents = [];\r\n    while (child.parent) {\r\n        parents.push(child.parent);\r\n        child = child.parent;\r\n    }\r\n    return parents;\r\n}\n\nexport { GetParents };\n", "function GetRandomChild(parent, startIndex = 0, length) {\r\n    const children = parent.children;\r\n    if (!length) {\r\n        length = children.length;\r\n    }\r\n    const randomIndex = startIndex + Math.floor(Math.random() * length);\r\n    return children[randomIndex];\r\n}\n\nexport { GetRandomChild };\n", "import { GetChildIndex } from './GetChildIndex.js';\nimport { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction MoveChildDown(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex > 0) {\r\n        const child2 = parentChildren[currentIndex - 1];\r\n        const index2 = parentChildren.indexOf(child2);\r\n        parentChildren[currentIndex] = child2;\r\n        parentChildren[index2] = child;\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n        child2.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { MoveChildDown };\n", "import { GetChildIndex } from './GetChildIndex.js';\nimport { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction MoveChildTo(parent, child, index) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex === -1 || index < 0 || index >= parentChildren.length) {\r\n        throw new Error('Index out of bounds');\r\n    }\r\n    if (currentIndex !== index) {\r\n        parentChildren.splice(currentIndex, 1);\r\n        parentChildren.splice(index, 0, child);\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { MoveChildTo };\n", "import { GetChildIndex } from './GetChildIndex.js';\nimport { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction MoveChildUp(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex !== -1 && currentIndex > 0) {\r\n        const child2 = parentChildren[currentIndex + 1];\r\n        const index2 = parentChildren.indexOf(child2);\r\n        parentChildren[currentIndex] = child2;\r\n        parentChildren[index2] = child;\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n        child2.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { MoveChildUp };\n", "function RectangleToRectangle(rectA, rectB) {\r\n    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0) {\r\n        return false;\r\n    }\r\n    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);\r\n}\n\nexport { RectangleToRectangle };\n", "import { RectangleToRectangle } from '../geom/intersects/RectangleToRectangle.js';\n\nfunction Overlap(source, ...targets) {\r\n    const sourceBounds = source.bounds.get();\r\n    for (let i = 0; i < targets.length; i++) {\r\n        const target = targets[i];\r\n        const targetBounds = target.bounds.get();\r\n        if (RectangleToRectangle(sourceBounds, targetBounds)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\nexport { Overlap };\n", "import { RemoveChildAt } from './RemoveChildAt.js';\n\nfunction RemoveChildrenAt(parent, ...index) {\r\n    const removed = [];\r\n    index.sort((a, b) => a - b);\r\n    index.reverse().forEach(i => {\r\n        const child = RemoveChildAt(parent, i);\r\n        if (child) {\r\n            removed.push(child);\r\n        }\r\n    });\r\n    return removed;\r\n}\n\nexport { RemoveChildrenAt };\n", "import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction RotateChildrenLeft(parent, total = 1) {\r\n    const parentChildren = parent.children;\r\n    let child = null;\r\n    for (let i = 0; i < total; i++) {\r\n        child = parentChildren.shift();\r\n        parentChildren.push(child);\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { RotateChildrenLeft };\n", "import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction RotateChildrenRight(parent, total = 1) {\r\n    const parentChildren = parent.children;\r\n    let child = null;\r\n    for (let i = 0; i < total; i++) {\r\n        child = parentChildren.pop();\r\n        parentChildren.unshift(child);\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { RotateChildrenRight };\n", "import { GetChildIndex } from './GetChildIndex.js';\nimport { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction SendChildToBack(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex !== -1 && currentIndex > 0) {\r\n        parentChildren.splice(currentIndex, 1);\r\n        parentChildren.unshift(child);\r\n        child.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return child;\r\n}\n\nexport { SendChildToBack };\n", "function SetBounds(x, y, width, height, ...children) {\r\n    children.forEach(child => {\r\n        child.bounds.set(x, y, width, height);\r\n    });\r\n    return children;\r\n}\n\nexport { SetBounds };\n", "import { DepthFirstSearch } from './DepthFirstSearch.js';\n\nfunction SetChildrenValue(parent, property, value) {\r\n    const children = DepthFirstSearch(parent);\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor) {\r\n            descriptor.set(value);\r\n        }\r\n    });\r\n    return children;\r\n}\n\nexport { SetChildrenValue };\n", "function SetName(name, ...children) {\r\n    children.forEach(child => {\r\n        child.name = name;\r\n    });\r\n    return children;\r\n}\n\nexport { SetName };\n", "function SetOrigin(originX, originY, ...children) {\r\n    children.forEach(child => {\r\n        child.setOrigin(originX, originY);\r\n    });\r\n    return children;\r\n}\n\nexport { SetOrigin };\n", "function SetPosition(x, y, ...children) {\r\n    children.forEach(child => {\r\n        child.setPosition(x, y);\r\n    });\r\n    return children;\r\n}\n\nexport { SetPosition };\n", "function SetRotation(rotation, ...children) {\r\n    children.forEach(child => {\r\n        child.rotation = rotation;\r\n    });\r\n    return children;\r\n}\n\nexport { SetRotation };\n", "function SetScale(scaleX, scaleY, ...children) {\r\n    children.forEach(child => {\r\n        child.setScale(scaleX, scaleY);\r\n    });\r\n    return children;\r\n}\n\nexport { SetScale };\n", "function SetSize(width, height, ...children) {\r\n    children.forEach(child => {\r\n        child.setSize(width, height);\r\n    });\r\n    return children;\r\n}\n\nexport { SetSize };\n", "function SetSkew(skewX, skewY, ...children) {\r\n    children.forEach(child => {\r\n        child.setSkew(skewX, skewY);\r\n    });\r\n    return children;\r\n}\n\nexport { SetSkew };\n", "function SetType(type, ...children) {\r\n    children.forEach(child => {\r\n        child.type = type;\r\n    });\r\n    return children;\r\n}\n\nexport { SetType };\n", "function SetValue(property, value, ...children) {\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor) {\r\n            descriptor.set(value);\r\n        }\r\n    });\r\n    return children;\r\n}\n\nexport { SetValue };\n", "function SetVisible(visible, ...children) {\r\n    children.forEach(child => {\r\n        child.visible = visible;\r\n    });\r\n    return children;\r\n}\n\nexport { SetVisible };\n", "import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction ShuffleChildren(parent) {\r\n    const children = parent.children;\r\n    for (let i = children.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        const temp = children[i];\r\n        children[i] = children[j];\r\n        children[j] = temp;\r\n        temp.setDirty(DIRTY_CONST.TRANSFORM);\r\n    }\r\n    return children;\r\n}\n\nexport { ShuffleChildren };\n", "import { GetChildIndex } from './GetChildIndex.js';\n\nfunction SwapChildren(child1, child2) {\r\n    if (child1.parent === child2.parent) {\r\n        const children = child1.parent.children;\r\n        const index1 = GetChildIndex(child1.parent, child1);\r\n        const index2 = GetChildIndex(child2.parent, child2);\r\n        if (index1 !== index2) {\r\n            children[index1] = child2;\r\n            children[index2] = child1;\r\n        }\r\n    }\r\n}\n\nexport { SwapChildren };\n", "export { DepthFirstSearch } from './DepthFirstSearch.js';\nexport { GetChildIndex } from './GetChildIndex.js';\nexport { RemoveChildAt } from './RemoveChildAt.js';\nexport { RemoveChild } from './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nexport { SetWorld } from './SetWorld.js';\nexport { SetParent } from './SetParent.js';\nexport { AddChild } from './AddChild.js';\nexport { AddChildAt } from './AddChildAt.js';\nexport { AddChildren } from './AddChildren.js';\nexport { AddChildrenAt } from './AddChildrenAt.js';\nexport { AddPosition } from './AddPosition.js';\nexport { AddRotation } from './AddRotation.js';\nexport { AddScale } from './AddScale.js';\nexport { AddSkew } from './AddSkew.js';\nimport '../gameobjects/DIRTY_CONST.js';\nexport { BringChildToTop } from './BringChildToTop.js';\nexport { DepthFirstSearchRecursiveNested } from './DepthFirstSearchRecursiveNested.js';\nexport { ConsoleTreeChildren } from './ConsoleTreeChildren.js';\nexport { CountMatchingChildren } from './CountMatchingChildren.js';\nexport { DepthFirstSearchRecursive } from './DepthFirstSearchRecursive.js';\nexport { RemoveChildrenBetween } from './RemoveChildrenBetween.js';\nexport { DestroyChildren } from './DestroyChildren.js';\nexport { FindChildByName } from './FindChildByName.js';\nexport { FindChildrenByName } from './FindChildrenByName.js';\nexport { GetAllChildren } from './GetAllChildren.js';\nexport { GetChildAt } from './GetChildAt.js';\nexport { GetChildren } from './GetChildren.js';\nimport '../math/distance/DistanceBetweenPoints.js';\nexport { GetClosestChild } from './GetClosestChild.js';\nexport { GetFirstChild } from './GetFirstChild.js';\nexport { GetFurthestChild } from './GetFurthestChild.js';\nexport { GetLastChild } from './GetLastChild.js';\nexport { GetParents } from './GetParents.js';\nexport { GetRandomChild } from './GetRandomChild.js';\nexport { MoveChildDown } from './MoveChildDown.js';\nexport { MoveChildTo } from './MoveChildTo.js';\nexport { MoveChildUp } from './MoveChildUp.js';\nimport '../geom/intersects/RectangleToRectangle.js';\nexport { Overlap } from './Overlap.js';\nexport { RemoveChildren } from './RemoveChildren.js';\nexport { RemoveChildrenAt } from './RemoveChildrenAt.js';\nexport { ReparentChildren } from './ReparentChildren.js';\nexport { RotateChildrenLeft } from './RotateChildrenLeft.js';\nexport { RotateChildrenRight } from './RotateChildrenRight.js';\nexport { SendChildToBack } from './SendChildToBack.js';\nexport { SetBounds } from './SetBounds.js';\nexport { SetChildrenValue } from './SetChildrenValue.js';\nexport { SetName } from './SetName.js';\nexport { SetOrigin } from './SetOrigin.js';\nexport { SetPosition } from './SetPosition.js';\nexport { SetRotation } from './SetRotation.js';\nexport { SetScale } from './SetScale.js';\nexport { SetSize } from './SetSize.js';\nexport { SetSkew } from './SetSkew.js';\nexport { SetType } from './SetType.js';\nexport { SetValue } from './SetValue.js';\nexport { SetVisible } from './SetVisible.js';\nexport { ShuffleChildren } from './ShuffleChildren.js';\nexport { SwapChildren } from './SwapChildren.js';\n", "function BatchTexturedQuad(sprite, renderer) {\r\n    const texture = sprite.texture;\r\n    const shader = renderer.shaders.current;\r\n    const buffer = shader.buffer;\r\n    const binding = texture.binding;\r\n    if (shader.count === buffer.batchSize) {\r\n        renderer.flush();\r\n    }\r\n    const data = sprite.vertexData;\r\n    renderer.textures.request(texture);\r\n    const textureIndex = binding.index;\r\n    data[4] = textureIndex;\r\n    data[10] = textureIndex;\r\n    data[16] = textureIndex;\r\n    data[22] = textureIndex;\r\n    const offset = shader.count * buffer.quadElementSize;\r\n    buffer.vertexViewF32.set(data, offset);\r\n    const color = sprite.vertexColor;\r\n    const U32 = buffer.vertexViewU32;\r\n    U32[offset + 5] = color[0];\r\n    U32[offset + 11] = color[2];\r\n    U32[offset + 17] = color[3];\r\n    U32[offset + 23] = color[1];\r\n    shader.count++;\r\n}\n\nexport { BatchTexturedQuad };\n", "import '../../GameInstance.js';\nimport '../../math/matrix2d/Matrix2D.js';\nimport '../../geom/rectangle/Contains.js';\nimport '../../geom/rectangle/Rectangle.js';\nimport '../../utils/NOOP.js';\nimport '../../math/vec2/Vec2Callback.js';\nimport '../../config/DefaultOrigin.js';\nimport '../../display/DepthFirstSearch.js';\nimport '../../display/GetChildIndex.js';\nimport '../../display/RemoveChildAt.js';\nimport '../../display/RemoveChild.js';\nimport '../events/AddedToWorldEvent.js';\nimport '../events/DestroyEvent.js';\nimport '../events/RemovedFromWorldEvent.js';\nimport '../../events/Emit.js';\nimport '../../display/SetWorld.js';\nimport '../../display/SetParent.js';\nimport { DIRTY_CONST } from '../DIRTY_CONST.js';\nimport '../../display/RemoveChildrenBetween.js';\nimport '../../display/DestroyChildren.js';\nimport '../../display/ReparentChildren.js';\nimport '../components/transform/GetVertices.js';\nimport '../components/bounds/BoundsComponent.js';\nimport '../components/input/InputComponent.js';\nimport '../../math/vec2/Vec2.js';\nimport '../components/transform/UpdateLocalTransform.js';\nimport '../../math/matrix2d/Copy.js';\nimport '../components/transform/UpdateWorldTransform.js';\nimport '../components/transform/TransformComponent.js';\nimport { GameObject } from '../GameObject.js';\n\nclass Container extends GameObject {\r\n    constructor(x = 0, y = 0) {\r\n        super(x, y);\r\n        this._alpha = 1;\r\n        this.type = 'Container';\r\n    }\r\n    setSize(width, height = width) {\r\n        this.transform.updateExtent(width, height);\r\n        return this;\r\n    }\r\n    setPosition(x, y) {\r\n        this.transform.position.set(x, y);\r\n        return this;\r\n    }\r\n    setOrigin(x, y = x) {\r\n        this.transform.origin.set(x, y);\r\n        return this;\r\n    }\r\n    setSkew(x, y = x) {\r\n        this.transform.skew.set(x, y);\r\n        return this;\r\n    }\r\n    setScale(x, y = x) {\r\n        this.transform.scale.set(x, y);\r\n        return this;\r\n    }\r\n    setRotation(value) {\r\n        this.transform.rotation = value;\r\n        return this;\r\n    }\r\n    set width(value) {\r\n        this.transform.updateExtent(value);\r\n    }\r\n    get width() {\r\n        return this.transform.extent.width;\r\n    }\r\n    set height(value) {\r\n        this.transform.updateExtent(undefined, value);\r\n    }\r\n    get height() {\r\n        return this.transform.extent.height;\r\n    }\r\n    set x(value) {\r\n        this.transform.position.x = value;\r\n    }\r\n    get x() {\r\n        return this.transform.position.x;\r\n    }\r\n    set y(value) {\r\n        this.transform.position.y = value;\r\n    }\r\n    get y() {\r\n        return this.transform.position.y;\r\n    }\r\n    set originX(value) {\r\n        this.transform.origin.x = value;\r\n    }\r\n    get originX() {\r\n        return this.transform.origin.x;\r\n    }\r\n    set originY(value) {\r\n        this.transform.origin.y = value;\r\n    }\r\n    get originY() {\r\n        return this.transform.origin.y;\r\n    }\r\n    set skewX(value) {\r\n        this.transform.skew.x = value;\r\n    }\r\n    get skewX() {\r\n        return this.transform.skew.x;\r\n    }\r\n    set skewY(value) {\r\n        this.transform.skew.y = value;\r\n    }\r\n    get skewY() {\r\n        return this.transform.skew.y;\r\n    }\r\n    set scaleX(value) {\r\n        this.transform.scale.x = value;\r\n    }\r\n    get scaleX() {\r\n        return this.transform.scale.x;\r\n    }\r\n    set scaleY(value) {\r\n        this.transform.scale.y = value;\r\n    }\r\n    get scaleY() {\r\n        return this.transform.scale.y;\r\n    }\r\n    set rotation(value) {\r\n        this.transform.rotation = value;\r\n    }\r\n    get rotation() {\r\n        return this.transform.rotation;\r\n    }\r\n    get alpha() {\r\n        return this._alpha;\r\n    }\r\n    set alpha(value) {\r\n        if (value !== this._alpha) {\r\n            this._alpha = value;\r\n            this.setDirty(DIRTY_CONST.TRANSFORM);\r\n        }\r\n    }\r\n}\n\nexport { Container };\n", "function DrawTexturedQuad(sprite, renderer) {\r\n    const frame = sprite.frame;\r\n    if (!frame) {\r\n        return;\r\n    }\r\n    const ctx = renderer.ctx;\r\n    const transform = sprite.transform;\r\n    const { a, b, c, d, tx, ty } = transform.world;\r\n    const { x, y } = transform.extent;\r\n    ctx.save();\r\n    ctx.setTransform(a, b, c, d, tx, ty);\r\n    ctx.globalAlpha = sprite.alpha;\r\n    ctx.drawImage(frame.texture.image, frame.x, frame.y, frame.width, frame.height, x, y, frame.width, frame.height);\r\n    ctx.restore();\r\n}\n\nexport { DrawTexturedQuad };\n", "function PackColor(rgb, alpha) {\r\n    const ua = ((alpha * 255) | 0) & 0xFF;\r\n    return ((ua << 24) | rgb) >>> 0;\r\n}\n\nexport { PackColor };\n", "import { PackColor } from './PackColor.js';\n\nfunction PackColors(sprite) {\r\n    const alpha = sprite.vertexAlpha;\r\n    const tint = sprite.vertexTint;\r\n    const color = sprite.vertexColor;\r\n    color[0] = PackColor(tint[0], alpha[0]);\r\n    color[1] = PackColor(tint[1], alpha[1]);\r\n    color[2] = PackColor(tint[2], alpha[2]);\r\n    color[3] = PackColor(tint[3], alpha[3]);\r\n    return sprite;\r\n}\n\nexport { PackColors };\n", "function SetFrame(texture, key, ...children) {\r\n    const frame = texture.getFrame(key);\r\n    const { u0, u1, v0, v1, pivot } = frame;\r\n    children.forEach(child => {\r\n        if (!child || frame === child.frame) {\r\n            return;\r\n        }\r\n        child.frame = frame;\r\n        if (pivot) {\r\n            child.setOrigin(pivot.x, pivot.y);\r\n        }\r\n        child.frame.setExtent(child);\r\n        child.hasTexture = true;\r\n        const data = child.vertexData;\r\n        data[2] = u0;\r\n        data[3] = v0;\r\n        data[8] = u0;\r\n        data[9] = v1;\r\n        data[14] = u1;\r\n        data[15] = v1;\r\n        data[20] = u1;\r\n        data[21] = v0;\r\n    });\r\n    return children;\r\n}\n\nexport { SetFrame };\n", "import '../../renderer/BindingQueue.js';\nimport '../../textures/Frame.js';\nimport { Texture } from '../../textures/Texture.js';\nimport { TextureManagerInstance } from '../../textures/TextureManagerInstance.js';\nimport { SetFrame } from './SetFrame.js';\n\nfunction SetTexture(key, frame, ...children) {\r\n    if (!key) {\r\n        children.forEach(child => {\r\n            child.texture = null;\r\n            child.frame = null;\r\n            child.hasTexture = false;\r\n        });\r\n    }\r\n    else {\r\n        let texture;\r\n        if (key instanceof Texture) {\r\n            texture = key;\r\n        }\r\n        else {\r\n            texture = TextureManagerInstance.get().get(key);\r\n        }\r\n        if (!texture) {\r\n            console.warn(`Invalid Texture key: ${key}`);\r\n        }\r\n        else {\r\n            children.forEach(child => {\r\n                child.texture = texture;\r\n            });\r\n            SetFrame(texture, frame, ...children);\r\n        }\r\n    }\r\n    return children;\r\n}\n\nexport { SetTexture };\n", "import { GetVertices } from '../components/transform/GetVertices.js';\n\nfunction UpdateVertices(sprite) {\r\n    const data = sprite.vertexData;\r\n    const { x0, y0, x1, y1, x2, y2, x3, y3 } = GetVertices(sprite.transform);\r\n    data[0] = x0;\r\n    data[1] = y0;\r\n    data[6] = x1;\r\n    data[7] = y1;\r\n    data[12] = x2;\r\n    data[13] = y2;\r\n    data[18] = x3;\r\n    data[19] = y3;\r\n    return sprite;\r\n}\n\nexport { UpdateVertices };\n", "import '../../GameInstance.js';\nimport '../../math/matrix2d/Matrix2D.js';\nimport '../../geom/rectangle/Contains.js';\nimport '../../geom/rectangle/Rectangle.js';\nimport '../../utils/NOOP.js';\nimport '../../math/vec2/Vec2Callback.js';\nimport '../../renderer/BindingQueue.js';\nimport '../../config/DefaultOrigin.js';\nimport '../../textures/Frame.js';\nimport '../../textures/Texture.js';\nimport '../../display/DepthFirstSearch.js';\nimport '../../display/GetChildIndex.js';\nimport '../../display/RemoveChildAt.js';\nimport '../../display/RemoveChild.js';\nimport '../events/AddedToWorldEvent.js';\nimport '../events/DestroyEvent.js';\nimport '../events/RemovedFromWorldEvent.js';\nimport '../../events/Emit.js';\nimport '../../display/SetWorld.js';\nimport '../../display/SetParent.js';\nimport { DIRTY_CONST } from '../DIRTY_CONST.js';\nimport '../../display/RemoveChildrenBetween.js';\nimport '../../display/DestroyChildren.js';\nimport '../../display/ReparentChildren.js';\nimport '../../textures/TextureManagerInstance.js';\nimport { BatchTexturedQuad } from '../../renderer/webgl1/draw/BatchTexturedQuad.js';\nimport '../components/transform/GetVertices.js';\nimport '../components/bounds/BoundsComponent.js';\nimport '../components/input/InputComponent.js';\nimport '../../math/vec2/Vec2.js';\nimport '../components/transform/UpdateLocalTransform.js';\nimport '../../math/matrix2d/Copy.js';\nimport '../components/transform/UpdateWorldTransform.js';\nimport '../components/transform/TransformComponent.js';\nimport '../GameObject.js';\nimport { Container } from '../container/Container.js';\nimport { DrawTexturedQuad } from '../../renderer/canvas/draw/DrawTexturedQuad.js';\nimport '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\nimport { SetFrame } from './SetFrame.js';\nimport { SetTexture } from './SetTexture.js';\nimport { UpdateVertices } from './UpdateVertices.js';\n\nclass Sprite extends Container {\r\n    constructor(x, y, texture, frame) {\r\n        super(x, y);\r\n        this.hasTexture = false;\r\n        this._tint = 0xffffff;\r\n        this.type = 'Sprite';\r\n        this.vertexData = new Float32Array(24).fill(0);\r\n        this.vertexColor = new Uint32Array(4).fill(4294967295);\r\n        this.vertexAlpha = new Float32Array(4).fill(1);\r\n        this.vertexTint = new Uint32Array(4).fill(0xffffff);\r\n        this.setTexture(texture, frame);\r\n    }\r\n    setTexture(key, frame) {\r\n        SetTexture(key, frame, this);\r\n        return this;\r\n    }\r\n    setFrame(key) {\r\n        SetFrame(this.texture, key, this);\r\n        return this;\r\n    }\r\n    isRenderable() {\r\n        return (this.visible && this.willRender && this.hasTexture && this.alpha > 0);\r\n    }\r\n    preRender() {\r\n        if (this.isDirty(DIRTY_CONST.COLORS)) {\r\n            PackColors(this);\r\n            this.clearDirty(DIRTY_CONST.COLORS);\r\n        }\r\n        if (this.isDirty(DIRTY_CONST.TRANSFORM)) {\r\n            UpdateVertices(this);\r\n            this.clearDirty(DIRTY_CONST.TRANSFORM);\r\n        }\r\n    }\r\n    renderGL(renderer) {\r\n        this.preRender();\r\n        BatchTexturedQuad(this, renderer);\r\n    }\r\n    renderCanvas(renderer) {\r\n        this.preRender();\r\n        DrawTexturedQuad(this, renderer);\r\n    }\r\n    get alpha() {\r\n        return this._alpha;\r\n    }\r\n    set alpha(value) {\r\n        if (value !== this._alpha) {\r\n            this._alpha = value;\r\n            const vertexAlpha = this.vertexAlpha;\r\n            vertexAlpha[0] = value;\r\n            vertexAlpha[1] = value;\r\n            vertexAlpha[2] = value;\r\n            vertexAlpha[3] = value;\r\n            this.setDirty(DIRTY_CONST.ALPHA);\r\n        }\r\n    }\r\n    get tint() {\r\n        return this._tint;\r\n    }\r\n    set tint(value) {\r\n        if (value !== this._tint) {\r\n            this._tint = value;\r\n            const vertexTint = this.vertexTint;\r\n            vertexTint[0] = value;\r\n            vertexTint[1] = value;\r\n            vertexTint[2] = value;\r\n            vertexTint[3] = value;\r\n            this.setDirty(DIRTY_CONST.COLORS);\r\n        }\r\n    }\r\n    destroy(reparentChildren) {\r\n        super.destroy(reparentChildren);\r\n        this.texture = null;\r\n        this.frame = null;\r\n        this.hasTexture = false;\r\n        this.vertexData = null;\r\n        this.vertexColor = null;\r\n        this.vertexAlpha = null;\r\n        this.vertexTint = null;\r\n    }\r\n}\n\nexport { Sprite };\n", "import '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\n\nfunction SetAlpha(alpha, ...children) {\r\n    children.forEach(child => {\r\n        const vertexAlpha = child.vertexAlpha;\r\n        vertexAlpha[0] = alpha;\r\n        vertexAlpha[1] = alpha;\r\n        vertexAlpha[2] = alpha;\r\n        vertexAlpha[3] = alpha;\r\n        PackColors(child);\r\n    });\r\n    return children;\r\n}\n\nexport { SetAlpha };\n", "import '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\n\nfunction SetQuadAlpha(topLeft, topRight, bottomLeft, bottomRight, ...children) {\r\n    children.forEach(child => {\r\n        const alpha = child.vertexAlpha;\r\n        alpha[0] = topLeft;\r\n        alpha[1] = topRight;\r\n        alpha[2] = bottomLeft;\r\n        alpha[3] = bottomRight;\r\n        PackColors(child);\r\n    });\r\n    return children;\r\n}\n\nexport { SetQuadAlpha };\n", "import '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\n\nfunction SetQuadTint(topLeft, topRight, bottomLeft, bottomRight, ...children) {\r\n    children.forEach(child => {\r\n        const tint = child.vertexTint;\r\n        tint[0] = topLeft;\r\n        tint[1] = topRight;\r\n        tint[2] = bottomLeft;\r\n        tint[3] = bottomRight;\r\n        PackColors(child);\r\n    });\r\n    return children;\r\n}\n\nexport { SetQuadTint };\n", "import '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\n\nfunction SetTint(tint, ...children) {\r\n    children.forEach(child => {\r\n        const vertexTint = child.vertexTint;\r\n        vertexTint[0] = tint;\r\n        vertexTint[1] = tint;\r\n        vertexTint[2] = tint;\r\n        vertexTint[3] = tint;\r\n        PackColors(child);\r\n    });\r\n    return children;\r\n}\n\nexport { SetTint };\n", "import '../../GameInstance.js';\nimport '../../math/matrix2d/Matrix2D.js';\nimport '../../geom/rectangle/Contains.js';\nimport '../../geom/rectangle/Rectangle.js';\nimport '../../utils/NOOP.js';\nimport '../../math/vec2/Vec2Callback.js';\nimport '../../renderer/BindingQueue.js';\nimport '../../config/DefaultOrigin.js';\nimport '../../textures/Frame.js';\nimport '../../textures/Texture.js';\nimport '../../display/DepthFirstSearch.js';\nimport '../../display/GetChildIndex.js';\nimport '../../display/RemoveChildAt.js';\nimport '../../display/RemoveChild.js';\nimport '../events/AddedToWorldEvent.js';\nimport '../events/DestroyEvent.js';\nimport '../events/RemovedFromWorldEvent.js';\nimport '../../events/Emit.js';\nimport '../../display/SetWorld.js';\nimport '../../display/SetParent.js';\nimport '../DIRTY_CONST.js';\nimport '../../display/RemoveChildrenBetween.js';\nimport '../../display/DestroyChildren.js';\nimport '../../display/ReparentChildren.js';\nimport '../../textures/TextureManagerInstance.js';\nimport '../../renderer/webgl1/draw/BatchTexturedQuad.js';\nimport '../components/transform/GetVertices.js';\nimport '../components/bounds/BoundsComponent.js';\nimport '../components/input/InputComponent.js';\nimport '../../math/vec2/Vec2.js';\nimport '../components/transform/UpdateLocalTransform.js';\nimport '../../math/matrix2d/Copy.js';\nimport '../components/transform/UpdateWorldTransform.js';\nimport '../components/transform/TransformComponent.js';\nimport '../GameObject.js';\nimport '../container/Container.js';\nimport '../../renderer/canvas/draw/DrawTexturedQuad.js';\nimport '../../renderer/webgl1/colors/PackColor.js';\nimport '../../renderer/webgl1/colors/PackColors.js';\nexport { SetFrame } from './SetFrame.js';\nexport { SetTexture } from './SetTexture.js';\nexport { UpdateVertices } from './UpdateVertices.js';\nexport { Sprite } from './Sprite.js';\nexport { SetAlpha } from './SetAlpha.js';\nexport { SetQuadAlpha } from './SetQuadAlpha.js';\nexport { SetQuadTint } from './SetQuadTint.js';\nexport { SetTint } from './SetTint.js';\n", "import { XType, YType } from '../../../types';\r\n\r\nexport let GetXYKey = function (\r\n    x: XType | undefined,\r\n    y: YType | undefined\r\n): string | undefined {\r\n\r\n    return ((x === undefined) || (y === undefined)) ? undefined : `${x}|${y}`;\r\n}", "export class Stack {\r\n    items: any[];\r\n\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n\r\n    destroy(): void {\r\n        this.clear();\r\n        this.items = undefined;\r\n    }\r\n\r\n    pop(): any {\r\n        return (this.items.length > 0) ? this.items.pop() : null;\r\n    }\r\n\r\n    push(l: any): this {\r\n        this.items.push(l);\r\n        return this;\r\n    }\r\n\r\n    pushMultiple(arr: any[]): this {\r\n        this.items.push.apply(this.items, arr);\r\n        arr.length = 0;\r\n        return this;\r\n    }\r\n\r\n    clear(): this {\r\n        this.items.length = 0;\r\n        return this;\r\n    }\r\n}", "import { Stack } from '../struct/Stack';\r\n\r\nlet globEmptyMapPool = new Stack();\r\n\r\nexport let GetEmptyMap = function (): Map<any, any> {\r\n    let newMap = globEmptyMapPool.pop();\r\n    if (newMap === null) {\r\n        newMap = new Map();\r\n    }\r\n    return newMap;\r\n}\r\n\r\nexport let FreeEmptyMap = function (map: Map<any, any>): void {\r\n    globEmptyMapPool.push(map);\r\n}\r\n\r\nexport let FreeEmptyMaps = function (maps: Map<any, any>[]): void {\r\n    globEmptyMapPool.pushMultiple(maps);\r\n}", "import { XType, YType, ZType, IChess, ZMapType } from '../../../types';\r\nimport { GetXYKey } from './Key';\r\nimport { FreeEmptyMap, GetEmptyMap } from '../../../../utils/pool/EmptyMap';\r\n\r\nexport let AddChessToZMap = function (\r\n    chess: IChess,\r\n    chessMap: Map<string, ZMapType>,\r\n    prevX: XType | undefined,\r\n    prevY: YType | undefined,\r\n    prevZ: ZType | undefined,\r\n    currX: XType | undefined,\r\n    currY: YType | undefined,\r\n    currZ: ZType | undefined\r\n) {\r\n    if ((prevX === currX) && (prevY === currY) && (prevZ === currZ)) {\r\n        return;\r\n    }\r\n    let prevKey = GetXYKey(prevX, prevY);\r\n    let currKey = GetXYKey(currX, currY);\r\n    if (prevKey) {\r\n        let zMap = chessMap.get(prevKey);\r\n        zMap.delete(prevZ);\r\n        if (prevKey === currKey) {\r\n            zMap.set(currZ, chess);\r\n            return;\r\n        } else if (zMap.size === 0) {\r\n            FreeEmptyMap(zMap); // Add to EmptyMap pool\r\n            chessMap.delete(prevKey);\r\n        }\r\n    }\r\n    if (currKey) {\r\n        let zMap = chessMap.get(currKey);\r\n        if (zMap) {\r\n            zMap.set(currZ, chess);\r\n        } else {\r\n            zMap = GetEmptyMap(); // Request an empty map\r\n            zMap.set(currZ, chess);\r\n            chessMap.set(currKey, zMap);\r\n        }\r\n    }\r\n}\r\n\r\nexport let RemoveChessFromZMap = function (\r\n    chessMap: Map<string, ZMapType>,\r\n    x: XType,\r\n    y: YType,\r\n    z?: ZType\r\n) {\r\n    let key = GetXYKey(x, y);\r\n    let zMap = chessMap.get(key);\r\n    if (zMap) {\r\n        if (z !== undefined) {\r\n            zMap.delete(z);\r\n            if (zMap.size === 0) {\r\n                FreeEmptyMap(zMap); // Add to EmptyMap pool\r\n                chessMap.delete(key);\r\n            }\r\n        } else {\r\n            zMap.clear();\r\n            FreeEmptyMap(zMap); // Add to EmptyMap pool\r\n            chessMap.delete(key);\r\n        }\r\n    }\r\n}", "import { Stack } from '../struct/Stack';\r\n\r\nlet globEmptySetPool = new Stack();\r\n\r\nexport let GetEmptySet = function (): Set<any> {\r\n    let newMap = globEmptySetPool.pop();\r\n    if (newMap === null) {\r\n        newMap = new Set();\r\n    }\r\n    return newMap;\r\n}\r\n\r\nexport let FreeEmptySet = function (map: Set<any>): void {\r\n    globEmptySetPool.push(map);\r\n}\r\n\r\nexport let FreeEmptySets = function (maps: Set<any>[]): void {\r\n    globEmptySetPool.pushMultiple(maps);\r\n}", "import { IChess, AnyKeyType, ChessSetType } from '../../../types';\r\nimport { FreeEmptySet, GetEmptySet } from '../../../../utils/pool/EmptySet';\r\n\r\nexport let AddChessToSet = function (\r\n    chess: IChess,\r\n    chessMap: Map<AnyKeyType, ChessSetType>,\r\n    prevKey: AnyKeyType | undefined,\r\n    currKey: AnyKeyType | undefined\r\n): void {\r\n    if (prevKey === currKey) {\r\n        return;\r\n    }\r\n\r\n    if (prevKey !== undefined) {\r\n        let chessSet = chessMap.get(prevKey);\r\n        if (chessSet) {\r\n            chessSet.delete(chess);\r\n            if (chessSet.size === 0) {\r\n                FreeEmptySet(chessSet); // Add to EmptySet pool\r\n                chessMap.delete(prevKey);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currKey !== undefined) {\r\n        let chessSet = chessMap.get(currKey);\r\n        if (chessSet) {\r\n            chessSet.add(chess);\r\n        } else {\r\n            chessSet = GetEmptySet(); // Request an empty set\r\n            chessSet.add(chess);\r\n            chessMap.set(currKey, chessSet);\r\n        }\r\n    }\r\n}\r\n\r\nexport let RemoveChessFromSet = function (\r\n    chessMap: Map<AnyKeyType, ChessSetType>,\r\n    key: AnyKeyType,\r\n    chess: IChess\r\n): void {\r\n\r\n    let chessSet = chessMap.get(key);\r\n    if (chessSet) {\r\n        chessSet.delete(chess);\r\n        if (chessSet.size === 0) {\r\n            FreeEmptySet(chessSet); // Add to EmptySet pool\r\n            chessMap.delete(key);\r\n        }\r\n    }\r\n}", "import { IBoardData } from '../IBoardData';\r\nimport { XType, YType, ZType, IChess } from '../../../types';\r\nimport { AddChessToZMap } from './ZMap';\r\nimport { AddChessToSet } from './ChessSet';\r\n\r\nexport let AddChess = function (\r\n    boardData: IBoardData,\r\n    chess: IChess,\r\n    x: XType,\r\n    y: YType,\r\n    z: ZType\r\n): void {\r\n\r\n    let prevXYZ = boardData.chessToXYZ.get(chess);\r\n    let prevX = (prevXYZ) ? prevXYZ.x : undefined;\r\n    let prevY = (prevXYZ) ? prevXYZ.y : undefined;\r\n    let prevZ = (prevXYZ) ? prevXYZ.y : undefined;\r\n\r\n    if (prevXYZ) {\r\n        prevXYZ.x = x;\r\n        prevXYZ.y = y;\r\n        prevXYZ.z = z;\r\n    } else {\r\n        boardData.chessToXYZ.set(chess, { x: x, y: y, z: z });\r\n    }\r\n    AddChessToZMap(chess, boardData.XYToZMap, prevX, prevY, prevZ, x, y, z);\r\n    AddChessToSet(chess, boardData.XToChessSet, prevX, x);\r\n    AddChessToSet(chess, boardData.YToChessSet, prevY, y);\r\n    AddChessToSet(chess, boardData.ZToChessSet, prevZ, z);\r\n}", "import { IBoardData } from '../IBoardData';\r\nimport { XType, YType, ZType, IChess, ZMapType } from '../../../types';\r\nimport { GetXYKey } from './Key';\r\n\r\nexport let GetChess = function (\r\n    boardData: IBoardData,\r\n    x: XType,\r\n    y: YType,\r\n    z?: ZType\r\n): IChess | ZMapType | null {\r\n    let zMap = boardData.XYToZMap.get(GetXYKey(x, y));\r\n    if (zMap === undefined) {\r\n        return null;\r\n    }\r\n\r\n    if (z !== undefined) {\r\n        return (zMap.has(z)) ? zMap.get(z) : null;\r\n    } else {\r\n        return zMap;\r\n    }\r\n}", "import { IBoardData } from '../IBoardData';\r\nimport { XType, YType, ZType, IChess, ZMapType } from '../../../types';\r\nimport { GetChess } from './GetChess';\r\nimport { RemoveChessFromZMap } from './ZMap';\r\nimport { RemoveChessFromSet } from './ChessSet';\r\n\r\nexport let RemoveChess = function (\r\n    boardData: IBoardData,\r\n    x: XType,\r\n    y: YType,\r\n    z?: ZType\r\n): void {\r\n\r\n    if (z !== undefined) {\r\n        let chess = GetChess(boardData, x, y, z) as IChess;\r\n        if (chess === undefined) {\r\n            return;\r\n        }\r\n\r\n        boardData.chessToXYZ.delete(chess);\r\n        RemoveChessFromZMap(boardData.XYToZMap, x, y, z);\r\n        RemoveChessFromSet(boardData.XToChessSet, x, chess);\r\n        RemoveChessFromSet(boardData.YToChessSet, y, chess);\r\n        RemoveChessFromSet(boardData.ZToChessSet, z, chess);\r\n\r\n    } else {\r\n\r\n        let zMap = GetChess(boardData, x, y) as ZMapType;\r\n        if (zMap) {\r\n            for (const [z, chess] of zMap) {\r\n                boardData.chessToXYZ.delete(chess);\r\n                // RemoveChessFromZMap(boardData.XYToZMap, x, y, z);\r\n                RemoveChessFromSet(boardData.XToChessSet, x, chess);\r\n                RemoveChessFromSet(boardData.YToChessSet, y, chess);\r\n                RemoveChessFromSet(boardData.ZToChessSet, z, chess);\r\n\r\n            }\r\n\r\n            RemoveChessFromZMap(boardData.XYToZMap, x, y);\r\n\r\n        }\r\n    }\r\n}", "import { IBoardData } from '../IBoardData';\r\nimport { IChess } from '../../../types';\r\n\r\nexport let HasChess = function (\r\n    boardData: IBoardData,\r\n    chess: IChess\r\n): boolean {\r\n\r\n    return boardData.chessToXYZ.has(chess);\r\n}", "import { IBoardData } from '../IBoardData';\r\nimport { XType, YType, ZType } from '../../../types';\r\nimport { GetChess } from './GetChess';\r\n\r\nexport let Contains = function (\r\n    boardData: IBoardData,\r\n    x: XType,\r\n    y: YType,\r\n    z: ZType\r\n): boolean {\r\n\r\n    return (GetChess(boardData, x, y, z) !== null);\r\n}", "import { IBoardData } from '../IBoardData';\r\nimport { IChess, XYZType } from '../../../types';\r\n\r\nexport let GetXYZ = function (\r\n    boardData: IBoardData,\r\n    chess: IChess\r\n): XYZType | null {\r\n\r\n    return boardData.chessToXYZ.get(chess) || null;\r\n}", "export let GetMaxMapKey = function (map: Map<number, any>) {\r\n    let result = -Infinity;\r\n    for (const [key, item] of map) {\r\n        if (result < key) {\r\n            result = key;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport let GetMinMapKey = function (map: Map<number, any>) {\r\n    let result = Infinity;\r\n    for (const [key, item] of map) {\r\n        if (result > key) {\r\n            result = key;\r\n        }\r\n    }\r\n    return result;\r\n}", "import { IBoardData } from './IBoardData';\r\nimport { XType, YType, ZType, XYZType, IChess, ZMapType, ChessSetType } from '../../types';\r\nimport { AddChess } from './methods/AddChess';\r\nimport { GetChess } from './methods/GetChess';\r\nimport { RemoveChess } from './methods/RemoveChess';\r\nimport { HasChess } from './methods/HasChess';\r\nimport { Contains } from './methods/Contains';\r\nimport { GetXYZ } from './methods/GetXYZ';\r\nimport { GetMaxMapKey, GetMinMapKey } from './methods/GetMaxMinMapKey';\r\n\r\nexport class BoardData implements IBoardData {\r\n    chessToXYZ: Map<IChess, XYZType>; // {chess: {x,y,z}}\r\n    XYToZMap: Map<string, Map<ZType, IChess>>; // {'x|y': {z:chess}}\r\n    XToChessSet: Map<XType, ChessSetType>; // {x, [chess]}\r\n    YToChessSet: Map<YType, ChessSetType>; // {y, [chess]}\r\n    ZToChessSet: Map<ZType, ChessSetType>; // {z, [chess]}\r\n\r\n    _xMax: number | undefined;\r\n    _xMin: number | undefined;\r\n    _yMax: number | undefined;\r\n    _yMin: number | undefined;\r\n\r\n    constructor() {\r\n        this.chessToXYZ = new Map();\r\n        this.XYToZMap = new Map();\r\n        this.XToChessSet = new Map();\r\n        this.YToChessSet = new Map();\r\n        this.ZToChessSet = new Map();\r\n\r\n        this._xMax = undefined;\r\n        this._xMin = undefined;\r\n        this._yMax = undefined;\r\n        this._yMin = undefined;\r\n    }\r\n\r\n    destroy(): void {\r\n        this.clear();\r\n    }\r\n\r\n    clear(): this {\r\n        this.chessToXYZ.clear();\r\n        this.XYToZMap.clear();\r\n        this.XToChessSet.clear();\r\n        this.YToChessSet.clear();\r\n        this.ZToChessSet.clear();\r\n        this.clearBounds();\r\n        return this;\r\n    }\r\n\r\n    clearBounds(): this {\r\n        this._xMax = undefined;\r\n        this._xMin = undefined;\r\n        this._yMax = undefined;\r\n        this._yMin = undefined;\r\n        return this;\r\n    }\r\n\r\n    addChess(\r\n        chess: IChess,\r\n        x: XType,\r\n        y: YType,\r\n        z: ZType\r\n    ): this {\r\n\r\n        AddChess(this, chess, x, y, z);\r\n        this.clearBounds();\r\n        return this;\r\n    }\r\n\r\n    getChess(\r\n        x: XType,\r\n        y: YType,\r\n        z?: ZType\r\n    ): IChess | ZMapType | null {\r\n\r\n        return GetChess(this, x, y, z);\r\n    }\r\n\r\n    removeChess(\r\n        x: XType,\r\n        y: YType,\r\n        z?: ZType\r\n    ): this {\r\n\r\n        RemoveChess(this, x, y, z);\r\n        this.clearBounds();\r\n        return this;\r\n    }\r\n\r\n    hasChess(\r\n        chess: IChess\r\n    ): boolean {\r\n\r\n        return HasChess(this, chess);\r\n    }\r\n\r\n    contains(\r\n        x: XType,\r\n        y: YType,\r\n        z?: ZType\r\n    ): boolean {\r\n\r\n        return Contains(this, x, y, z);\r\n    }\r\n\r\n    getXYZ(\r\n        chess: IChess\r\n    ): XYZType | null {\r\n\r\n        return GetXYZ(this, chess);\r\n    }\r\n\r\n    get xMax() {\r\n        if (this._xMax === undefined) {\r\n            this._xMax = GetMaxMapKey(this.XToChessSet);\r\n        }\r\n        return this._xMax;\r\n    }\r\n\r\n    get xMin() {\r\n        if (this._xMin === undefined) {\r\n            this._xMin = GetMinMapKey(this.XToChessSet);\r\n        }\r\n        return this._xMin;\r\n    }\r\n\r\n    get yMax() {\r\n        if (this._yMax === undefined) {\r\n            this._yMax = GetMaxMapKey(this.YToChessSet);\r\n        }\r\n        return this._yMax;\r\n    }\r\n\r\n    get yMin() {\r\n        if (this._yMin === undefined) {\r\n            this._yMin = GetMinMapKey(this.YToChessSet);\r\n        }\r\n        return this._yMin;\r\n    }\r\n}\r\n\r\n\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\n\r\nexport let SetBoardHeight = function (\r\n    board: IBaseBoard,\r\n    height: number\r\n): void {\r\n\r\n    if (board.infinityMode) {\r\n        return;\r\n    }\r\n    if ((board.height === undefined) || (board.height <= height)) {\r\n        board.height = height;\r\n        return;\r\n    }\r\n\r\n    // board.height > height : collapse\r\n    for (let x = 0; x < board.width; x++) {\r\n        for (let y = height; y < board.height; y++) {\r\n\r\n            // TODO: RemoveChess\r\n        }\r\n    }\r\n\r\n    board.height = height;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\n\r\nexport let SetBoardWidth = function (\r\n    board: IBaseBoard,\r\n    width: number\r\n): void {\r\n\r\n    if (board.infinityMode) {\r\n        return;\r\n    }\r\n    if ((board.width === undefined) || (board.width <= width)) {\r\n        board.width = width;\r\n        return;\r\n    }\r\n\r\n    // this.width > width : collapse\r\n    for (let x = width; x < board.width; x++) {\r\n        for (let y = 0; y < board.height; y++) {\r\n            // TODO: RemoveChess\r\n        }\r\n    }\r\n\r\n    board.width = width;\r\n}", "import { BoardData } from './BoardData';\r\nimport { SetBoardHeight } from './SetBoardHeight';\r\nimport { SetBoardWidth } from './SetBoardWidth';\r\n\r\nexport {\r\n    BoardData,\r\n    SetBoardHeight,\r\n    SetBoardWidth\r\n}", "import { IBaseBoard, IConfig } from './IBaseBoard';\r\nimport { IGrid } from '../grid/IGrid';\r\nimport { IBoardData } from './boarddata/IBoardData';\r\nimport { BoardData, SetBoardWidth, SetBoardHeight } from './boarddata';\r\n\r\nexport class BaseBoard implements IBaseBoard {\r\n\r\n    grid: IGrid;\r\n    wrapMode: boolean;\r\n    infinityMode: boolean;\r\n    width: number | undefined;\r\n    height: number | undefined;\r\n    boardData: IBoardData;\r\n    _isBoard: boolean;\r\n\r\n    constructor({\r\n        grid = undefined,\r\n        wrap = false,\r\n        inifinity = false,\r\n        width = 0,\r\n        height = 0\r\n    }: IConfig = {}) {\r\n\r\n        this.boardData = new BoardData();\r\n        this._isBoard = true;\r\n        this.setGrid(grid);\r\n        this.setWrapMode(wrap);\r\n        this.setInfinityMode(inifinity);\r\n        this.setBoardSize(width, height);\r\n    }\r\n\r\n    destroy() {\r\n\r\n    }\r\n\r\n    setGrid(grid?: IGrid): this {\r\n\r\n        this.grid = grid;\r\n        return this;\r\n    }\r\n\r\n    setWrapMode(mode: boolean = true): this {\r\n\r\n        this.wrapMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setInfinityMode(mode: boolean = true): this {\r\n\r\n        this.infinityMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setBoardSize(width: number = 0, height: number = 0): this {\r\n\r\n        SetBoardWidth(this, width);\r\n        SetBoardHeight(this, height);\r\n        return this;\r\n    }\r\n\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, ZType, IChess } from '../../types';\r\n\r\nexport let TileXYZToChess = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ: ZType\r\n): IChess | null {\r\n\r\n    return board.boardData.getChess(tileX, tileY, tileZ) as IChess;\r\n}", "export let IsPlainObject = function (obj: any): boolean {\r\n    // Not plain objects:\r\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n    // - DOM nodes\r\n    // - window\r\n    if (typeof (obj) !== 'object' || obj.nodeType || obj === obj.window) {\r\n        return false;\r\n    }\r\n\r\n    // Support: Firefox <20\r\n    // The try/catch suppresses exceptions thrown when attempting to access\r\n    // the \"constructor\" property of certain host objects, ie. |window.location|\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n    try {\r\n        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n\r\n    // If the function hasn't returned already, we're confident that\r\n    // |obj| is a plain object, created by {} or constructed with new Object\r\n    return true;\r\n};\r\n", "import { IsPlainObject } from '../../utils/object/IsPlainObject';\r\n\r\nexport let IsTileXYZ = function (obj: any): boolean {\r\n    if (IsPlainObject(obj)) {\r\n        return true;\r\n    } else if (typeof (obj) === 'object') {\r\n        return obj.isTileXYZ;\r\n    } else {\r\n        return false;\r\n    }\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYZType, XYType } from '../../types';\r\nimport { IsTileXYZ } from '../../utils/IsTileXYZ';\r\n\r\nexport let ChessToTileXYZ = function (\r\n    board: IBaseBoard,\r\n    chess: IChess | XYZType | XYType\r\n): XYZType | XYType | null {\r\n\r\n    let xyz: XYZType | undefined = board.boardData.getXYZ(chess);\r\n    if (xyz) {\r\n        return xyz;\r\n    } else if (IsTileXYZ(chess)) { // {x, y}, or {x, y, z}\r\n        return chess as XYType;\r\n    } else {\r\n        return null;\r\n    }\r\n\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, ZType } from '../../types';\r\n\r\nexport let Contains = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ?: ZType\r\n): boolean {\r\n\r\n    let result: boolean;\r\n    if (board.infinityMode) {\r\n        result = true;\r\n    } else {\r\n        result = (tileX >= 0) && (tileX < board.width) &&\r\n            (tileY >= 0) && (tileY < board.height);\r\n    }\r\n    if (result && (tileZ !== undefined)) {\r\n        result = board.boardData.contains(tileX, tileY, tileZ);\r\n    }\r\n    return result;\r\n};", "import { XYZType } from '../../types';\r\nimport { IBaseBoard } from '../IBaseBoard';\r\nimport {\r\n    IChessData,\r\n    BlockerType, EdgeBlockerType\r\n} from './IChessData';\r\n\r\nexport class ChessData implements IChessData {\r\n    parent: any;\r\n    board: IBaseBoard | null;\r\n    blocker: BlockerType | EdgeBlockerType;\r\n\r\n    constructor(parent: any) {\r\n        this.parent = parent;\r\n        this.board = null;\r\n        this.blocker = false;\r\n        this.boot();\r\n    }\r\n\r\n    boot() {\r\n        if ((typeof (this.parent) === 'object') && this.parent.on) {\r\n            this.parent.on('destroy', this.destroy, this);\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        if (this.board) {\r\n            let tileXYZ = this.tileXYZ;\r\n            this.board.boardData.removeChess(tileXYZ.x, tileXYZ.y, tileXYZ.z);\r\n        }\r\n\r\n        this.parent = undefined;\r\n        this.board = null;\r\n    }\r\n\r\n    setBoard(board: IBaseBoard | null): this {\r\n\r\n        this.board = board;\r\n        return this;\r\n    }\r\n\r\n    get tileXYZ(): XYZType | null {\r\n        if (this.board == null) {\r\n            return null;\r\n        }\r\n        return this.board.boardData.getXYZ(this.parent);\r\n    }\r\n\r\n    setBlocker(value: boolean = true): this {\r\n\r\n        this.blocker = value;\r\n        return this;\r\n    }\r\n\r\n    setBlockEdge(\r\n        direction: number | object,\r\n        value: boolean = true\r\n    ): this {\r\n\r\n        if (typeof (this.blocker) === 'boolean') {\r\n            this.blocker = {};\r\n        }\r\n\r\n        let blocker = this.blocker;\r\n        if (typeof (direction) === 'object') {\r\n            let blockEdges = direction;\r\n            for (let dir in blockEdges) {\r\n                blocker[dir] = blockEdges[dir];\r\n            }\r\n        } else {\r\n            blocker[direction] = value;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    getBlockEdge(direction: number): boolean {\r\n\r\n        if (typeof (this.blocker) === 'boolean') {\r\n            return false;\r\n        }\r\n\r\n        if (!this.blocker.hasOwnProperty(direction)) {\r\n            return false;\r\n        } else {\r\n            return this.blocker[direction];\r\n        }\r\n    }\r\n}", "import { IChessData } from './IChessData';\r\nimport { ChessData } from './ChessData';\r\nimport { IChess } from '../../types';\r\n\r\nexport let GetChessData = function (\r\n    chess: IChess\r\n): IChessData {\r\n\r\n    if (!chess.hasOwnProperty('rexChess')) {\r\n        chess.rexChess = new ChessData(chess);\r\n    }\r\n    return chess.rexChess;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess } from '../../types';\r\n\r\n\r\nexport let GetAllChess = function (\r\n    board: IBaseBoard,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let chessToXYZ = board.boardData.chessToXYZ;\r\n    for (const [chess, xyz] of chessToXYZ) {\r\n        out.push(chess);\r\n    }\r\n    return out;\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, Vec2Type } from '../../types';\r\n\r\n\r\nexport let TileXYToWorldXY = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    out?: Vec2Type | true\r\n): Vec2Type {\r\n\r\n    return board.grid.getWorldXY(tileX, tileY, out);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XType, YType, XYZType } from '../../types';\r\nimport { GetAllChess } from '../chess/GetAllChess';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { TileXYToWorldXY } from './TileXYToWorldXY';\r\n\r\nexport let GridAlign = function (\r\n    board: IBaseBoard,\r\n    chess?: IChess,\r\n    tileX?: XType,\r\n    tileY?: YType\r\n): void {\r\n\r\n    if (chess === undefined) {\r\n        let chessArray = GetAllChess(board);\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            let chess = chessArray[i];\r\n            let tileXYZ = ChessToTileXYZ(board, chess) as XYZType;\r\n\r\n            TileXYToWorldXY(board, tileXYZ.x, tileXYZ.y, chess);\r\n        }\r\n    } else {\r\n        if (tileX === undefined) {\r\n            let tileXYZ = ChessToTileXYZ(board, chess) as XYZType;\r\n            tileX = tileXYZ.x;\r\n            tileY = tileXYZ.y;\r\n        }\r\n\r\n        TileXYToWorldXY(board, tileX, tileY, chess);\r\n    }\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XType, YType, ZType, XYZType } from '../../types';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { GetChessData } from '../chessdata/GetChessData';\r\n\r\n\r\nexport let RemoveChess = function (\r\n    board: IBaseBoard,\r\n    chess: IChess | null | undefined,\r\n    tileX?: XType,\r\n    tileY?: YType,\r\n    tileZ?: ZType,\r\n    destroy: boolean = false,\r\n    fromBoardRemove: boolean = false\r\n) {\r\n\r\n    if (chess) {\r\n        let tileXYZ = ChessToTileXYZ(board, chess) as XYZType;\r\n        if (tileXYZ) {\r\n            tileX = tileXYZ.x;\r\n            tileY = tileXYZ.y;\r\n            tileZ = tileXYZ.z;\r\n        } else {\r\n            // chess is not in this board\r\n            return;\r\n        }\r\n    } else {\r\n        chess = TileXYZToChess(board, tileX, tileY, tileZ);\r\n        if (!chess) {\r\n            // chess is not in this board\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (!fromBoardRemove) {\r\n        board.boardData.removeChess(tileX, tileY, tileZ);\r\n    }\r\n    if (board._isBoard) {\r\n        GetChessData(chess).setBoard(null);\r\n    }\r\n\r\n    if (destroy && chess.destroy) {\r\n        chess.destroy();\r\n    }\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XType, YType, ZType, XYZType } from '../../types';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { Contains } from '../tilexy/Contains';\r\nimport { GetChessData } from '../chessdata/GetChessData';\r\nimport { GridAlign } from '../worldxy/GridAlign';\r\nimport { RemoveChess } from './RemoveChess'\r\n\r\nexport let AddChess = function (\r\n    board: IBaseBoard,\r\n    chess: IChess,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ?: ZType,\r\n    align: boolean = true\r\n) {\r\n\r\n    if (!Contains(board, tileX, tileY)) {\r\n        return;\r\n    }\r\n\r\n    let curTileXYZ = ChessToTileXYZ(board, chess) as XYZType;\r\n    if (tileZ === undefined) {\r\n        if (curTileXYZ) {\r\n            tileZ = curTileXYZ.z;\r\n        } else {\r\n            tileZ = 0;\r\n        }\r\n    }\r\n\r\n    if (curTileXYZ &&\r\n        (curTileXYZ.x === tileX) && (curTileXYZ.y === tileY) && (curTileXYZ.z === tileZ)) {\r\n        // Move to current position\r\n        return;\r\n    }\r\n\r\n    let occupiedChess = TileXYZToChess(board, tileX, tileY, tileZ);\r\n    if (occupiedChess) {\r\n        // board.emit('kickout', occupiedChess, chess, curTileXYZ);\r\n        RemoveChess(board, null, tileX, tileY, tileZ); // Clear up (tileX, tileY, tileZ)\r\n    }\r\n\r\n    board.boardData.addChess(chess, tileX, tileY, tileZ);\r\n\r\n    if (board._isBoard) {\r\n        GetChessData(chess).setBoard(board);\r\n    }\r\n\r\n    if (align) {\r\n        GridAlign(board, chess, tileX, tileY);\r\n    }\r\n};", "export let Between = function (\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number\r\n): number {\r\n\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { TileXYToWorldXY } from './TileXYToWorldXY';\r\nimport { Between as GetAngle } from '../../../utils/math/angle/Between';\r\n\r\nexport let AngleBetween = function (\r\n    board: IBaseBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType\r\n): number {\r\n\r\n    let tileA = ChessToTileXYZ(board, chessA);\r\n    let tileB = ChessToTileXYZ(board, chessB);\r\n    let out = TileXYToWorldXY(board, tileA.x, tileA.y, true);\r\n    let x0 = out.x;\r\n    let y0 = out.y;\r\n    out = TileXYToWorldXY(board, tileB.x, tileB.y, true);\r\n    let x1 = out.x;\r\n    let y1 = out.y;\r\n    return GetAngle(x0, y0, x1, y1); // -PI~PI\r\n}", "export let Wrap = function (\r\n    value: number,\r\n    min: number,\r\n    max: number\r\n): number {\r\n\r\n    let range = max - min;\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, XYType } from '../../types';\r\nimport { Wrap } from '../../../utils/math/Wrap';\r\n\r\nexport let GetWrapTileXY = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if (board.wrapMode) {\r\n        tileX = Wrap(tileX, 0, board.width);\r\n    } else if ((!board.infinityMode) &&\r\n        ((tileX < 0) || (tileX >= board.width))) {\r\n        tileX = null;\r\n    }\r\n    if (board.wrapMode) {\r\n        tileY = Wrap(tileY, 0, board.height);\r\n    } else if ((!board.infinityMode) &&\r\n        ((tileY < 0) || (tileY >= board.height))) {\r\n        tileY = null;\r\n    }\r\n    out.x = tileX;\r\n    out.y = tileY;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { ChessToTileXYZ } from './ChessToTileXYZ';\r\nimport { GetWrapTileXY } from './GetWrapTileXY';\r\n\r\nexport type DistanceConfig = {\r\n    end?: number,\r\n    start?: number,\r\n    step?: number\r\n};\r\n\r\nexport let GetTileXYAtDirection = function (\r\n    board: IBaseBoard,\r\n    chess: IChess | XYType,\r\n    directions: number | number[] | string | null,\r\n    distance: number | number[] | DistanceConfig,\r\n    out?: XYType | XYType[] | true\r\n): XYType | XYType[] | null {\r\n\r\n    let srcTileXY = ChessToTileXYZ(board, chess);\r\n    if (srcTileXY === null) {\r\n        return null;\r\n    }\r\n\r\n    if (typeof (directions) === 'string') {\r\n        if (directions.indexOf(',') === -1) {\r\n            directions = parseInt(directions);\r\n        } else {\r\n            directions = directions.split('.').map((dir) => parseInt(dir, 10))\r\n        }\r\n    }\r\n\r\n    let isNumberDirection = (typeof (directions) === 'number');\r\n    let isNumberDistance = (typeof (distance) === 'number');\r\n    if (isNumberDirection && isNumberDistance) {\r\n        // Directions is a number, distance is a number, return a singl tileXY\r\n        let result = board.grid.getTileXYAtDirection(\r\n            srcTileXY,\r\n            directions as number,\r\n            distance as number,\r\n            out as XYType | true\r\n        ) as XYType;\r\n        GetWrapTileXY(board, result.x, result.y, result);\r\n        if ((result.x === null) || (result.y === null)) {\r\n            result = null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    if (!Array.isArray(out)) {\r\n        out = [];\r\n    }\r\n    if (directions === null) {\r\n        directions = board.grid.allDirections;\r\n    }\r\n\r\n    let resultTileXY: XYType;\r\n    if (isNumberDirection) {\r\n        // Directions is a number, distance is an object or array\r\n        if (Array.isArray(distance)) { // Distance is an array\r\n            for (let i = 0, cnt = distance.length; i < cnt; i++) {\r\n                resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, distance[i]) as XYType;\r\n                if (resultTileXY !== null) {\r\n                    out.push(resultTileXY);\r\n                }\r\n            }\r\n        } else {\r\n            let end: number,\r\n                start: number,\r\n                step: number;\r\n            ({\r\n                end = 1,\r\n                start = ((end > 0) ? 1 : -1),\r\n                step = ((end >= start) ? 1 : -1)\r\n            } = distance as DistanceConfig);\r\n\r\n            if (start === end) {\r\n                resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, end) as XYType; // Return a single tileXY\r\n                if (resultTileXY !== null) {\r\n                    out.push(resultTileXY);\r\n                }\r\n            } else if (start < end) {\r\n                for (let i = start; i <= end; i += step) {\r\n                    resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, i) as XYType; // return a single tileXY\r\n                    if (resultTileXY !== null) {\r\n                        out.push(resultTileXY);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = start; i >= end; i += step) {\r\n                    resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, i) as XYType; // Return a single tileXY\r\n                    if (resultTileXY !== null) {\r\n                        out.push(resultTileXY);\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    } else { // Directions is a list\r\n        for (let i = 0, cnt = (directions as number[]).length; i < cnt; i++) {\r\n            if (isNumberDistance) { // Return a single tileXY\r\n                resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions[i], distance) as XYType;\r\n                if (resultTileXY !== null) {\r\n                    out.push(resultTileXY);\r\n                }\r\n            } else { // Append an array of tileXY\r\n                GetTileXYAtDirection(board, srcTileXY, directions[i], distance, out);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { GetTileXYAtDirection } from '../tilexy/GetTileXYAtDirection';\r\n\r\nexport let GetNeighborTileXY = function (\r\n    board: IBaseBoard,\r\n    srcTileXY: XYType,\r\n    directions: number | number[] | string | null = null,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType | XYType[] | null {\r\n\r\n    return GetTileXYAtDirection(board, srcTileXY, directions, 1, out);\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { GetNeighborTileXY } from '../neighbors/GetNeighborTileXY';\r\nimport { AngleBetween } from './AngleBetween';\r\n\r\nexport let AngleToward = function (\r\n    board: IBaseBoard,\r\n    tileXY: XYType,\r\n    direction: number\r\n): number {\r\n\r\n    if (tileXY === undefined) {\r\n        tileXY = zeroTileXY;\r\n    }\r\n    // Save wrapMode, infinityMode and clear them\r\n    let wrapModeSave = board.wrapMode;\r\n    let infinityModeSave = board.infinityMode;\r\n    board.wrapMode = false;\r\n    board.infinityMode = true;\r\n\r\n    // Get neighborTileXY\r\n    let neighborTileXY = GetNeighborTileXY(board, tileXY, direction, true) as XYType;\r\n\r\n    // Restore wrapMode, infinityMode and clear them\r\n    board.wrapMode = wrapModeSave;\r\n    board.infinityMode = infinityModeSave;\r\n    return AngleBetween(board, tileXY, neighborTileXY); // -PI~PI\r\n}\r\n\r\nlet zeroTileXY: XYType = { x: 0, y: 0 };", "const RAD_TO_DEG = 180 / Math.PI;\r\n\r\nexport let RadToDeg = function (radians: number): number {\r\n\r\n    return radians * RAD_TO_DEG;\r\n};\r\n", "export let ShortestBetween = function (\r\n    angle1: number,\r\n    angle2: number\r\n): number {\r\n\r\n    let difference = angle2 - angle1;\r\n    if (difference === 0) {\r\n        return 0;\r\n    }\r\n\r\n    let times = Math.floor((difference - (-180)) / 360);\r\n    return difference - (times * 360);\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { AngleToward } from './AngleToward';\r\nimport { RadToDeg } from '../../../utils/math/angle/RadToDeg';\r\nimport { ShortestBetween } from '../../../utils/math/angle/ShortestBetween';\r\n\r\nexport let AngleSnapToDirection = function (\r\n    board: IBaseBoard,\r\n    tileXY: XYType,\r\n    angle: number\r\n): number {\r\n\r\n    angle = RadToDeg(angle); // -180~180\r\n    let directions = board.grid.allDirections;\r\n    let minDeltaAngle = Infinity,\r\n        direction = undefined;\r\n    for (let i = 0, cnt = directions.length; i < cnt; i++) {\r\n        let neighborAngle = RadToDeg(AngleToward(board, tileXY, directions[i])); // -PI~PI -> -180~180\r\n        let deltaAngle = Math.abs(ShortestBetween(angle, neighborAngle));\r\n        if (deltaAngle < minDeltaAngle) {\r\n            minDeltaAngle = deltaAngle;\r\n            direction = i;\r\n        }\r\n    }\r\n\r\n    return direction;\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { GetNeighborTileXY } from './GetNeighborTileXY'\r\n\r\nexport let GetNeighborTileDirection = function (\r\n    board: IBaseBoard,\r\n    srcTileXY: XYType | null,\r\n    neighborTileXY: XYType | null\r\n): number | null {\r\n\r\n    if ((srcTileXY === null) || (neighborTileXY === null)) {\r\n        return null;\r\n    }\r\n    if ((srcTileXY.x === neighborTileXY.x) && (srcTileXY.y === neighborTileXY.y)) {\r\n        return null\r\n    }\r\n\r\n    let direction = board.grid.getNeighborTileDirection(srcTileXY, neighborTileXY);\r\n    if (board.wrapMode && (direction === null)) {\r\n        let tileXYArray = GetNeighborTileXY(board, srcTileXY, null) as XYType[];\r\n        for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n            let tileXY = tileXYArray[i];\r\n            if ((neighborTileXY.x === tileXY.x) && (neighborTileXY.y === tileXY.y)) {\r\n                direction = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return direction;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { GetNeighborTileDirection } from './GetNeighborTileDirection'\r\n\r\nexport let GetNeighborChessDirection = function (\r\n    board: IBaseBoard,\r\n    chess: IChess | XYType,\r\n    neighborChess: IChess | XYType\r\n): number {\r\n\r\n    let srcTileXYZ = ChessToTileXYZ(board, chess);\r\n    let neighborTileXYZ = ChessToTileXYZ(board, neighborChess);\r\n    return GetNeighborTileDirection(board, srcTileXYZ, neighborTileXYZ);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { GetNeighborChessDirection } from './GetNeighborChessDirection'\r\n\r\nexport let AreNeighbors = function (\r\n    board: IBaseBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType\r\n): boolean {\r\n\r\n    return (GetNeighborChessDirection(board, chessA, chessB) !== null);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { ChessToTileXYZ } from './ChessToTileXYZ'\r\n\r\nexport let DirectionBetween = function (\r\n    board: IBaseBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType,\r\n    round: boolean = true\r\n): number | null {\r\n\r\n    let tileA = ChessToTileXYZ(board, chessA);\r\n    let tileB = ChessToTileXYZ(board, chessB);\r\n    if ((tileA === null) || (tileB === null)) {\r\n        return null;\r\n    }\r\n\r\n    return board.grid.directionBetween(tileA, tileB, round);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { Contains } from '../tilexy/Contains';\r\n\r\nexport let RingToTileXYArray = function (\r\n    board: IBaseBoard,\r\n    centerTileXY: XYType,\r\n    radius: number = 1,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let tileArray = board.grid.ringToTileXYArray(centerTileXY, radius) as XYType[];\r\n    for (let i = 0, cnt = tileArray.length; i < cnt; i++) {\r\n        let tileXY = tileArray[i];\r\n        if (Contains(board, tileXY.x, tileXY.y)) {\r\n            out.push(tileXY);\r\n        }\r\n    }\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { RingToTileXYArray } from './RingToTileXYArray'\r\n\r\nexport let FilledRingToTileXYArray = function (\r\n    board: IBaseBoard,\r\n    centerTileXY: XYType,\r\n    radius: number,\r\n    nearToFar: boolean = true,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    for (let i = 0; i <= radius; i++) {\r\n        let level = (nearToFar) ? i : (radius - i);\r\n        RingToTileXYArray(board, centerTileXY, level, out);\r\n    }\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\n\r\n\r\nexport let Offset = function (\r\n    board: IBaseBoard,\r\n    tileXY: XYType,\r\n    offsetTileX: number,\r\n    offsetTileY: number,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if ((offsetTileX === 0) && (offsetTileY === 0)) {\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n    } else {\r\n        board.grid.offset(tileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };", "// Offset tileXYArray to (0,0), and set board size to fit tileXYArray\r\nimport { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { Offset } from './Offset';\r\nimport { SetBoardHeight } from '../boarddata/SetBoardHeight';\r\nimport { SetBoardWidth } from '../boarddata/SetBoardWidth';\r\n\r\nexport let Fit = function (\r\n    board: IBaseBoard,\r\n    tileXYArray: XYType[]\r\n): XYType[] {\r\n\r\n    // Get minimum tileX, tileY\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let tileXY: XYType;\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        tileXY = tileXYArray[i];\r\n        minX = Math.min(minX, tileXY.x);\r\n        minY = Math.min(minY, tileXY.y);\r\n    }\r\n    // Offset tileXYArray to (0,0)\r\n    if ((minX !== 0) || (minY !== 0)) {\r\n        for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n            tileXY = tileXYArray[i];\r\n            Offset(board, tileXY, -minX, -minY, tileXY);\r\n        }\r\n    }\r\n\r\n    // Get maximun tileX, tileY\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        tileXY = tileXYArray[i];\r\n        maxX = Math.max(maxX, tileXY.x);\r\n        maxY = Math.max(maxY, tileXY.y);\r\n    }\r\n\r\n    // Set board size\r\n    SetBoardWidth(board, maxX + 1);\r\n    SetBoardHeight(board, maxY + 1);\r\n\r\n    return tileXYArray;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\n\r\nexport type ForEachTileXYCallback = (tileXY: XYType, board: IBaseBoard) => void;\r\nexport enum ForEachTileXYOrder {\r\n    'x+,y+' = 0,\r\n    'x-,y+' = 1,\r\n    'y+,x+' = 2,\r\n    'y-,x+' = 3\r\n}\r\n\r\nexport let ForEachTileXY = function (\r\n    board: IBaseBoard,\r\n    callback: ForEachTileXYCallback,\r\n    scope?: any,\r\n    order: ForEachTileXYOrder = ForEachTileXYOrder['x+,y+']\r\n): void {\r\n\r\n    let tileXY: XYType = { x: 0, y: 0 };\r\n    switch (order) {\r\n        case ForEachTileXYOrder['x+,y+']:\r\n            for (let tileY = 0; tileY < board.height; tileY++) {\r\n                for (let tileX = 0; tileX < board.width; tileX++) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case ForEachTileXYOrder['x-,y+']:\r\n            for (let tileY = 0; tileY < board.height; tileY++) {\r\n                for (let tileX = board.width - 1; tileX >= 0; tileX--) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case ForEachTileXYOrder['y+,x+']:\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                for (let tileY = 0; tileY < board.height; tileY++) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case ForEachTileXYOrder['y-,x+']:\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                for (let tileY = board.height - 1; tileY >= 0; tileY--) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n    }\r\n\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\n\r\nexport let GetDistance = function (\r\n    board: IBaseBoard,\r\n    tileA: XYType,\r\n    tileB: XYType,\r\n    roughMode?: boolean\r\n): number {\r\n\r\n    return board.grid.getDistance(tileA, tileB, roughMode);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { ZType, XYType } from '../../types';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\n\r\nexport let GetEmptyTileXYArray = function (\r\n    board: IBaseBoard,\r\n    tileZ: ZType | ZType[] = 0,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    if (!Array.isArray(tileZ)) {\r\n        for (let tileY = 0; tileY < board.height; tileY++) {\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                if (TileXYZToChess(board, tileX, tileY, tileZ) === null) {\r\n                    out.push({\r\n                        x: tileX,\r\n                        y: tileY\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        let tileZArray = tileZ;\r\n        for (let tileY = 0; tileY < board.height; tileY++) {\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                let isEmpty = true;\r\n                for (let k = 0, kcnt = tileZArray.length; k < kcnt; k++) {\r\n                    if (TileXYZToChess(board, tileX, tileY, tileZArray[k]) !== null) {\r\n                        isEmpty = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isEmpty) {\r\n                    out.push({\r\n                        x: tileX,\r\n                        y: tileY\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { Vec2Type } from '../../types';\r\n\r\n\r\nexport let GetGridPoints = function (\r\n    board: IBaseBoard,\r\n    tileX?: number | Vec2Type,\r\n    tileY?: number,\r\n    out?: Vec2Type[] | true\r\n): Vec2Type[] {\r\n\r\n    return board.grid.getGridPoints(tileX, tileY, out);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, IChess, ZMapType } from '../../types';\r\n\r\nexport let TileXYToChessArray = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let zMap = board.boardData.getChess(tileX, tileY) as ZMapType;\r\n    for (const [tileZ, chess] of zMap) {\r\n        out.push(chess);\r\n    }\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { ZType, XYType, IChess } from '../../types';\r\nimport { TileXYZToChess } from './TileXYZToChess';\r\nimport { TileXYToChessArray } from './TileXYToChessArray';\r\n\r\n\r\nexport let TileXYArrayToChessArray = function (\r\n    board: IBaseBoard,\r\n    tileXYArray: XYType[],\r\n    tileZ?: ZType,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let tileZMode = (tileZ != null);\r\n    let tileXY: XYType,\r\n        chess: IChess;\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        tileXY = tileXYArray[i];\r\n        if (tileZMode) {\r\n            chess = TileXYZToChess(board, tileXY.x, tileXY.y, tileZ as ZType);\r\n            if (chess !== null) {\r\n                out.push(chess);\r\n            }\r\n        } else {\r\n            TileXYToChessArray(board, tileXY.x, tileXY.y, out);\r\n        }\r\n    }\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType, XYZType, ZType } from '../../types';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { TileXYArrayToChessArray } from '../tilexy/TileXYArrayToChessArray';\r\nimport { TileXYToChessArray } from '../tilexy/TileXYToChessArray';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { GetNeighborTileXY } from './GetNeighborTileXY';\r\n\r\nexport let GetNeighborChess = function (\r\n    board: IBaseBoard,\r\n    chess: IChess | XYType,\r\n    directions: number | number[] | string | null,\r\n    neighborTileZ?: ZType | null,\r\n    out?: IChess[]\r\n): IChess | IChess[] | null {\r\n\r\n    let tileXYZ = ChessToTileXYZ(board, chess);\r\n    if (tileXYZ === null) { // chess is not on board\r\n        return null;\r\n    }\r\n\r\n    if (neighborTileZ == null) {\r\n        neighborTileZ = (tileXYZ.hasOwnProperty('z')) ? (tileXYZ as XYZType).z : null;\r\n    }\r\n\r\n    let neighborTileXY = GetNeighborTileXY(board, tileXYZ, directions, true);\r\n    if (neighborTileXY === null) {\r\n        return null;\r\n    } else if (Array.isArray(neighborTileXY)) { // NeighborTileXY array -> chess array\r\n        if (out === undefined) {\r\n            out = [];\r\n        }\r\n        return TileXYArrayToChessArray(board, neighborTileXY, neighborTileZ, out);\r\n    } else { // Single neighborTileXY -> single chess if tileZ, chess array if no tileZ\r\n        if (neighborTileZ == null) {\r\n            if (out === undefined) {\r\n                out = [];\r\n            }\r\n            return TileXYToChessArray(board, neighborTileXY.x, neighborTileXY.y, out);\r\n        } else {\r\n            return TileXYZToChess(board, neighborTileXY.x, neighborTileXY.y, neighborTileZ);\r\n        }\r\n    }\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { AngleSnapToDirection } from '../worldxy/AngleSnapToDirection';\r\nimport { GetTileXYAtDirection } from '../tilexy/GetTileXYAtDirection';\r\n\r\nexport let GetNeighborTileXYAtAngle = function (\r\n    board: IBaseBoard,\r\n    srcTileXY: XYType,\r\n    angle: number,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType | null {\r\n\r\n    let direction = AngleSnapToDirection(board, srcTileXY, angle);\r\n    return GetTileXYAtDirection(board, srcTileXY, direction, 1, out) as XYType;\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType } from '../../types';\r\n\r\nexport let GetOppositeDirection = function (\r\n    baord: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    direction: number\r\n): number {\r\n\r\n    return baord.grid.getOppositeDirection(tileX, tileY, direction);\r\n}", "export let RandomInt = function (min: number, max: number): number {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n};", "export let GetRandomItem = function (\r\n    array: any[] | string,\r\n    startIndex: number = 0,\r\n    length: number = array.length\r\n) {\r\n\r\n    let randomIndex = startIndex + Math.floor(Math.random() * length);\r\n    return (array[randomIndex] === undefined) ? null : array[randomIndex];\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, ZType, XYType } from '../../types';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { GetEmptyTileXYArray } from './GetEmptyTileXYArray';\r\nimport { RandomInt } from '../../../utils/math/RandomInt';\r\nimport { GetRandomItem } from '../../../utils/array/GetRandom';\r\n\r\nexport let GetRandomEmptyTileXY = function (\r\n    board: IBaseBoard,\r\n    tileZ: ZType = 0,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType | null {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    // Random picking a tileXY\r\n    let retryCount = Math.floor(board.width * board.height * 0.3);\r\n    for (let i = 0; i < retryCount; i++) {\r\n        let tileX = RandomInt(0, board.width - 1) as XType;\r\n        let tileY = RandomInt(0, board.height - 1) as YType;\r\n        if (TileXYZToChess(board, tileX, tileY, tileZ) === null) {\r\n            out.x = tileX;\r\n            out.y = tileY;\r\n            return out;\r\n        }\r\n    }\r\n\r\n    // Not found any empty tileXY\r\n    // Get all empty tileXY\r\n    let tileXYArray = GetEmptyTileXYArray(board, tileZ);\r\n    if (tileXYArray.length === 0) {\r\n        return null;\r\n    } else {\r\n        let tileXY: XYType = GetRandomItem(tileXYArray);\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n        return out;\r\n    }\r\n}\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, ZType } from '../../types';\r\nimport { TileXYToChessArray } from '../tilexy/TileXYToChessArray';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { GetChessData } from '../chessdata/GetChessData';\r\n\r\nexport let HasBlocker = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ?: ZType\r\n): boolean {\r\n\r\n    if (tileZ === undefined) {\r\n        // any chess at (tileX, tileY) has blocker\r\n        let chessArray = TileXYToChessArray(board, tileX, tileY);\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            let blocker = GetChessData(chessArray[i]).blocker;\r\n            if (blocker === true) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n\r\n    } else {\r\n        // chess at (tileX, tileY, tileZ) has blocker\r\n        let chess = TileXYZToChess(board, tileX, tileY, tileZ);\r\n        if (chess === null) {\r\n            return false;\r\n        }\r\n        let blocker = GetChessData(chess).blocker;\r\n        return (blocker === true);\r\n\r\n    }\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess } from '../../types';\r\n\r\nexport let HasChess = function (\r\n    board: IBaseBoard,\r\n    chess: IChess\r\n): boolean {\r\n\r\n    return board.boardData.chessToXYZ.has(chess);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XType, YType, ZType } from '../../types';\r\nimport { EdgeBlockerType } from '../chessdata/IChessData';\r\nimport { TileXYToChessArray } from '../tilexy/TileXYToChessArray';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { GetChessData } from '../chessdata/GetChessData';\r\n\r\nexport let HasEdgeBlocker = function (\r\n    board: IBaseBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ: ZType | undefined,\r\n    direction: number\r\n): boolean {\r\n\r\n    if (tileZ === undefined) {\r\n        // any chess at (tileX, tileY) has blocker\r\n        let chessArray = TileXYToChessArray(board, tileX, tileY);\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            if (IsEdgeBlocker(GetChessData(chessArray[i]).blocker, direction)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n\r\n    } else {\r\n        // chess at (tileX, tileY, tileZ) has blocker\r\n        let chess = TileXYZToChess(board, tileX, tileY, tileZ);\r\n        if (chess === null) {\r\n            return false;\r\n        }\r\n        return IsEdgeBlocker(GetChessData(chess).blocker, direction);\r\n    }\r\n}\r\n\r\nlet IsEdgeBlocker = function (\r\n    blocker: EdgeBlockerType | boolean,\r\n    direction: number\r\n): boolean {\r\n\r\n    if ((blocker === false) || (blocker === true)) {\r\n        return blocker;\r\n    } else {\r\n        return (blocker[direction] === true);\r\n    }\r\n}", "export let Normalize = function (angle: number): number {\r\n    angle = angle % PI2;\r\n\r\n    if (angle >= 0) {\r\n        return angle;\r\n    }\r\n    else {\r\n        return angle + PI2;\r\n    }\r\n};\r\n\r\nconst PI2 = Math.PI * 2;\r\n", "export let Equal = function (\r\n    a: number,\r\n    b: number,\r\n    epsilon: number = 0.0001\r\n): boolean {\r\n\r\n    return Math.abs(a - b) < epsilon;\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { AngleBetween } from './AngleBetween';\r\nimport { Normalize as AngleNormalize } from '../../../utils/math/angle/Normalize';\r\nimport { Equal } from '../../../utils/math/fuzzy/Equal';\r\n\r\nexport let IsAngleInCone = function (\r\n    board: IBaseBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType,\r\n    face: number,\r\n    cone: number\r\n): boolean {\r\n\r\n    let tileXYA = ChessToTileXYZ(board, chessA);\r\n    let tileXYB = ChessToTileXYZ(board, chessB);\r\n    let targetAngle = AngleBetween(board, tileXYA, tileXYB); // -PI~PI\r\n    targetAngle = AngleNormalize(targetAngle); // 0~2PI\r\n    let deltaAngle = Math.abs(targetAngle - face);\r\n    deltaAngle = Math.min(deltaAngle, PI2 - deltaAngle);\r\n    let halfCone = cone / 2;\r\n    return Equal(deltaAngle, halfCone) || (deltaAngle < halfCone);\r\n}\r\n\r\nconst PI2 = Math.PI * 2;", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYType } from '../../types';\r\nimport { ChessToTileXYZ } from './ChessToTileXYZ'\r\n\r\nexport let IsDirectionInCone = function (\r\n    board: IBaseBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType,\r\n    face: number,\r\n    cone: number\r\n): boolean {\r\n\r\n    let tileXYA = ChessToTileXYZ(board, chessA);\r\n    let tileXYB = ChessToTileXYZ(board, chessB);\r\n\r\n    let savedDirections = board.grid.directions; // Save directions\r\n    board.grid.directions = board.grid.sides;\r\n    let direction = board.grid.directionBetween(tileXYA, tileXYB, false);\r\n    board.grid.directions = savedDirections; // Restore directions\r\n\r\n    let deltaDirection = Math.abs(direction - face);\r\n    deltaDirection = Math.min(deltaDirection, board.grid.directions - deltaDirection);\r\n    return (deltaDirection <= (cone / 2));\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\n\r\n\r\nexport let WorldXYToTileXY = function (\r\n    board: IBaseBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    return board.grid.getTileXY(worldX, worldY, out);\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { ZType } from '../../types';\r\nimport { WorldXYToTileXY } from './WorldXYToTileXY';\r\nimport { Contains } from '../tilexy/Contains'\r\n\r\n\r\nexport let IsOverlappingPoint = function (\r\n    board: IBaseBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    tileZ?: ZType\r\n): boolean {\r\n\r\n    if (board.infinityMode && (tileZ === undefined)) {\r\n        return true;\r\n    }\r\n\r\n    let out = WorldXYToTileXY(board, worldX, worldY, true);\r\n    return Contains(board, out.x, out.y, tileZ);\r\n}", "export let DistanceBetween = function (\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number\r\n): number {\r\n\r\n    let dx = x1 - x2;\r\n    let dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};", "export let Linear = function (\r\n    p0: number,\r\n    p1: number,\r\n    t: number\r\n): number {\r\n\r\n    return (p1 - p0) * t + p0;\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { WorldXYToTileXY } from '../worldxy/WorldXYToTileXY';\r\nimport { Contains } from '../tilexy/Contains';\r\nimport { XYType } from '../../types';\r\nimport { DistanceBetween } from '../../../utils/math/distance/DistanceBetween';\r\nimport { Linear } from '../../../utils/math/Linear';\r\n\r\nexport let LineToTileXYArray = function (\r\n    board: IBaseBoard,\r\n    startX: number,\r\n    startY: number,\r\n    endX: number,\r\n    endY: number,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let totalDistance = DistanceBetween(startX, startY, endX, endY);\r\n    let gridSize = Math.min(board.grid.width, board.grid.height);\r\n    let quantity = Math.ceil(totalDistance / (gridSize / 4));\r\n    let preTileXY: XYType;\r\n    for (let i = 0; i <= quantity; i++) {\r\n        let t = i / quantity;\r\n        let worldX = Linear(startX, endX, t);\r\n        let worldY = Linear(startY as number, endY, t);\r\n        let tileXY = WorldXYToTileXY(board, worldX, worldY);\r\n\r\n        if (!Contains(board, tileXY.x, tileXY.y)) {\r\n            continue;\r\n        }\r\n\r\n        if (preTileXY &&\r\n            (preTileXY.x === tileXY.x) && (preTileXY.y === tileXY.y)) {\r\n            continue;\r\n        }\r\n\r\n        out.push(tileXY);\r\n        preTileXY = tileXY;\r\n    }\r\n    return out;\r\n}", "export interface Vec2Type {\r\n    x: number,\r\n    y: number\r\n};\r\n\r\nexport interface Vec3Type {\r\n    x: number,\r\n    y: number,\r\n    z: number\r\n}", "import { Vec2Type } from '../utils/types/VectorType';\r\nimport { IChessData } from './board/chessdata/IChessData';\r\n\r\nexport type XType = number;\r\nexport type YType = number;\r\nexport type ZType = number | string;\r\nexport type AnyKeyType = XType | YType | ZType;\r\nexport type XYType = {\r\n    x: XType,\r\n    y: YType\r\n}\r\nexport type XYZType = {\r\n    x: XType,\r\n    y: YType,\r\n    z: ZType\r\n}\r\nexport { Vec2Type };\r\nexport interface IChess {\r\n    rexChess?: IChessData;\r\n    x: number,\r\n    y: number,\r\n    destroy?: () => any;\r\n};\r\nexport type ChessSetType = Set<IChess>;\r\nexport type ZMapType = Map<ZType, IChess>;", "import { Vec2Type } from '../types';\r\nexport { Vec2Type };\r\n\r\nexport interface IGrid {\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number\r\n\r\n    mode: number;\r\n    directions: number;\r\n    readonly sides: number;\r\n    readonly allDirections: number[];\r\n    readonly halfDirections: number[];\r\n\r\n    _savedOriginX: number;\r\n    _savedOriginY: number;\r\n\r\n    directionBetween(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        round?: boolean\r\n    ): number;\r\n\r\n    directionNormalize(\r\n        direction: number\r\n    ): number;\r\n\r\n    getDistance(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        roughMode?: boolean\r\n    ): number;\r\n\r\n    getGridPoints(\r\n        tileX?: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type[] | true\r\n    ): Vec2Type[];\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: Vec2Type,\r\n        neighborTileXY: Vec2Type\r\n    ): number | null;\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    getOppositeDirection(\r\n        tileX: number | Vec2Type,\r\n        tileY: number | undefined | null,\r\n        direction: number\r\n    ): number;\r\n\r\n    getTileXY(\r\n        worldX: number | Vec2Type,\r\n        worldY?: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    getTileXYAtDirection(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        distance: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    getWorldXY(\r\n        tileX: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    mirror(\r\n        srcTileXY: Vec2Type,\r\n        mode: MirrorMode | MirrorModeString,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    offset(\r\n        srcTileXY: Vec2Type,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    restoreOrigin(): this;\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: Vec2Type,\r\n        radius: number,\r\n        out?: Vec2Type[]\r\n    ): Vec2Type[];\r\n\r\n    rotate(\r\n        srcTileXY: Vec2Type,\r\n        dir: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type\r\n\r\n    saveOrigin(): this;\r\n\r\n    setDirectionMode(\r\n        mode: number\r\n    ): this;\r\n}\r\n\r\nexport enum MirrorMode {\r\n    x = 1,\r\n    horizontal = 1,\r\n    h = 1,\r\n    y = 2,\r\n    vertical = 2,\r\n    v = 2,\r\n    xy = 3,\r\n}\r\n\r\nexport type MirrorModeString = 'x' | 'y' | 'xy' | 'vertical' | 'horizontal' | 'v' | 'h';", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { MirrorMode, MirrorModeString } from '../../grid/IGrid';\r\nimport { Offset } from './Offset';\r\n\r\nexport { MirrorMode, MirrorModeString };\r\n\r\nexport let Mirror = function (\r\n    board: IBaseBoard,\r\n    tileXY: XYType,\r\n    mode: MirrorMode | MirrorModeString,\r\n    originTileXY: XYType | null = null,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if (originTileXY !== null) {\r\n        Offset(board, tileXY, -originTileXY.x, -originTileXY.y, out);\r\n    } else {\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n    }\r\n    board.grid.mirror(out, mode, out);\r\n    if (originTileXY !== null) {\r\n        Offset(board, out, originTileXY.x, originTileXY.y, out);\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { GetAllChess } from './GetAllChess';\r\nimport { RemoveChess } from './RemoveChess';\r\n\r\nexport let RemoveAllChess = function (\r\n    board: IBaseBoard,\r\n    destroy: boolean = false,\r\n    fromBoardRemove: boolean = false\r\n): void {\r\n\r\n    let chessArray = GetAllChess(board);\r\n    for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n        RemoveChess(board, chessArray[i], undefined, undefined, undefined, destroy, fromBoardRemove);\r\n    }\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType } from '../../types';\r\nimport { Offset } from './Offset';\r\n\r\nexport let Rotate = function (\r\n    board: IBaseBoard,\r\n    tileXY: XYType,\r\n    direction: number,\r\n    originTileXY: XYType | null = null,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if (originTileXY !== null) {\r\n        Offset(board, tileXY, -originTileXY.x, -originTileXY.y, out);\r\n    } else {\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n    }\r\n    board.grid.rotate(out, direction, out);\r\n    if (originTileXY !== null) {\r\n        Offset(board, out, originTileXY.x, originTileXY.y, out);\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, ZType, XType, YType } from '../../types';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { AddChess } from './AddChess';\r\n\r\nexport let SetTileZ = function (\r\n    board: IBaseBoard,\r\n    chess: IChess,\r\n    tileZ: ZType\r\n): void {\r\n\r\n    let srcTileXYZ = ChessToTileXYZ(board, chess);\r\n    if (srcTileXYZ === null) {\r\n        return;\r\n    }\r\n\r\n    AddChess(board, chess, srcTileXYZ.x, srcTileXYZ.y, tileZ);\r\n}", "export interface BoundsType {\r\n    left: number,\r\n    right: number,\r\n    top: number,\r\n    bottom: number\r\n}", "export let Clamp = function (\r\n    value: number,\r\n    min: number,\r\n    max: number\r\n): number {\r\n\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { BoundsType as ShapeType } from '../../../utils/types/BoundsType';\r\nimport { XYType } from '../../types';\r\nimport { WorldXYToTileXY } from '../worldxy/WorldXYToTileXY';\r\nimport { TileXYToWorldXY } from '../worldxy/TileXYToWorldXY';\r\nimport { Clamp } from '../../../utils/math/Clamp';\r\n\r\nexport { ShapeType };\r\nexport type ContainsCallbackType = (shape: ShapeType, x: number, y: number) => boolean\r\n\r\nexport let ShapeToTileXYArray = function (\r\n    board: IBaseBoard,\r\n    shape: ShapeType,\r\n    containsCallback: ContainsCallbackType,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let topLeftTileXY = WorldXYToTileXY(board, shape.left, shape.top, true);\r\n    let left = topLeftTileXY.x - 1,\r\n        top = topLeftTileXY.y - 1;\r\n    let bottomRightTileXY = WorldXYToTileXY(board, shape.right, shape.bottom, true);\r\n    let right = bottomRightTileXY.x + 1,\r\n        bottom = bottomRightTileXY.y + 1;\r\n    if (!board.infinityMode) {\r\n        left = Clamp(left, 0, board.width - 1);\r\n        top = Clamp(top, 0, board.height - 1);\r\n        right = Clamp(right, 0, board.width - 1);\r\n        bottom = Clamp(bottom, 0, board.height - 1);\r\n    }\r\n\r\n    for (let x = left; x <= right; x++) {\r\n        for (let y = top; y <= bottom; y++) {\r\n            let targetWorldXY = TileXYToWorldXY(board, x, y, true);\r\n            if (containsCallback(shape, targetWorldXY.x, targetWorldXY.y)) {\r\n                out.push({ x: x, y: y });\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { IChess, XYZType } from '../../types';\r\nimport { ChessToTileXYZ } from '../tilexy/ChessToTileXYZ';\r\nimport { RemoveChess } from './RemoveChess';\r\nimport { AddChess } from './AddChess';\r\n\r\n\r\nexport let SwapChess = function (\r\n    board: IBaseBoard,\r\n    chessA: IChess,\r\n    chessB: IChess,\r\n    align: boolean = true\r\n): void {\r\n\r\n    let tileXYZA = ChessToTileXYZ(board, chessA) as XYZType;\r\n    let tileXYZB = ChessToTileXYZ(board, chessB) as XYZType;\r\n    if ((tileXYZA == null) || (tileXYZB == null)) {\r\n        return;\r\n    }\r\n    RemoveChess(board, chessA);\r\n    RemoveChess(board, chessB);\r\n    AddChess(board, chessA, tileXYZB.x, tileXYZB.y, tileXYZB.z, align);\r\n    AddChess(board, chessB, tileXYZA.x, tileXYZA.y, tileXYZA.z, align);\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { ZType, IChess } from '../../types';\r\n\r\nexport let TileZToChessArray = function (\r\n    board: IBaseBoard,\r\n    tileZ: ZType,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let chessSet = board.boardData.ZToChessSet.get(tileZ);\r\n    if (chessSet) {\r\n        for (const chess of chessSet) {\r\n            out.push(chess);\r\n        }\r\n    }\r\n    return out;\r\n}", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { XYType, Vec2Type } from '../../types';\r\nimport { TileXYToWorldXY } from './TileXYToWorldXY';\r\n\r\nexport let TileXYArrayToWorldXYArray = function (\r\n    board: IBaseBoard,\r\n    tileXYArray: XYType[],\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        let tileXY = tileXYArray[i];\r\n        out.push(TileXYToWorldXY(board, tileXY.x, tileXY.y));\r\n    }\r\n    return out;\r\n};", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { Vec2Type } from '../../types';\r\nimport { WorldXYToTileXY } from './WorldXYToTileXY';\r\nimport { TileXYToWorldXY } from './TileXYToWorldXY';\r\n\r\nexport let WorldXYSnapToGrid = function (\r\n    board: IBaseBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globWorldXY;\r\n    }\r\n\r\n    WorldXYToTileXY(board, worldX, worldY, out);\r\n    TileXYToWorldXY(board, out.x, out.y, out);\r\n    return out;\r\n};\r\n\r\nlet globWorldXY: Vec2Type = { x: 0, y: 0 };", "import { IBaseBoard } from '../IBaseBoard';\r\nimport { ZType, IChess } from '../../types';\r\nimport { WorldXYToTileXY } from './WorldXYToTileXY';\r\nimport { TileXYZToChess } from '../tilexy/TileXYZToChess';\r\nimport { TileXYToChessArray } from '../tilexy/TileXYToChessArray';\r\n\r\nexport let WorldXYToChess = function (\r\n    board: IBaseBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    tileZ?: ZType,\r\n    out?: IChess[]\r\n): IChess | IChess[] {\r\n\r\n    let tileXY = WorldXYToTileXY(board, worldX, worldY, true);\r\n    if (tileZ !== undefined) {\r\n        return TileXYZToChess(board, tileXY.x, tileXY.y, tileZ)\r\n    } else {\r\n        return TileXYToChessArray(board, tileXY.x, tileXY.y, out);\r\n    }\r\n}", "import { BaseBoard } from './BaseBoard';\r\nimport { XType, YType, ZType, XYType, XYZType, Vec2Type, IChess } from '../types';\r\nimport { ILogicBoard, IChessData } from './ILogicBoard';\r\n\r\nimport { AddChess } from './chess/AddChess';\r\nimport { AngleBetween } from './worldxy/AngleBetween';\r\nimport { AngleSnapToDirection } from './worldxy/AngleSnapToDirection';\r\nimport { AngleToward } from './worldxy/AngleToward';\r\nimport { AreNeighbors } from './neighbors/AreNeighbors';\r\nimport { ChessToTileXYZ } from './tilexy/ChessToTileXYZ';\r\nimport { Contains } from './tilexy/Contains';\r\nimport { DirectionBetween } from './tilexy/DirectionBetween';\r\nimport { FilledRingToTileXYArray } from './ring/FilledRingToTileXYArray';\r\nimport { Fit } from './transform/Fit';\r\nimport { ForEachTileXY, ForEachTileXYCallback, ForEachTileXYOrder } from './tilexy/ForEachTileXY';\r\nimport { GetAllChess } from './chess/GetAllChess';\r\nimport { GetChessData } from './chessdata/GetChessData';\r\nimport { GetDistance } from './tilexy/GetDistance';\r\nimport { GetEmptyTileXYArray } from './empty/GetEmptyTileXYArray';\r\nimport { GetGridPoints } from './worldxy/GetGridPoints';\r\nimport { GetNeighborChess } from './neighbors/GetNeighborChess';\r\nimport { GetNeighborChessDirection } from './neighbors/GetNeighborChessDirection';\r\nimport { GetNeighborTileDirection } from './neighbors/GetNeighborTileDirection';\r\nimport { GetNeighborTileXY } from './neighbors/GetNeighborTileXY';\r\nimport { GetNeighborTileXYAtAngle } from './neighbors/GetNeighborTileXYAtAngle';\r\nimport { GetOppositeDirection } from './tilexy/GetOppositeDirection';\r\nimport { GetRandomEmptyTileXY } from './empty/GetRandomEmptyTileXY';\r\nimport { GetTileXYAtDirection, DistanceConfig } from './tilexy/GetTileXYAtDirection'\r\nimport { GetWrapTileXY } from './tilexy/GetWrapTileXY';\r\nimport { GridAlign } from './worldxy/GridAlign';\r\nimport { HasBlocker } from './blocker/HasBlocker';\r\nimport { HasChess } from './chess/HasChess';\r\nimport { HasEdgeBlocker } from './blocker/HasEdgeBlocker';\r\nimport { IsAngleInCone } from './worldxy/IsAngleInCone';\r\nimport { IsDirectionInCone } from './tilexy/IsDirectionInCone';\r\nimport { IsOverlappingPoint } from './worldxy/IsOverlappingPoint';\r\nimport { LineToTileXYArray } from './shape/LineToTileXYArray';\r\nimport { Mirror, MirrorMode, MirrorModeString } from './transform/Mirror';\r\nimport { Offset } from './transform/Offset';\r\nimport { RemoveAllChess } from './chess/RemoveAllChess';\r\nimport { RemoveChess } from './chess/RemoveChess';\r\nimport { RingToTileXYArray } from './ring/RingToTileXYArray';\r\nimport { Rotate } from './transform/Rotate';\r\nimport { SetBoardHeight } from './boarddata/SetBoardHeight';\r\nimport { SetBoardWidth } from './boarddata/SetBoardWidth';\r\nimport { SetTileZ } from './chess/SetTileZ';\r\nimport { ShapeToTileXYArray, ShapeType, ContainsCallbackType } from './shape/ShapeToTileXYArray';\r\nimport { SwapChess } from './chess/SwapChess';\r\nimport { TileXYArrayToChessArray } from './tilexy/TileXYArrayToChessArray';\r\nimport { TileXYToChessArray } from './tilexy/TileXYToChessArray';\r\nimport { TileXYZToChess } from './tilexy/TileXYZToChess';\r\nimport { TileZToChessArray } from './tilexy/TileZToChessArray';\r\nimport { TileXYArrayToWorldXYArray } from './worldxy/TileXYArrayToWorldXYArray';\r\nimport { TileXYToWorldXY } from './worldxy/TileXYToWorldXY';\r\nimport { WorldXYSnapToGrid } from './worldxy/WorldXYSnapToGrid';\r\nimport { WorldXYToChess } from './worldxy/WorldXYToChess';\r\nimport { WorldXYToTileXY } from './worldxy/WorldXYToTileXY';\r\n\r\nexport class LogicBoard extends BaseBoard implements ILogicBoard {\r\n\r\n    addChess(\r\n        chess: IChess,\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType,\r\n        align: boolean = true\r\n    ): this {\r\n\r\n        AddChess(this, chess, tileX, tileY, tileZ, align);\r\n        return this;\r\n    }\r\n\r\n    angleBetween(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType\r\n    ): number {\r\n\r\n        return AngleBetween(this, chessA, chessB);\r\n    }\r\n\r\n    angleSnapToDirection(\r\n        tileXY: XYType,\r\n        angle: number\r\n    ): number {\r\n\r\n        return AngleSnapToDirection(this, tileXY, angle);\r\n    }\r\n\r\n    angleToward(\r\n        tileXY: XYType,\r\n        direction: number\r\n    ): number {\r\n\r\n        return AngleToward(this, tileXY, direction);\r\n    }\r\n\r\n    areNeighbors(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType\r\n    ): boolean {\r\n\r\n        return AreNeighbors(this, chessA, chessB);\r\n    }\r\n\r\n    chessToTileXYZ(\r\n        chess: IChess | XYZType | XYType\r\n    ): XYZType | any | null {\r\n\r\n        return ChessToTileXYZ(this, chess);\r\n    }\r\n\r\n    contains(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType\r\n    ): boolean {\r\n\r\n        return Contains(this, tileX, tileY, tileZ);\r\n    }\r\n\r\n    directionBetween(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        round: boolean = true\r\n    ): number | null {\r\n\r\n        return DirectionBetween(this, chessA, chessB, round);\r\n    }\r\n\r\n    filledRingToTileXYArray(\r\n        centerTileXY: XYType,\r\n        radius: number,\r\n        nearToFar: boolean = true,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return FilledRingToTileXYArray(this, centerTileXY, radius, nearToFar, out);\r\n    }\r\n\r\n    fit(\r\n        tileXYArray: XYType[]\r\n    ): XYType[] {\r\n\r\n        return Fit(this, tileXYArray);\r\n    }\r\n\r\n    forEachTileXY(\r\n        callback: ForEachTileXYCallback,\r\n        scope?: any,\r\n        order: ForEachTileXYOrder = 0\r\n    ): this {\r\n\r\n        ForEachTileXY(this, callback, scope, order);\r\n        return this;\r\n    }\r\n\r\n    getAllChess(\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return GetAllChess(this, out);\r\n    }\r\n\r\n    getChessData(\r\n        chess: IChess\r\n    ): IChessData {\r\n\r\n        return GetChessData(chess);\r\n    }\r\n\r\n    getDistance(\r\n        tileA: XYType,\r\n        tileB: XYType,\r\n        roughMode: boolean = false\r\n    ): number {\r\n\r\n        return GetDistance(this, tileA, tileB, roughMode);\r\n    }\r\n\r\n    getEmptyTileXYArray(\r\n        tileZ: ZType | ZType[] = 0,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return GetEmptyTileXYArray(this, tileZ, out);\r\n    }\r\n\r\n    getGridPoints(\r\n        tileX?: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type[] | true\r\n    ): Vec2Type[] {\r\n\r\n        return GetGridPoints(this, tileX, tileY, out);\r\n    }\r\n\r\n    getNeighborChess(\r\n        chess: IChess | XYType,\r\n        directions: number | number[] | string | null,\r\n        neighborTileZ?: ZType | null,\r\n        out?: IChess[]\r\n    ): IChess | IChess[] | null {\r\n\r\n        return GetNeighborChess(this, chess, directions, neighborTileZ, out);\r\n    }\r\n\r\n    getNeighborChessDirection(\r\n        chess: IChess | XYType,\r\n        neighborChess: IChess | XYType\r\n    ): number {\r\n\r\n        return GetNeighborChessDirection(this, chess, neighborChess);\r\n    }\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: XYType | null,\r\n        neighborTileXY: XYType | null\r\n    ): number | null {\r\n\r\n        return GetNeighborTileDirection(this, srcTileXY, neighborTileXY);\r\n    }\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: XYType,\r\n        directions: number | number[] | string | null = null,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType | XYType[] | null {\r\n\r\n        return GetNeighborTileXY(this, srcTileXY, directions, out);\r\n    }\r\n\r\n    getNeighborTileXYAtAngle(\r\n        srcTileXY: XYType,\r\n        angle: number,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType | null {\r\n\r\n        return GetNeighborTileXYAtAngle(this, srcTileXY, angle, out);\r\n    }\r\n\r\n    getOppositeDirection(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        direction: number\r\n    ): number {\r\n\r\n        return GetOppositeDirection(this, tileX, tileY, direction);\r\n    }\r\n\r\n    getRandomEmptyTileXY(\r\n        tileZ: ZType = 0,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType | null {\r\n\r\n        return GetRandomEmptyTileXY(this, tileZ, out);\r\n    }\r\n\r\n    getTileXYAtDirection(\r\n        chess: IChess | XYType,\r\n        directions: number | number[] | string | null,\r\n        distance: number | number[] | DistanceConfig,\r\n        out?: XYType | XYType[] | true\r\n    ): XYType | XYType[] | null {\r\n\r\n        return GetTileXYAtDirection(this, chess, directions, distance, out);\r\n    }\r\n\r\n    getWrapTileXY(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        return GetWrapTileXY(this, tileX, tileY, out)\r\n    }\r\n\r\n    gridAlign(\r\n        chess?: IChess,\r\n        tileX?: XType,\r\n        tileY?: YType\r\n    ): this {\r\n\r\n        GridAlign(this, chess, tileX, tileY);\r\n        return this;\r\n    }\r\n\r\n    hasBlocker(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType\r\n    ): boolean {\r\n\r\n        return HasBlocker(this, tileX, tileY, tileZ);\r\n    }\r\n\r\n    hasChess(\r\n        chess: IChess\r\n    ): boolean {\r\n\r\n        return HasChess(this, chess);\r\n    }\r\n\r\n    hasEdgeBlocker(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ: ZType | undefined,\r\n        direction: number\r\n    ): boolean {\r\n\r\n        return HasEdgeBlocker(this, tileX, tileY, tileZ, direction);\r\n    }\r\n\r\n    isAngleInCone(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        face: number,\r\n        cone: number\r\n    ): boolean {\r\n\r\n        return IsAngleInCone(this, chessA, chessB, face, cone);\r\n    }\r\n\r\n    isDirectionInCone(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        face: number,\r\n        cone: number\r\n    ): boolean {\r\n\r\n        return IsDirectionInCone(this, chessA, chessB, face, cone);\r\n    }\r\n\r\n    isOverlappingPoint(\r\n        worldX: number,\r\n        worldY: number,\r\n        tileZ?: ZType\r\n    ): boolean {\r\n\r\n        return IsOverlappingPoint(this, worldX, worldY, tileZ);\r\n    }\r\n\r\n    lineToTileXYArray(\r\n        startX: number,\r\n        startY: number,\r\n        endX: number,\r\n        endY: number,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return LineToTileXYArray(this, startX, startY, endX, endY, out);\r\n    }\r\n\r\n    mirror(\r\n        tileXY: XYType,\r\n        mode: MirrorMode | MirrorModeString,\r\n        originTileXY: XYType | null = null,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        return Mirror(this, tileXY, mode, originTileXY, out);\r\n    }\r\n\r\n    offset(\r\n        tileXY: XYType,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out?: XYType | true\r\n    ): XYType {\r\n\r\n        return Offset(this, tileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n\r\n    removeAllChess(\r\n        destroy: boolean = false,\r\n        fromBoardRemove: boolean = false\r\n    ): this {\r\n\r\n        RemoveAllChess(this, destroy, fromBoardRemove);\r\n        return this;\r\n    }\r\n\r\n    removeChess(\r\n        chess: IChess | null | undefined,\r\n        tileX?: XType,\r\n        tileY?: YType,\r\n        tileZ?: ZType,\r\n        destroy: boolean = false,\r\n        fromBoardRemove: boolean = false\r\n    ): this {\r\n\r\n        RemoveChess(this, chess, tileX, tileY, tileZ, destroy, fromBoardRemove);\r\n        return this;\r\n    }\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: XYType,\r\n        radius: number = 1,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return RingToTileXYArray(this, centerTileXY, radius, out);\r\n    }\r\n\r\n    rotate(\r\n        tileXY: XYType,\r\n        direction: number,\r\n        originTileXY: XYType | null = null,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        return Rotate(this, tileXY, direction, originTileXY, out);\r\n    }\r\n\r\n    setBoardWidth(\r\n        width: number = 0\r\n    ): this {\r\n\r\n        SetBoardWidth(this, width);\r\n        return this\r\n    }\r\n\r\n    setBoardHeight(\r\n        height: number = 0\r\n    ): this {\r\n\r\n        SetBoardHeight(this, height);\r\n        return this;\r\n    }\r\n\r\n    setTileZ(\r\n        chess: IChess,\r\n        tileZ: ZType\r\n    ): this {\r\n\r\n        SetTileZ(this, chess, tileZ);\r\n        return this;\r\n    }\r\n\r\n    shapeToTileXYArray(\r\n        shape: ShapeType,\r\n        containsCallback: ContainsCallbackType,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return ShapeToTileXYArray(this, shape, containsCallback, out);\r\n    }\r\n\r\n    swapChess(\r\n        chessA: IChess,\r\n        chessB: IChess,\r\n        align: boolean = true\r\n    ): this {\r\n\r\n        SwapChess(this, chessA, chessB, align);\r\n        return this;\r\n    }\r\n\r\n    tileXYArrayToChessArray(\r\n        tileXYArray: XYType[],\r\n        tileZ?: ZType,\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return TileXYArrayToChessArray(this, tileXYArray, tileZ, out);\r\n    }\r\n\r\n    tileXYToChessArray(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return TileXYToChessArray(this, tileX, tileY, out);\r\n    }\r\n\r\n    tileXYZToChess(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ: ZType\r\n    ): IChess | undefined {\r\n\r\n        return TileXYZToChess(this, tileX, tileY, tileZ);\r\n    }\r\n\r\n    tileZToChessArray(\r\n        tileZ: ZType,\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return TileZToChessArray(this, tileZ, out);\r\n    }\r\n\r\n    tileXYArrayToWorldXYArray(\r\n        tileXYArray: XYType[],\r\n        out: Vec2Type[] = []\r\n    ): Vec2Type[] {\r\n\r\n        return TileXYArrayToWorldXYArray(this, tileXYArray, out);\r\n    }\r\n\r\n    tileXYToWorldXY(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return TileXYToWorldXY(this, tileX, tileY, out);\r\n    }\r\n\r\n    worldXYSnapToGrid(\r\n        worldX: number,\r\n        worldY: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return WorldXYSnapToGrid(this, worldX, worldY, out);\r\n    }\r\n\r\n    worldXYToChess(\r\n        worldX: number,\r\n        worldY: number,\r\n        tileZ?: ZType,\r\n        out?: IChess[]\r\n    ): IChess | IChess[] {\r\n\r\n        return WorldXYToChess(this, worldX, worldY, tileZ, out);\r\n    }\r\n\r\n    worldXYToTileXY(\r\n        worldX: number,\r\n        worldY: number,\r\n        out?: XYType | true\r\n    ): XYType {\r\n\r\n        return WorldXYToTileXY(this, worldX, worldY, out);\r\n    }\r\n}", "import { LogicBoard } from './LogicBoard';\r\n\r\nexport class Board extends LogicBoard {\r\n\r\n}", "import { ChessToTileXYZ } from './ChessToTileXYZ';\r\nimport { Contains } from './Contains';\r\nimport { DirectionBetween } from './DirectionBetween';\r\nimport { ForEachTileXY } from './ForEachTileXY';\r\nimport { GetDistance } from './GetDistance';\r\nimport { GetOppositeDirection } from './GetOppositeDirection';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\nimport { GetWrapTileXY } from './GetWrapTileXY';\r\nimport { IsDirectionInCone } from './IsDirectionInCone';\r\nimport { TileXYArrayToChessArray } from './TileXYArrayToChessArray';\r\nimport { TileXYToChessArray } from './TileXYToChessArray';\r\nimport { TileXYZToChess } from './TileXYZToChess';\r\nimport { TileZToChessArray } from './TileZToChessArray';\r\n\r\nexport {\r\n    ChessToTileXYZ,\r\n    Contains,\r\n    DirectionBetween,\r\n    ForEachTileXY,\r\n    GetDistance,\r\n    GetOppositeDirection,\r\n    GetTileXYAtDirection,\r\n    GetWrapTileXY,\r\n    IsDirectionInCone,\r\n    TileXYArrayToChessArray,\r\n    TileXYToChessArray,\r\n    TileXYZToChess,\r\n    TileZToChessArray\r\n}\r\n", "import { AngleBetween } from './AngleBetween';\r\nimport { AngleSnapToDirection } from './AngleSnapToDirection';\r\nimport { AngleToward } from './AngleToward';\r\nimport { GetGridPoints } from './GetGridPoints';\r\nimport { GridAlign } from './GridAlign';\r\nimport { IsAngleInCone } from './IsAngleInCone';\r\nimport { IsOverlappingPoint } from './IsOverlappingPoint';\r\nimport { TileXYArrayToWorldXYArray } from './TileXYArrayToWorldXYArray';\r\nimport { TileXYToWorldXY } from './TileXYToWorldXY';\r\nimport { WorldXYSnapToGrid } from './WorldXYSnapToGrid';\r\nimport { WorldXYToChess } from './WorldXYToChess';\r\nimport { WorldXYToTileXY } from './WorldXYToTileXY';\r\n\r\nexport {\r\n    AngleBetween,\r\n    AngleSnapToDirection,\r\n    AngleToward,\r\n    GetGridPoints,\r\n    GridAlign,\r\n    IsAngleInCone,\r\n    IsOverlappingPoint,\r\n    TileXYArrayToWorldXYArray,\r\n    TileXYToWorldXY,\r\n    WorldXYSnapToGrid,\r\n    WorldXYToChess,\r\n    WorldXYToTileXY\r\n}", "import { AddChess } from './AddChess';\r\nimport { GetAllChess } from './GetAllChess';\r\nimport { HasChess } from './HasChess';\r\nimport { RemoveAllChess } from './RemoveAllChess';\r\nimport { RemoveChess } from './RemoveChess';\r\nimport { SetTileZ } from './SetTileZ';\r\nimport { SwapChess } from './SwapChess';\r\n\r\nexport {\r\n    AddChess,\r\n    GetAllChess,\r\n    HasChess,\r\n    RemoveAllChess,\r\n    RemoveChess,\r\n    SetTileZ,\r\n    SwapChess\r\n}", "import { HasBlocker } from './HasBlocker';\r\nimport { HasEdgeBlocker } from './HasEdgeBlocker';\r\n\r\nexport {\r\n    HasBlocker,\r\n    HasEdgeBlocker\r\n}", "import { GetEmptyTileXYArray } from './GetEmptyTileXYArray';\r\nimport { GetRandomEmptyTileXY } from './GetRandomEmptyTileXY';\r\n\r\nexport {\r\n    GetEmptyTileXYArray,\r\n    GetRandomEmptyTileXY\r\n}", "import { AreNeighbors } from './AreNeighbors';\r\nimport { GetNeighborChess } from './GetNeighborChess';\r\nimport { GetNeighborChessDirection } from './GetNeighborChessDirection';\r\nimport { GetNeighborTileDirection } from './GetNeighborTileDirection';\r\nimport { GetNeighborTileXY } from './GetNeighborTileXY';\r\nimport { GetNeighborTileXYAtAngle } from './GetNeighborTileXYAtAngle';\r\n\r\nexport {\r\n    AreNeighbors,\r\n    GetNeighborChess,\r\n    GetNeighborChessDirection,\r\n    GetNeighborTileDirection,\r\n    GetNeighborTileXY,\r\n    GetNeighborTileXYAtAngle\r\n}", "import { Fit } from './Fit';\r\nimport { Mirror } from './Mirror';\r\nimport { Offset } from './Offset';\r\nimport { Rotate } from './Rotate';\r\n\r\nexport {\r\n    Fit,\r\n    Mirror,\r\n    Offset,\r\n    Rotate\r\n}", "import { LineToTileXYArray } from './LineToTileXYArray';\r\nimport { ShapeToTileXYArray } from './ShapeToTileXYArray';\r\n\r\nexport {\r\n    LineToTileXYArray,\r\n    ShapeToTileXYArray\r\n}", "import { FilledRingToTileXYArray } from './FilledRingToTileXYArray';\r\nimport { RingToTileXYArray } from './RingToTileXYArray';\r\n\r\nexport {\r\n    FilledRingToTileXYArray,\r\n    RingToTileXYArray\r\n}", "import { BaseBoard } from './BaseBoard';\r\nimport { LogicBoard } from './LogicBoard';\r\nimport { Board } from './Board';\r\n\r\nimport * as TileXY from './tilexy';\r\nimport * as WorldXY from './worldxy';\r\nimport * as Chess from './chess';\r\nimport * as Blocker from './blocker';\r\nimport * as Empty from './empty';\r\nimport * as Nieghbors from './neighbors';\r\nimport * as Transform from './transform';\r\nimport * as Shape from './shape';\r\nimport * as Ring from './ring';\r\n\r\nexport {\r\n    BaseBoard,\r\n    LogicBoard,\r\n    Board,\r\n\r\n    TileXY,\r\n    WorldXY,\r\n    Chess,\r\n    Blocker,\r\n    Empty,\r\n    Nieghbors,\r\n    Transform,\r\n    Shape,\r\n    Ring\r\n}", "export enum LayoutMode {\r\n    'orthogonal' = 0,\r\n    'isometric' = 1\r\n}\r\n\r\nexport type LayoutModeString = 'orthogonal' | 'isometric';\r\n\r\nexport enum DirMode {\r\n    '4dir' = 4,\r\n    '8dir' = 8\r\n};\r\n\r\nexport type DirModeString = '4dir' | '8dir';\r\n\r\nexport interface IConfig {\r\n    x?: number,\r\n    y?: number,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n    type?: LayoutMode | LayoutModeString,\r\n    dir?: DirMode | DirModeString\r\n}\r\n\r\nexport interface IState {\r\n    x?: number,\r\n    y?: number,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n    type?: LayoutMode | LayoutModeString,\r\n    dir?: DirMode | DirModeString\r\n}\r\n\r\nexport interface IQuadBase {\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number\r\n\r\n    _halfWidth: number,\r\n    _halfHeight: number,\r\n    mode: LayoutMode,\r\n    directions: DirMode,\r\n};", "import {\r\n    IQuadBase, IConfig, IState,\r\n    LayoutMode, LayoutModeString,\r\n    DirMode, DirModeString\r\n} from './IQuadBase';\r\n\r\nexport class QuadBase implements IQuadBase {\r\n    x: number;\r\n    y: number;\r\n\r\n    _width: number;\r\n    _height: number;\r\n    _halfWidth: number;\r\n    _halfHeight: number;\r\n\r\n    mode: LayoutMode;\r\n    directions: DirMode;\r\n\r\n    constructor({\r\n        x = 0,\r\n        y = 0,\r\n        cellWidth = 0,\r\n        cellHeight = 0,\r\n        type = LayoutMode.orthogonal,\r\n        dir = DirMode['4dir']\r\n    }: IConfig = {}) {\r\n\r\n        this.setOriginPosition(x, y);\r\n        this.setCellSize(cellWidth, cellHeight);\r\n        this.setType(type);\r\n        this.setDirectionMode(dir);\r\n    }\r\n\r\n    fromJSON({\r\n        x = 0,\r\n        y = 0,\r\n        cellWidth = 0,\r\n        cellHeight = 0,\r\n        type = LayoutMode.orthogonal,\r\n        dir = DirMode['4dir']\r\n    }: IState = {}): this {\r\n\r\n        this.setType(type);\r\n        this.setDirectionMode(dir);\r\n        this.setOriginPosition(x, y);\r\n        this.setCellSize(cellWidth, cellHeight);\r\n\r\n        return this;\r\n    }\r\n\r\n    toJSON(): IState {\r\n        return {\r\n            x: this.x,\r\n            y: this.y,\r\n            cellWidth: this.cellWidth,\r\n            cellHeight: this.cellHeight,\r\n            type: this.mode,\r\n            dir: this.directions\r\n        }\r\n    }\r\n\r\n    setOriginPosition(x: number = 0, y: number = 0): this {\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    set width(value) {\r\n        this._width = value;\r\n        this._halfWidth = value / 2;\r\n    }\r\n\r\n    get height() {\r\n        return this._height;\r\n    }\r\n\r\n    set height(value) {\r\n        this._height = value;\r\n        this._halfHeight = value / 2;\r\n    }\r\n\r\n    setCellSize(width: number = 0, height: number = 0) {\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    get cellWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    set cellWidth(value: number) {\r\n        this.width = value;\r\n    }\r\n\r\n    get cellHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    set cellHeight(value: number) {\r\n        this.height = value;\r\n    }\r\n\r\n    setType(type: LayoutMode | LayoutModeString = LayoutMode.orthogonal): this {\r\n\r\n        if (typeof (type) === 'string') {\r\n            type = LayoutMode[type]\r\n        }\r\n\r\n        this.mode = type;\r\n        return this;\r\n    }\r\n\r\n    setDirectionMode(mode: DirMode | DirModeString = DirMode['4dir']): this {\r\n\r\n        if (typeof (mode) === 'string') {\r\n            mode = DirMode[mode];\r\n        }\r\n\r\n        this.directions = mode;\r\n        return this;\r\n    }\r\n}", "import { IQuadBase, LayoutMode, DirMode } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { Between as GetAngle } from '../../../utils/math/angle/Between';\r\nimport { RadToDeg } from '../../../utils/math/angle/RadToDeg';\r\n\r\nexport let DirectionBetween = function (\r\n    quad: IQuadBase,\r\n    tileA: Vec2Type,\r\n    tileB: Vec2Type,\r\n    round: boolean = true\r\n): number {\r\n\r\n    let direction: number;\r\n    switch (quad.mode) {\r\n        case LayoutMode.orthogonal:\r\n        case LayoutMode.isometric:\r\n            if (tileA.y === tileB.y) {\r\n                direction = (tileB.x >= tileA.x) ? 0 : 2;\r\n            } else if (tileA.x === tileB.x) {\r\n                direction = (tileB.y >= tileA.y) ? 1 : 3;\r\n            } else if (quad.directions === DirMode['4dir']) {\r\n                let angle = RadToDeg(GetAngle(tileA.x, tileA.y, tileB.x, tileB.y)); // -180~180\r\n                if (angle < 0) {\r\n                    angle += 360;\r\n                }\r\n                direction = angle / 90;\r\n                if (round) {\r\n                    direction = Math.round(direction);\r\n                }\r\n            } else { // quad.directions === 8\r\n                let dx = tileB.x - tileA.x;\r\n                let dy = tileB.y - tileA.y;\r\n                if (dx === dy) {\r\n                    direction = (dx > 0) ? 4 : 6;\r\n                } else if (dx === -dy) {\r\n                    direction = (dx > 0) ? 7 : 5;\r\n                } else {\r\n                    let angle = RadToDeg(Math.atan2(dy, dx));\r\n                    if (angle < 0) {\r\n                        angle += 360;\r\n                    }\r\n                    let steps = angle / 45;\r\n                    if (round) {\r\n                        steps = Math.round(steps);\r\n                    }\r\n\r\n                    if ((steps >= 0) && (steps < 1)) {\r\n                        direction = steps;  // (steps - 0) + 0\r\n                    } else if ((steps >= 1) && (steps < 2)) {\r\n                        direction = (steps + 3);  // (steps - 1) + 4\r\n                    } else if ((steps >= 2) && (steps < 3)) {\r\n                        direction = (steps - 1);  // (steps - 2) + 1\r\n                    } else if ((steps >= 3) && (steps < 4)) {\r\n                        direction = (steps + 2);  // (steps - 3) + 5\r\n                    } else if ((steps >= 4) && (steps < 5)) {\r\n                        direction = (steps - 2);  // (steps - 4) + 2\r\n                    } else if ((steps >= 5) && (steps < 6)) {\r\n                        direction = (steps + 1);  // (steps - 5) + 6\r\n                    } else if ((steps >= 6) && (steps < 7)) {\r\n                        direction = (steps - 3);  // (steps - 6) + 3\r\n                    } else {  // if ((steps >= 7) && (steps < 8))\r\n                        direction = steps;  // (steps - 7) + 7\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n\r\n    if (direction === quad.directions) {\r\n        direction = 0;\r\n    }\r\n    return direction;\r\n}", "import { IGrid } from '../IGrid';\r\nimport { Wrap } from '../../../utils/math/Wrap';\r\n\r\nexport let DirectionNormalize = function (\r\n    grid: IGrid,\r\n    direction: number\r\n): number {\r\n\r\n    return Wrap(direction, 0, grid.directions);\r\n}", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetDistance = function (\r\n    quad: IQuadBase,\r\n    tileA: Vec2Type,\r\n    tileB: Vec2Type,\r\n    roughMode: boolean = false\r\n): number {\r\n\r\n    let dx = tileB.x - tileA.x;\r\n    let dy = tileB.y - tileA.y;\r\n    let dist: number;\r\n    if (roughMode) {\r\n        dist = Math.abs(dx) + Math.abs(dy);\r\n    } else {\r\n        dist = Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return dist;\r\n}", "import { Vec2Type } from '../IGrid';\r\n\r\nexport let FillPositionArray = function (\r\n    length: number,\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    if (out.length === length) {\r\n        // Do nothing\r\n    } else if (out.length < length) {\r\n        for (let i = out.length; i < length; i++) {\r\n            out.push({ x: 0, y: 0 });\r\n        }\r\n    } else { // out.length < length\r\n        out.length = length;\r\n    }\r\n\r\n    return out;\r\n}", "import { IQuadBase, LayoutMode } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetWorldXY = function (\r\n    quad: IQuadBase,\r\n    tileX: number | Vec2Type,\r\n    tileY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (tileX) === 'object') {\r\n        tileY = tileX.y;\r\n        tileX = tileX.x;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globWorldXY;\r\n    }\r\n\r\n    let worldX, worldY;\r\n    switch (quad.mode) {\r\n        case LayoutMode.orthogonal:\r\n            worldX = tileX * quad.width;\r\n            worldY = tileY * quad.height;\r\n            break;\r\n        case LayoutMode.isometric:\r\n            worldX = (tileX - tileY) * quad._halfWidth;\r\n            worldY = (tileX + tileY) * quad._halfHeight;\r\n            break;\r\n    }\r\n    worldX += quad.x;\r\n    worldY += quad.y;\r\n    out.x = worldX;\r\n    out.y = worldY;\r\n    return out;\r\n\r\n};\r\n\r\nlet globWorldXY: Vec2Type = { x: 0, y: 0 };", "import { IQuadBase, LayoutMode } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { FillPositionArray } from '../utils/FillPositionArray';\r\nimport { GetWorldXY } from './GetWorldXY';\r\n\r\nexport let GetGridPoints = function (\r\n    quad: IQuadBase,\r\n    tileX: number | Vec2Type = 0,\r\n    tileY: number = 0,\r\n    out: Vec2Type[] | true = []\r\n): Vec2Type[] {\r\n\r\n    if (typeof (tileX) === 'object') {\r\n        let tileXY = tileX;\r\n        tileY = tileXY.y;\r\n        tileX = tileXY.x;\r\n    }\r\n    if (out === true) {\r\n        out = globPoints;\r\n    }\r\n\r\n    FillPositionArray(4, out);\r\n\r\n    let x: number,\r\n        y: number;\r\n    ({ x, y } = GetWorldXY(quad, tileX, tileY))\r\n\r\n    let halfW = quad._halfWidth;\r\n    let halfH = quad._halfHeight;\r\n    switch (quad.mode) {\r\n        case LayoutMode.orthogonal:\r\n            // top-right\r\n            out[0].x = x + halfW;\r\n            out[0].y = y - halfH;\r\n            // bottom-right\r\n            out[1].x = x + halfW;\r\n            out[1].y = y + halfH;\r\n            // bottom-left\r\n            out[2].x = x - halfW;\r\n            out[2].y = y + halfH;\r\n            // top-left\r\n            out[3].x = x - halfW;\r\n            out[3].y = y - halfH;\r\n            break;\r\n        case LayoutMode.isometric:\r\n            // 0\r\n            out[0].x = x + halfW;\r\n            out[0].y = y;\r\n            // 90\r\n            out[1].x = x;\r\n            out[1].y = y + halfH;\r\n            // 180\r\n            out[2].x = x - halfW;\r\n            out[2].y = y;\r\n            // 270\r\n            out[3].x = x;\r\n            out[3].y = y - halfH;\r\n            break;\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nlet globPoints: Vec2Type[] = []", "// orthogonal or isometric\r\nexport type DirectionToDeltaXYType = [number, number][];\r\n\r\nconst OrthogonalMap: DirectionToDeltaXYType = [\r\n    [1, 0],\r\n    [0, 1],\r\n    [-1, 0],\r\n    [0, -1],\r\n    [1, 1],\r\n    [-1, 1],\r\n    [-1, -1],\r\n    [1, -1]\r\n];\r\nconst IsometricMap: DirectionToDeltaXYType = OrthogonalMap;\r\n\r\nexport {\r\n    OrthogonalMap,\r\n    IsometricMap\r\n};", "import {\r\n    OrthogonalMap as OrthogonalMapIn,\r\n    IsometricMap as IsometricMapIn,\r\n    DirectionToDeltaXYType\r\n} from './DirectionToDeltaXY';\r\n\r\nexport type DeltaXYToDirectionType = {\r\n    [x: number]: {\r\n        [y: number]: number\r\n    }\r\n}\r\n\r\nlet ReverseDirMap = function (\r\n    dirMap: DirectionToDeltaXYType\r\n): DeltaXYToDirectionType {\r\n\r\n    let out: DeltaXYToDirectionType = {},\r\n        entry: [number, number],\r\n        x: number,\r\n        y: number;\r\n    for (let dir in dirMap) {\r\n        entry = dirMap[dir]; // [x, y]\r\n        x = entry[0];\r\n        y = entry[1];\r\n        if (!out.hasOwnProperty(x)) {\r\n            out[x] = {}\r\n        }\r\n        out[x][y] = parseInt(dir);\r\n    }\r\n    return out;\r\n}\r\n\r\nconst OrthogonalMapOut = ReverseDirMap(OrthogonalMapIn);\r\nconst IsometricMapOut = ReverseDirMap(IsometricMapIn);\r\n\r\nexport {\r\n    OrthogonalMapOut as OrthogonalMap,\r\n    IsometricMapOut as IsometricMap\r\n};", "import { IQuadBase, LayoutMode } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport {\r\n    OrthogonalMap,\r\n    IsometricMap,\r\n    DeltaXYToDirectionType\r\n} from './DeltaTileXYToDirection';\r\n\r\nexport let GetNeighborTileDirection = function (\r\n    quad: IQuadBase,\r\n    srcTileXY: Vec2Type,\r\n    neighborTileXY: Vec2Type\r\n): number | null {\r\n\r\n    let deltaTileXYToDirMap: DeltaXYToDirectionType;\r\n    switch (quad.mode) {\r\n        case LayoutMode.orthogonal:\r\n            deltaTileXYToDirMap = OrthogonalMap;\r\n            break;\r\n        case LayoutMode.isometric:\r\n            deltaTileXYToDirMap = IsometricMap;\r\n            break;\r\n    }\r\n\r\n    let deltaTileX: number = neighborTileXY.x - srcTileXY.x;\r\n    let deltaTileY: number = neighborTileXY.y - srcTileXY.y;\r\n    if (deltaTileXYToDirMap.hasOwnProperty(deltaTileX)) {\r\n        let xEntry = deltaTileXYToDirMap[deltaTileX]\r\n        if (xEntry.hasOwnProperty(deltaTileY)) {\r\n            return xEntry[deltaTileY];\r\n        }\r\n    }\r\n    return null;\r\n}", "import { IQuadBase, LayoutMode } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { OrthogonalMap, IsometricMap } from './DirectionToDeltaXY';\r\n\r\nexport let GetTileXYAtDirection = function (\r\n    quad: IQuadBase,\r\n    srcTileXY: Vec2Type,\r\n    direction: number,\r\n    distance: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let deltaTileX: number,\r\n        deltaTileY: number;\r\n    switch (quad.mode) {\r\n        case LayoutMode.orthogonal:\r\n            deltaTileX = OrthogonalMap[direction][0];\r\n            deltaTileY = OrthogonalMap[direction][1];\r\n            break;\r\n        case LayoutMode.isometric:\r\n            deltaTileX = IsometricMap[direction][0];\r\n            deltaTileY = IsometricMap[direction][1];\r\n            break;\r\n    }\r\n\r\n    if (distance === 1) { // Neighbor\r\n        out.x = srcTileXY.x + deltaTileX;\r\n        out.y = srcTileXY.y + deltaTileY;\r\n    } else {\r\n        out.x = srcTileXY.x + (distance * deltaTileX);\r\n        out.y = srcTileXY.y + (distance * deltaTileY);\r\n    }\r\n    return out;\r\n\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\n\r\nexport let GetNeighborTileXY = function (\r\n    quad: IQuadBase,\r\n    srcTileXY: Vec2Type,\r\n    direction: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    return GetTileXYAtDirection(quad, srcTileXY, direction, 1, out);\r\n}", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetOppositeDirection = function (\r\n    quad: IQuadBase,\r\n    tileX: number | Vec2Type,\r\n    tileY: number | undefined | null,\r\n    direction: number\r\n): number {\r\n\r\n    return oppositeDirectionMap[direction];\r\n}\r\n\r\nconst oppositeDirectionMap = {\r\n    0: 2,  // Left\r\n    1: 3,  // Down\r\n    2: 0,  // Right\r\n    3: 1,  // Up\r\n    4: 6,  // Left-down\r\n    5: 7,  // Down-right\r\n    6: 4,  // Right-up\r\n    7: 5   // Up-left\r\n}", "import { IQuadBase, LayoutMode } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetTileXY = function (\r\n    quad: IQuadBase,\r\n    worldX: number | Vec2Type,\r\n    worldY?: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (worldX) === 'object') {\r\n        worldY = worldX.y;\r\n        worldX = worldX.x;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    worldX -= quad.x;\r\n    worldY -= quad.y;\r\n    let tmpx = worldX / quad.width;\r\n    let tmpy = worldY / quad.height;\r\n    switch (quad.mode) {\r\n        case LayoutMode.orthogonal:\r\n            out.x = Math.round(tmpx);\r\n            out.y = Math.round(tmpy);\r\n            break;\r\n        case LayoutMode.isometric:\r\n            out.x = Math.round(+tmpx + tmpy);\r\n            out.y = Math.round(-tmpx + tmpy);\r\n            break;\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type, MirrorMode, MirrorModeString } from '../IGrid';\r\n\r\nexport let Mirror = function (\r\n    quad: IQuadBase,\r\n    srcTileXY: Vec2Type,\r\n    mode: MirrorMode | MirrorModeString,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (mode) === 'string') {\r\n        mode = MirrorMode[mode];\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    out.x = (mode & 1) ? -srcTileXY.x : srcTileXY.x;\r\n    out.y = (mode & 2) ? -srcTileXY.y : srcTileXY.y;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let Offset = function (\r\n    quad: IQuadBase,\r\n    srcTileXY: Vec2Type,\r\n    offsetTileX: number,\r\n    offsetTileY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let newTileX = srcTileXY.x + offsetTileX;\r\n    let newTileY = srcTileXY.y + offsetTileY;\r\n    out.x = newTileX;\r\n    out.y = newTileY;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { Offset } from './Offset';\r\n\r\nexport let RingToTileXYArray = function (\r\n    quad: IQuadBase,\r\n    centerTileXY: Vec2Type,\r\n    radius: number,\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    let i: number, j: number;\r\n    // Top-right to bottom-right\r\n    i = radius;\r\n    for (j = -radius; j <= radius; j++) {\r\n        out.push(Offset(quad, centerTileXY, i, j));\r\n    }\r\n    // Bottom-right to bottom-left\r\n    j = radius;\r\n    for (i = radius - 1; i >= -radius; i--) {\r\n        out.push(Offset(quad, centerTileXY, i, j));\r\n    }\r\n    // Bottom-left to top-left\r\n    i = -radius;\r\n    for (j = radius - 1; j >= -radius; j--) {\r\n        out.push(Offset(quad, centerTileXY, i, j));\r\n    }\r\n    // Top-left to top-right\r\n    j = -radius;\r\n    for (i = -radius + 1; i <= radius - 1; i++) {\r\n        out.push(Offset(quad, centerTileXY, i, j));\r\n    }\r\n\r\n    return out;\r\n}", "import { IQuadBase } from './IQuadBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { Wrap } from '../../../utils/math/Wrap';\r\n\r\nexport let Rotate = function (\r\n    quad: IQuadBase,\r\n    srcTileXY: Vec2Type,\r\n    dir: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    dir = Wrap(dir, 0, 3);\r\n    let newTileX: number,\r\n        newTileY: number;\r\n    switch (dir) {\r\n        case 1:\r\n            newTileX = -srcTileXY.y;\r\n            newTileY = srcTileXY.x;\r\n            break;\r\n        case 2:\r\n            newTileX = -srcTileXY.x;\r\n            newTileY = -srcTileXY.y;\r\n            break;\r\n        case 3:\r\n            newTileX = srcTileXY.y;\r\n            newTileY = -srcTileXY.x;\r\n            break;\r\n        default:\r\n            newTileX = srcTileXY.x;\r\n            newTileY = srcTileXY.y;\r\n            break;\r\n    }\r\n    out.x = newTileX;\r\n    out.y = newTileY;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IGrid } from '../IGrid';\r\n\r\nexport let SaveOrigin = function (\r\n    grid: IGrid\r\n): void {\r\n    grid._savedOriginX = grid.x;\r\n    grid._savedOriginY = grid.y;\r\n}\r\n\r\nexport let RestoreOrigin = function (\r\n    grid: IGrid\r\n): void {\r\n    grid.x = grid._savedOriginX;\r\n    grid.y = grid._savedOriginY;\r\n}", "import { IGrid, Vec2Type } from '../IGrid';\r\nimport { QuadBase } from './QuadBase';\r\n\r\nimport { DirectionBetween } from './DirectionBetween';\r\nimport { DirectionNormalize } from '../utils/DirectionNormalize';\r\nimport { GetDistance } from './GetDistance';\r\nimport { GetGridPoints } from './GetGridPoints';\r\nimport { GetNeighborTileDirection } from './GetNeighborTileDirection';\r\nimport { GetNeighborTileXY } from './GetNeighborTileXY';\r\nimport { GetOppositeDirection } from './GetOppositeDirection';\r\nimport { GetTileXY } from './GetTileXY';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\nimport { GetWorldXY } from './GetWorldXY';\r\nimport { MirrorMode, MirrorModeString } from '../IGrid';\r\nimport { Mirror } from './Mirror';\r\nimport { Offset } from './Offset';\r\nimport { RingToTileXYArray } from './RingToTileXYArray';\r\nimport { Rotate } from './Rotate';\r\nimport { SaveOrigin, RestoreOrigin } from '../utils/SaveOrigin';\r\n\r\n\r\nexport class Quad extends QuadBase implements IGrid {\r\n\r\n    _savedOriginX: number;\r\n    _savedOriginY: number;\r\n\r\n    get sides() {\r\n        return 4;\r\n    }\r\n\r\n    // Direction of neighbors\r\n    get allDirections() {\r\n        return (this.directions === 4) ? ALLDIR4 : ALLDIR8;\r\n    }\r\n\r\n    // Board-match\r\n    get halfDirections() {\r\n        return (this.directions === 4) ? HALFDIR4 : HALFDIR8;\r\n    }\r\n\r\n    directionBetween(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        round: boolean = true\r\n    ): number {\r\n\r\n        return DirectionBetween(this, tileA, tileB, round);\r\n    }\r\n\r\n    directionNormalize(\r\n        direction: number\r\n    ): number {\r\n\r\n        return DirectionNormalize(this, direction);\r\n    }\r\n\r\n    getDistance(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        roughMode: boolean = false\r\n    ): number {\r\n\r\n        return GetDistance(this, tileA, tileB, roughMode);\r\n    }\r\n\r\n    getGridPoints(\r\n        tileX: number | Vec2Type = 0,\r\n        tileY: number = 0,\r\n        out: Vec2Type[] | true = []\r\n    ): Vec2Type[] {\r\n\r\n        return GetGridPoints(this, tileX, tileY, out);\r\n    }\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: Vec2Type,\r\n        neighborTileXY: Vec2Type\r\n    ): number | null {\r\n\r\n        return GetNeighborTileDirection(this, srcTileXY, neighborTileXY);\r\n    }\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetNeighborTileXY(this, srcTileXY, direction, out);\r\n    }\r\n\r\n    getOppositeDirection(\r\n        tileX: number | Vec2Type,\r\n        tileY: number | undefined | null,\r\n        direction: number\r\n    ): number {\r\n\r\n        return GetOppositeDirection(this, tileX, tileY, direction);\r\n    }\r\n\r\n    getTileXY(\r\n        worldX: number | Vec2Type,\r\n        worldY?: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetTileXY(this, worldX, worldY, out);\r\n    }\r\n\r\n    getTileXYAtDirection(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        distance: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetTileXYAtDirection(this, srcTileXY, direction, distance, out);\r\n    }\r\n\r\n    getWorldXY(\r\n        tileX: number | Vec2Type,\r\n        tileY?: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetWorldXY(this, tileX, tileY, out);\r\n    }\r\n\r\n    mirror(\r\n        srcTileXY: Vec2Type,\r\n        mode: MirrorMode | MirrorModeString,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Mirror(this, srcTileXY, mode, out);\r\n    }\r\n\r\n    offset(\r\n        srcTileXY: Vec2Type,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Offset(this, srcTileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: Vec2Type,\r\n        radius: number,\r\n        out: Vec2Type[] = []\r\n    ): Vec2Type[] {\r\n\r\n        return RingToTileXYArray(this, centerTileXY, radius, out);\r\n    }\r\n\r\n    rotate(srcTileXY: Vec2Type,\r\n        dir: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Rotate(this, srcTileXY, dir, out);\r\n    }\r\n\r\n    restoreOrigin(): this {\r\n\r\n        RestoreOrigin(this);\r\n        return this\r\n    }\r\n\r\n    saveOrigin(): this {\r\n\r\n        SaveOrigin(this);\r\n        return this;\r\n    }\r\n}\r\n\r\nconst ALLDIR4 = [0, 1, 2, 3];\r\nconst ALLDIR8 = [0, 1, 2, 3, 4, 5, 6, 7];\r\nconst HALFDIR4 = [0, 1];\r\nconst HALFDIR8 = [0, 1, 4, 5];", "export enum LayoutMode {\r\n    ODD_R = 0,\r\n    EVEN_R = 1,\r\n    ODD_Q = 2,\r\n    EVEN_Q = 3\r\n}\r\n\r\nexport type LayoutModeString = 'ODD_R' | 'EVEN_R' | 'ODD_Q' | 'EVEN_Q'\r\n\r\nexport enum StaggerAxis {\r\n    y = 0,\r\n    flat = 0,\r\n    x = 1,\r\n    pointy = 1\r\n}\r\n\r\nexport type StaggerAxisString = 'y' | 'x' | 'flat' | 'pointy';\r\n\r\nexport enum StaggerIndex {\r\n    even = 0,\r\n    odd = 1\r\n}\r\n\r\nexport type StaggerIndexString = 'even' | 'odd';\r\n\r\nexport interface IState {\r\n    x?: number,\r\n    y?: number,\r\n\r\n    radius?: number,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n\r\n    staggerAxis?: StaggerAxis | StaggerAxisString,\r\n    staggerIndex?: StaggerIndex | StaggerIndexString\r\n}\r\n\r\nexport interface IConfig {\r\n    x?: number,\r\n    y?: number,\r\n\r\n    radius?: number | undefined,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n\r\n    staggerAxis?: StaggerAxis | StaggerAxisString,\r\n    staggerIndex?: StaggerIndex | StaggerIndexString\r\n}\r\n\r\nexport interface IHexagonBase {\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number\r\n\r\n    _halfWidth: number,\r\n    _halfHeight: number,\r\n    radius: number,\r\n    mode: LayoutMode,\r\n    directions: number,\r\n    staggerAxis: StaggerAxis\r\n};", "import {\r\n    IHexagonBase, IConfig, IState,\r\n    StaggerAxis, StaggerAxisString, StaggerIndex, StaggerIndexString, LayoutMode\r\n} from './IHexagonBase';\r\n\r\nexport class HexagonBase implements IHexagonBase {\r\n    x: number;\r\n    y: number;\r\n\r\n    _width: number;\r\n    _height: number;\r\n    _halfWidth: number;\r\n    _halfHeight: number;\r\n    radius: number;\r\n\r\n    mode: LayoutMode;\r\n    staggerAxis: StaggerAxis;\r\n    staggerIndex: StaggerIndex;\r\n    directions: number;\r\n\r\n    constructor({\r\n        x = 0,\r\n        y = 0,\r\n        radius = undefined,\r\n        cellWidth = 0,\r\n        cellHeight = 0,\r\n        staggerAxis = StaggerAxis.x,\r\n        staggerIndex = StaggerIndex.odd\r\n    }: IConfig = {}) {\r\n\r\n        this.setType(staggerAxis, staggerIndex);\r\n        this.setDirectionMode();\r\n\r\n        this.setOriginPosition(x, y);\r\n\r\n        if (radius !== undefined) {\r\n            this.setRadius(radius);\r\n        } else {\r\n            this.setCellSize(cellWidth, cellHeight);\r\n        }\r\n    }\r\n\r\n    fromJSON({\r\n        x = 0,\r\n        y = 0,\r\n        radius = undefined,\r\n        cellWidth = 0,\r\n        cellHeight = 0,\r\n        staggerAxis = StaggerAxis.x,\r\n        staggerIndex = StaggerIndex.odd\r\n    }: IState = {}): this {\r\n\r\n        this.setType(staggerAxis, staggerIndex);\r\n        this.setDirectionMode();\r\n\r\n        this.setOriginPosition(x, y);\r\n        if (radius !== undefined) {\r\n            this.setRadius(radius);\r\n        } else {\r\n            this.setCellSize(cellWidth, cellHeight);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    toJSON(): IState {\r\n        return {\r\n            x: this.x,\r\n            y: this.y,\r\n\r\n            radius: this.radius,\r\n            cellWidth: this.cellWidth,\r\n            cellHeight: this.cellHeight,\r\n            staggerAxis: this.staggerAxis,\r\n            staggerIndex: this.staggerIndex\r\n        }\r\n    }\r\n\r\n    setOriginPosition(x: number, y: number): this {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    set width(value: number) {\r\n        this._width = value;\r\n        this._halfWidth = value / 2;\r\n    }\r\n\r\n    get height() {\r\n        return this._height;\r\n    }\r\n\r\n    set height(value: number) {\r\n        this._height = value;\r\n        this._halfHeight = value / 2;\r\n    }\r\n\r\n    setCellSize(width: number = 0, height: number = 0): this {\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.radius = undefined;\r\n        return this;\r\n    }\r\n\r\n    get cellWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    set cellWidth(value: number) {\r\n        this.width = value;\r\n    }\r\n\r\n    get cellHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    set cellHeight(value: number) {\r\n        this.height = value;\r\n    }\r\n\r\n    setRadius(radius: number = 0): this {\r\n\r\n        let cellWidth: number,\r\n            cellHeight: number;\r\n        if (this.staggerAxis === StaggerAxis.y) {\r\n            cellWidth = 2 * radius;\r\n            cellHeight = SQRT3 * radius;\r\n        } else {\r\n            cellWidth = SQRT3 * radius;\r\n            cellHeight = 2 * radius;\r\n        }\r\n        this.setCellSize(cellWidth, cellHeight);\r\n        this.radius = radius;\r\n        return this;\r\n    }\r\n\r\n    setDirectionMode(): this {\r\n        this.directions = 6;\r\n        return this;\r\n    }\r\n\r\n    setType(\r\n        staggerAxis: StaggerAxis | StaggerAxisString = 1,\r\n        staggerIndex: StaggerIndex | StaggerIndexString = 1\r\n    ): this {\r\n\r\n        if (typeof (staggerAxis) === 'string') {\r\n            staggerAxis = StaggerAxis[staggerAxis]\r\n        }\r\n        if (typeof (staggerIndex) === 'string') {\r\n            staggerIndex = StaggerIndex[staggerIndex]\r\n        }\r\n\r\n        this.staggerAxis = staggerAxis;\r\n        this.staggerIndex = staggerIndex;\r\n        if (staggerAxis === StaggerAxis.y) { // flat\r\n            this.mode = (staggerIndex === StaggerIndex.even) ? LayoutMode.EVEN_Q : LayoutMode.ODD_Q;\r\n        } else { // pointy\r\n            this.mode = (staggerIndex === StaggerIndex.even) ? LayoutMode.EVEN_R : LayoutMode.ODD_R;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\nconst SQRT3 = Math.sqrt(3);", "import { LayoutMode } from './IHexagonBase';\r\n\r\nexport type CubeType = {\r\n    x: number,\r\n    y: number,\r\n    z: number\r\n}\r\n\r\nexport type ColRowType = {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\nexport type QRType = {\r\n    q: number,\r\n    r: number\r\n}\r\n\r\nexport function cr2cube(\r\n    mode: LayoutMode,\r\n    col: number,\r\n    row: number,\r\n    out: CubeType | true = { x: 0, y: 0, z: 0 }\r\n): CubeType {\r\n\r\n    if (out === true) {\r\n        out = globCube;\r\n    }\r\n\r\n    switch (mode) {\r\n        case LayoutMode.ODD_R:\r\n            out.x = col - (row - (row & 1)) / 2;\r\n            out.z = row;\r\n            break;\r\n\r\n        case LayoutMode.EVEN_R:\r\n            out.x = col - (row + (row & 1)) / 2;\r\n            out.z = row;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            out.x = col;\r\n            out.z = row - (col - (col & 1)) / 2;\r\n            break;\r\n        case LayoutMode.EVEN_Q:\r\n            out.x = col;\r\n            out.z = row - (col + (col & 1)) / 2;\r\n            break;\r\n    }\r\n    out.y = -out.x - out.z;\r\n    return out;\r\n}\r\n\r\nexport function roundcube(\r\n    x: number | CubeType,\r\n    y?: number,\r\n    z?: number,\r\n    out: CubeType | true = { x: 0, y: 0, z: 0 }\r\n): CubeType {\r\n\r\n    if (typeof (x) !== 'number') {\r\n        out = x;\r\n        x = out.x;\r\n        y = out.y;\r\n        z = out.z;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globCube;\r\n    }\r\n\r\n    let rx = Math.round(x);\r\n    let ry = Math.round(y);\r\n    let rz = Math.round(z);\r\n\r\n    let dx = Math.abs(rx - x);\r\n    let dy = Math.abs(ry - y);\r\n    let dz = Math.abs(rz - z);\r\n\r\n    if ((dx > dy) && (dx > dz)) {\r\n        rx = -ry - rz;\r\n    } else if (dy > dz) {\r\n        ry = -rx - rz;\r\n    } else {\r\n        rz = -rx - ry;\r\n    }\r\n    out.x = rx;\r\n    out.y = ry;\r\n    out.z = rz;\r\n    return out;\r\n}\r\n\r\nexport function cube2cr(\r\n    mode: LayoutMode,\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    out: ColRowType | true = { x: 0, y: 0 }\r\n): ColRowType {\r\n\r\n    if (out === true) {\r\n        out = globCR;\r\n    }\r\n\r\n    switch (mode) {\r\n        case LayoutMode.ODD_R:\r\n            out.x = x + (z - (z & 1)) / 2;\r\n            out.y = z;\r\n            break;\r\n        case LayoutMode.EVEN_R:\r\n            out.x = x + (z + (z & 1)) / 2;\r\n            out.y = z;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            out.x = x;\r\n            out.y = z + (x - (x & 1)) / 2;\r\n            break;\r\n        case LayoutMode.EVEN_Q:\r\n            out.x = x;\r\n            out.y = z + (x + (x & 1)) / 2;\r\n            break;\r\n    }\r\n    return out;\r\n}\r\n\r\nexport function qr2cube(\r\n    q: number,\r\n    r: number,\r\n    out: CubeType | true = { x: 0, y: 0, z: 0 }\r\n): CubeType {\r\n\r\n    if (out === true) {\r\n        out = globCube;\r\n    }\r\n    out.x = q;\r\n    out.y = -q - r;\r\n    out.z = r;\r\n    return out;\r\n}\r\n\r\nexport function cube2qr(\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    out: QRType | true = { q: 0, r: 0 }\r\n): QRType {\r\n\r\n    if (out === true) {\r\n        out = globQR;\r\n    }\r\n\r\n    out.q = x;\r\n    out.r = z;\r\n    return out;\r\n}\r\n\r\nlet globCube: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globCR: ColRowType = { x: 0, y: 0 };\r\nlet globQR: QRType = { q: 0, r: 0 };", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, CubeType } from './CubeTransfer';\r\n\r\nexport let DirectionBetween = function (\r\n    hexagon: IHexagonBase,\r\n    tileA: Vec2Type,\r\n    tileB: Vec2Type,\r\n    round: boolean = true\r\n): number {\r\n\r\n    let direction: number;\r\n    cr2cube(hexagon.mode, tileA.x, tileA.y, globCubeA);\r\n    cr2cube(hexagon.mode, tileB.x, tileB.y, globCubeB);\r\n    let dx = globCubeB.x - globCubeA.x;\r\n    let dy = globCubeB.y - globCubeA.y;\r\n    let dz = globCubeB.z - globCubeA.z;\r\n    if (dz === 0) {\r\n        direction = (dx > 0) ? 0 : 3;\r\n    } else if (dx === 0) {\r\n        direction = (dz > 0) ? 1 : 4;\r\n    } else if (dy === 0) {\r\n        direction = (dz > 0) ? 2 : 5;\r\n    } else if ((dx > 0) && (dy < 0) && (dz > 0)) { // 0~1\r\n        direction = 0 + (dz / (-dy));\r\n    } else if ((dx < 0) && (dy < 0) && (dz > 0)) { // 1~2\r\n        direction = 1 + ((-dy) / dz);\r\n    } else if ((dx < 0) && (dy > 0) && (dz > 0)) { // 2~3\r\n        direction = 2 + (dy / (-dx));\r\n    } else if ((dx < 0) && (dy > 0) && (dz < 0)) { // 3~4\r\n        direction = 3 + ((-dz) / dy);\r\n    } else if ((dx > 0) && (dy > 0) && (dz < 0)) { // 4~5\r\n        direction = 4 + (dx / (-dz));\r\n    } else { // ((dx > 0) && (dy < 0) && (dz < 0)) // 5~0\r\n        direction = 5 + ((-dy) / dx);\r\n    }\r\n\r\n    if (round) {\r\n        direction = Math.round(direction);\r\n    }\r\n    return direction;\r\n}\r\n\r\nlet globCubeA: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globCubeB: CubeType = { x: 0, y: 0, z: 0 };", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, CubeType } from './CubeTransfer';\r\n\r\nexport let GetDistance = function (\r\n    hexagon: IHexagonBase,\r\n    tileA: Vec2Type,\r\n    tileB: Vec2Type,\r\n    roughMode: boolean = false\r\n): number {\r\n\r\n    cr2cube(hexagon.mode, tileA.x, tileA.y, globCubeA);\r\n    cr2cube(hexagon.mode, tileB.x, tileB.y, globCubeB);\r\n    let dx = globCubeB.x - globCubeA.x;\r\n    let dy = globCubeB.y - globCubeA.y;\r\n    let dz = globCubeB.z - globCubeA.z;\r\n    return (Math.abs(dx) + Math.abs(dy) + Math.abs(dz)) / 2;\r\n}\r\n\r\nlet globCubeA: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globCubeB: CubeType = { x: 0, y: 0, z: 0 };\r\n\r\nexport default GetDistance;", "import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetWorldXY = function (\r\n    hexagon: IHexagonBase,\r\n    tileX: number | Vec2Type,\r\n    tileY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (tileX) === 'object') {\r\n        tileY = tileX.y;\r\n        tileX = tileX.x;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globWorldXY;\r\n    }\r\n\r\n    let worldX = (tileX * hexagon.width);\r\n    let worldY = (tileY * hexagon.height);\r\n    switch (hexagon.mode) {\r\n        case LayoutMode.ODD_R:\r\n            if (tileY & 1) {\r\n                worldX += hexagon._halfWidth;\r\n            }\r\n            worldY *= 0.75;\r\n            break;\r\n\r\n        case LayoutMode.EVEN_R:\r\n            if (tileY & 1) {\r\n                worldX -= hexagon._halfWidth;\r\n            }\r\n            worldY *= 0.75;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            worldX *= 0.75;\r\n            if (tileX & 1) {\r\n                worldY += hexagon._halfHeight;\r\n            }\r\n            break;\r\n\r\n        case LayoutMode.EVEN_Q:\r\n            worldX *= 0.75;\r\n            if (tileX & 1) {\r\n                worldY -= hexagon._halfHeight;\r\n            }\r\n            break;\r\n    }\r\n    worldX += hexagon.x;\r\n    worldY += hexagon.y;\r\n    out.x = worldX;\r\n    out.y = worldY;\r\n    return out;\r\n}\r\n\r\nlet globWorldXY: Vec2Type = { x: 0, y: 0 };", "const DEG_TO_RAD = Math.PI / 180;\r\n\r\nexport let DegToRad = function (degrees: number): number {\r\n\r\n    return degrees * DEG_TO_RAD;\r\n};\r\n", "import { IHexagonBase, StaggerAxis } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { FillPositionArray } from '../utils/FillPositionArray';\r\nimport { GetWorldXY } from './GetWorldXY';\r\nimport { DegToRad } from '../../../utils/math/angle/DegToRad';\r\n\r\nexport let GetGridPoints = function (\r\n    hexagon: IHexagonBase,\r\n    tileX: number | Vec2Type = 0,\r\n    tileY: number = 0,\r\n    out: Vec2Type[] | true = []\r\n): Vec2Type[] {\r\n\r\n    if (typeof (tileX) === 'object') {\r\n        let tileXY = tileX;\r\n        tileY = tileXY.y;\r\n        tileX = tileXY.x;\r\n    }\r\n    if (out === true) {\r\n        out = globPoints;\r\n    }\r\n\r\n    FillPositionArray(6, out);\r\n\r\n    let x: number,\r\n        y: number;\r\n    ({ x, y } = GetWorldXY(hexagon, tileX, tileY))\r\n\r\n    if (hexagon.radius !== undefined) {\r\n        let radius = hexagon.radius;\r\n        let angleOffset = (hexagon.staggerAxis === StaggerAxis.flat) ? 0 : -30;\r\n        for (let i = 0; i < 6; i++) {\r\n            let angleDeg = (60 * i) + angleOffset;\r\n            let angleRad = DegToRad(angleDeg);\r\n            out[i].x = x + radius * Math.cos(angleRad);\r\n            out[i].y = y + radius * Math.sin(angleRad);\r\n        }\r\n\r\n    } else {\r\n        let halfW = hexagon._halfWidth;\r\n        let quarterW = halfW / 2;\r\n        let halfH = hexagon._halfHeight;\r\n        let quarterH = halfH / 2;\r\n        if (hexagon.staggerAxis === StaggerAxis.flat) {\r\n            out[0].x = x + halfW;\r\n            out[0].y = y;\r\n\r\n            out[1].x = x + quarterW;\r\n            out[1].y = y + halfH;\r\n\r\n            out[2].x = x - quarterW;\r\n            out[2].y = y + halfH;\r\n\r\n            out[3].x = x - halfW;\r\n            out[3].y = y;\r\n\r\n            out[4].x = x - quarterW;\r\n            out[4].y = y - halfH;\r\n\r\n            out[5].x = x + quarterW;\r\n            out[5].y = y - halfH;\r\n        } else { // StaggerAxis.pointy\r\n            out[0].x = x + halfW;\r\n            out[0].y = y - quarterH;\r\n\r\n            out[1].x = x + halfW;\r\n            out[1].y = y + quarterH;\r\n\r\n            out[2].x = x;\r\n            out[2].y = y + halfH;\r\n\r\n            out[3].x = x - halfW;\r\n            out[3].y = y + quarterH;\r\n\r\n            out[4].x = x - halfW;\r\n            out[4].y = y - quarterH;\r\n\r\n            out[5].x = x;\r\n            out[5].y = y - halfH;\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nlet globPoints: Vec2Type[] = []", "type DeltaXYType = [number, number];\r\nexport type DirectionToDeltaXYEntryType = DeltaXYType[];\r\ntype ParityToDeltaXYType = DirectionToDeltaXYEntryType[];\r\ntype DirectionToDeltaTileXYType = ParityToDeltaXYType[];\r\n\r\nconst ODD_R: ParityToDeltaXYType = [\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1]\r\n    ],\r\n    [\r\n        [+1, 0],\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ]\r\n];\r\nconst EVEN_R: ParityToDeltaXYType = [\r\n    [\r\n        [+1, 0],\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ],\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1]\r\n    ]\r\n];\r\nconst ODD_Q: ParityToDeltaXYType = [\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ],\r\n    [\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, 0]\r\n    ]\r\n];\r\nconst EVEN_Q: ParityToDeltaXYType = [\r\n    [\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, 0]\r\n    ],\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ]\r\n];\r\n\r\nexport let DirectionToDeltaTileXY: DirectionToDeltaTileXYType = [\r\n    ODD_R,\r\n    EVEN_R,\r\n    ODD_Q,\r\n    EVEN_Q\r\n];\r\n// DirectionToDeltaTileXYType[mode][parity][dir]: [x/y]", "import {\r\n    DirectionToDeltaTileXY,\r\n    DirectionToDeltaXYEntryType\r\n} from './DirectionToDeltaTileXY';\r\n\r\ntype DeltaXYToDirectionEntryType = {\r\n    [x: number]: {\r\n        [y: number]: number\r\n    }\r\n}\r\n\r\nlet ReverseDirMap = function (\r\n    dirMap: DirectionToDeltaXYEntryType\r\n): DeltaXYToDirectionEntryType {\r\n\r\n    let out: DeltaXYToDirectionEntryType = {},\r\n        x: number, y: number;\r\n    for (let dir in dirMap) {\r\n        ([x, y] = dirMap[dir]);\r\n        if (!out.hasOwnProperty(x)) {\r\n            out[x] = {}\r\n        }\r\n        out[x][y] = parseInt(dir);\r\n    }\r\n    return out;\r\n}\r\n\r\ntype ParityToDirectionType = DeltaXYToDirectionEntryType[];\r\nexport type DeltaTileXYToDirectionType = ParityToDirectionType[];\r\nexport let DeltaTileXYToDirection: DeltaTileXYToDirectionType = [\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[0][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[0][1])\r\n    ],\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[1][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[1][1])\r\n    ],\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[2][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[2][1])\r\n    ],\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[3][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[3][1])\r\n    ]\r\n];\r\n// DeltaTileXYToDirection[mode][parity][x][y]: dir", "import { LayoutMode } from './IHexagonBase'\r\n\r\nexport function GetParity(\r\n    mode: LayoutMode,\r\n    tileX: number,\r\n    tileY: number\r\n): number {\r\n\r\n    let parity;\r\n    switch (mode) {\r\n        case LayoutMode.ODD_R:\r\n        case LayoutMode.EVEN_R:\r\n            parity = tileY & 1;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n        case LayoutMode.EVEN_Q:\r\n            parity = tileX & 1;\r\n            break;\r\n    }\r\n    return parity;\r\n}", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { DeltaTileXYToDirection } from './DeltaTileXYToDirection';\r\nimport { GetParity } from './GetParity';\r\n\r\nexport let GetNeighborTileDirection = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    neighborTileXY: Vec2Type\r\n): number | null {\r\n\r\n    let mode = hexagon.mode;\r\n    let parity = GetParity(mode, srcTileXY.x, srcTileXY.y);\r\n    let deltaTileXYToDirMap = DeltaTileXYToDirection[mode][parity];\r\n\r\n    let deltaTileX = neighborTileXY.x - srcTileXY.x;\r\n    let deltaTileY = neighborTileXY.y - srcTileXY.y;\r\n    if (deltaTileXYToDirMap.hasOwnProperty(deltaTileX)) {\r\n        let xEntry = deltaTileXYToDirMap[deltaTileX]\r\n        if (xEntry.hasOwnProperty(deltaTileY)) {\r\n            return xEntry[deltaTileY];\r\n        }\r\n    }\r\n    return null;\r\n}", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { DirectionToDeltaTileXY } from './DirectionToDeltaTileXY';\r\nimport { GetParity } from './GetParity';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nexport let GetTileXYAtDirection = function (\r\n    hexragon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    direction: number,\r\n    distance: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let mode = hexragon.mode;\r\n    let srcTileX = srcTileXY.x,\r\n        srcTileY = srcTileXY.y;\r\n\r\n    if (distance === 1) { // Neighbor\r\n        let parity = GetParity(mode, srcTileX, srcTileY);\r\n        out.x = srcTileX + DirectionToDeltaTileXY[mode][parity][direction][0];\r\n        out.y = srcTileY + DirectionToDeltaTileXY[mode][parity][direction][1];\r\n    } else if (distance === 0) {\r\n        out.x = srcTileX;\r\n        out.y = srcTileY;\r\n    } else {\r\n        let cubeXYZ = cr2cube(mode, srcTileX, srcTileY, true);\r\n        let newCubeX: number,\r\n            newCubeY: number,\r\n            newCubeZ: number;\r\n\r\n        switch (direction) {\r\n            case 1:\r\n                newCubeX = cubeXYZ.x;\r\n                newCubeY = cubeXYZ.y - distance;\r\n                newCubeZ = cubeXYZ.z + distance;\r\n                break;\r\n            case 2:\r\n                newCubeX = cubeXYZ.x - distance;\r\n                newCubeY = cubeXYZ.y;\r\n                newCubeZ = cubeXYZ.z + distance;\r\n                break;\r\n            case 3:\r\n                newCubeX = cubeXYZ.x - distance;\r\n                newCubeY = cubeXYZ.y + distance;\r\n                newCubeZ = cubeXYZ.z;\r\n                break;\r\n            case 4:\r\n                newCubeX = cubeXYZ.x;\r\n                newCubeY = cubeXYZ.y + distance;\r\n                newCubeZ = cubeXYZ.z - distance;\r\n                break;\r\n            case 5:\r\n                newCubeX = cubeXYZ.x + distance;\r\n                newCubeY = cubeXYZ.y;\r\n                newCubeZ = cubeXYZ.z - distance;\r\n                break;\r\n            default:\r\n                newCubeX = cubeXYZ.x + distance;\r\n                newCubeY = cubeXYZ.y - distance;\r\n                newCubeZ = cubeXYZ.z;\r\n                break;\r\n        }\r\n        cube2cr(mode, newCubeX, newCubeY, newCubeZ, out);\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\n\r\nexport let GetNeighborTileXY = function (\r\n    hexragon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    direction: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    return GetTileXYAtDirection(hexragon, srcTileXY, direction, 1, out);\r\n};", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetOppositeDirection = function (\r\n    hexagon: IHexagonBase,\r\n    tileX: number | Vec2Type,\r\n    tileY: number | undefined | null,\r\n    direction\r\n): number {\r\n\r\n    return (direction + 3) % 6;\r\n};", "import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { qr2cube, roundcube, cube2cr, CubeType } from './CubeTransfer';\r\n\r\nconst C_4div3 = (4 / 3);\r\nconst C_2div3 = (2 / 3);\r\n\r\nexport let GetTileXY = function (\r\n    hexagon: IHexagonBase,\r\n    worldX: number | Vec2Type,\r\n    worldY?: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (worldX) === 'object') {\r\n        worldY = worldX.y;\r\n        worldX = worldX.x;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    worldX -= hexagon.x;\r\n    worldY -= hexagon.y;\r\n    let q: number,\r\n        r: number;\r\n\r\n    switch (hexagon.mode) {\r\n        case LayoutMode.ODD_R:\r\n        case LayoutMode.EVEN_R:\r\n            r = (worldY * C_4div3) / hexagon.height;\r\n            q = (worldX / hexagon.width) - C_2div3 * (worldY / hexagon.height);\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n        case LayoutMode.EVEN_Q:\r\n            r = (worldY / hexagon.height) - C_2div3 * (worldX / hexagon.width);\r\n            q = (worldX * C_4div3) / hexagon.width;\r\n            break;\r\n    }\r\n\r\n    let cube = qr2cube(q, r, globCube);\r\n    roundcube(cube);\r\n    cube2cr(hexagon.mode, cube.x, cube.y, cube.z, out);\r\n    return out;\r\n}\r\n\r\nlet globCube: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };\r\n", "import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport {\r\n    Vec2Type,\r\n    MirrorMode, MirrorModeString\r\n} from '../IGrid';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nexport let Mirror = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    mode: MirrorMode | MirrorModeString,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (mode) === 'string') {\r\n        mode = MirrorMode[mode];\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let cubeXYZ = cr2cube(hexagon.mode, srcTileXY.x, srcTileXY.y, true);\r\n    let isRMode = (hexagon.mode === LayoutMode.ODD_R) || (hexagon.mode === LayoutMode.EVEN_R);\r\n    let newCubeX: number,\r\n        newCubeY: number,\r\n        newCubeZ: number;\r\n\r\n    if (mode & 1) { // Mirror x\r\n        if (isRMode) {\r\n            newCubeX = cubeXYZ.y;\r\n            newCubeY = cubeXYZ.x;\r\n            newCubeZ = cubeXYZ.z;\r\n        } else {\r\n            newCubeX = -cubeXYZ.x;\r\n            newCubeY = -cubeXYZ.z;\r\n            newCubeZ = -cubeXYZ.y;\r\n        }\r\n        cubeXYZ.x = newCubeX;\r\n        cubeXYZ.y = newCubeY;\r\n        cubeXYZ.z = newCubeZ;\r\n    }\r\n    if (mode & 2) { // Mirror y\r\n        if (isRMode) {\r\n            newCubeX = -cubeXYZ.y;\r\n            newCubeY = -cubeXYZ.x;\r\n            newCubeZ = -cubeXYZ.z;\r\n        } else {\r\n            newCubeX = cubeXYZ.x;\r\n            newCubeY = cubeXYZ.z;\r\n            newCubeZ = cubeXYZ.y;\r\n        }\r\n    }\r\n    cube2cr(hexagon.mode, newCubeX, newCubeY, newCubeZ, out);\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };\r\n\r\nexport default Mirror;", "import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let Offset = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let newX = srcTileXY.x + offsetX;\r\n    let newY = srcTileXY.y + offsetY;\r\n    switch (hexagon.mode) {\r\n        case LayoutMode.ODD_R:\r\n            if ((offsetY & 1) !== 0) {\r\n                if ((newY & 1) === 0) {\r\n                    newX += 1;\r\n                }\r\n            }\r\n            break;\r\n\r\n        case LayoutMode.EVEN_R:\r\n            if ((offsetY & 1) !== 0) {\r\n                if ((newY & 1) === 0) {\r\n                    newX -= 1;\r\n                }\r\n            }\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            if ((offsetX & 1) !== 0) {\r\n                if ((newX & 1) == 0) {\r\n                    newY += 1;\r\n                }\r\n            }\r\n            break;\r\n        case LayoutMode.EVEN_Q:\r\n            if ((offsetX & 1) !== 0) {\r\n                if ((newX & 1) == 0) {\r\n                    newY -= 1;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    out.x = newX;\r\n    out.y = newY;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nexport let RingToTileXYArray = function (\r\n    hexagon: IHexagonBase,\r\n    centerTileXY: Vec2Type,\r\n    radius: number,\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    let centerCube = cr2cube(hexagon.mode, centerTileXY.x, centerTileXY.y, true);\r\n    let cx = centerCube.x,\r\n        cy = centerCube.y,\r\n        cz = centerCube.z;\r\n    let i: number,\r\n        j: number,\r\n        k: number;\r\n\r\n    k = radius;\r\n    for (i = 0; i >= -radius; i--) {\r\n        j = -i - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    i = -radius;\r\n    for (j = 1; j <= radius; j++) {\r\n        k = -i - j;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    j = radius;\r\n    for (k = -1; k >= -radius; k--) {\r\n        i = -j - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    k = -radius;\r\n    for (i = 1; i <= radius; i++) {\r\n        j = -i - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    i = radius;\r\n    for (j = -1; j >= -radius; j--) {\r\n        k = -i - j;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    j = -radius;\r\n    for (k = 1; k <= radius - 1; k++) {\r\n        i = -j - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n    return out;\r\n}", "import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nimport { Wrap } from '../../../utils/math/Wrap';\r\n\r\nexport let Rotate = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    dir: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    dir = Wrap(dir, 0, 5);\r\n    let cubeXYZ = cr2cube(hexagon.mode, srcTileXY.x, srcTileXY.y, true);\r\n    let newCubeX: number,\r\n        newCubeY: number,\r\n        newCubeZ: number;\r\n\r\n    switch (dir) {\r\n        case 1:\r\n            newCubeX = -cubeXYZ.z;\r\n            newCubeY = -cubeXYZ.x;\r\n            newCubeZ = -cubeXYZ.y;\r\n            break;\r\n        case 2:\r\n            newCubeX = cubeXYZ.y;\r\n            newCubeY = cubeXYZ.z;\r\n            newCubeZ = cubeXYZ.x;\r\n            break;\r\n        case 3:\r\n            newCubeX = -cubeXYZ.x;\r\n            newCubeY = -cubeXYZ.y;\r\n            newCubeZ = -cubeXYZ.z;\r\n            break;\r\n        case 4:\r\n            newCubeX = cubeXYZ.z;\r\n            newCubeY = cubeXYZ.x;\r\n            newCubeZ = cubeXYZ.y;\r\n            break;\r\n        case 5:\r\n            newCubeX = -cubeXYZ.y;\r\n            newCubeY = -cubeXYZ.z;\r\n            newCubeZ = -cubeXYZ.x;\r\n            break;\r\n        default:\r\n            newCubeX = cubeXYZ.x;\r\n            newCubeY = cubeXYZ.y;\r\n            newCubeZ = cubeXYZ.z;\r\n            break;\r\n    }\r\n\r\n    cube2cr(hexagon.mode, newCubeX, newCubeY, newCubeZ, out);\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };", "import { IGrid, Vec2Type } from '../IGrid';\r\nimport { HexagonBase } from './HexagonBase';\r\n\r\nimport { DirectionBetween } from './DirectionBetween';\r\nimport { DirectionNormalize } from '../utils/DirectionNormalize';\r\nimport { GetDistance } from './GetDistance';\r\nimport { GetGridPoints } from './GetGridPoints';\r\nimport { GetNeighborTileDirection } from './GetNeighborTileDirection';\r\nimport { GetNeighborTileXY } from './GetNeighborTileXY';\r\nimport { GetOppositeDirection } from './GetOppositeDirection';\r\nimport { GetTileXY } from './GetTileXY';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\nimport { GetWorldXY } from './GetWorldXY';\r\nimport { MirrorMode, MirrorModeString } from '../IGrid';\r\nimport { Mirror } from './Mirror';\r\nimport { Offset } from './Offset';\r\nimport { RingToTileXYArray } from './RingToTileXYArray';\r\nimport { Rotate } from './Rotate';\r\nimport { SaveOrigin, RestoreOrigin } from '../utils/SaveOrigin';\r\n\r\nexport class Hexagon extends HexagonBase implements IGrid {\r\n\r\n    _savedOriginX: number;\r\n    _savedOriginY: number;\r\n\r\n    get sides() {\r\n        return 6;\r\n    }\r\n\r\n    // Direction of neighbors\r\n    get allDirections() {\r\n        return ALLDIR;\r\n    }\r\n\r\n    // Board-match\r\n    get halfDirections() {\r\n        return HALFDIR;\r\n    }\r\n\r\n    directionBetween(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        round: boolean = true\r\n    ): number {\r\n\r\n        return DirectionBetween(this, tileA, tileB, round);\r\n    }\r\n\r\n    directionNormalize(\r\n        direction: number\r\n    ): number {\r\n\r\n        return DirectionNormalize(this, direction);\r\n    }\r\n\r\n    getDistance(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        roughMode: boolean = false\r\n    ): number {\r\n\r\n        return GetDistance(this, tileA, tileB, roughMode);\r\n    }\r\n\r\n    getGridPoints(\r\n        tileX: number | Vec2Type = 0,\r\n        tileY: number = 0,\r\n        out: Vec2Type[] | true = []\r\n    ): Vec2Type[] {\r\n\r\n        return GetGridPoints(this, tileX, tileY, out);\r\n    }\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: Vec2Type,\r\n        neighborTileXY: Vec2Type\r\n    ): number | null {\r\n\r\n        return GetNeighborTileDirection(this, srcTileXY, neighborTileXY);\r\n    }\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetNeighborTileXY(this, srcTileXY, direction, out);\r\n    }\r\n\r\n    getOppositeDirection(\r\n        tileX: number | Vec2Type,\r\n        tileY: number | undefined | null,\r\n        direction: number\r\n    ): number {\r\n\r\n        return GetOppositeDirection(this, tileX, tileY, direction);\r\n    }\r\n\r\n    getTileXY(\r\n        worldX: number | Vec2Type,\r\n        worldY?: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetTileXY(this, worldX, worldY, out);\r\n    }\r\n\r\n    getTileXYAtDirection(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        distance: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetTileXYAtDirection(this, srcTileXY, direction, distance, out);\r\n    }\r\n\r\n    getWorldXY(\r\n        tileX: number | Vec2Type,\r\n        tileY?: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetWorldXY(this, tileX, tileY, out);\r\n    }\r\n\r\n    mirror(\r\n        srcTileXY: Vec2Type,\r\n        mode: MirrorMode | MirrorModeString,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Mirror(this, srcTileXY, mode, out);\r\n    }\r\n\r\n    offset(\r\n        srcTileXY: Vec2Type,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Offset(this, srcTileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: Vec2Type,\r\n        radius: number,\r\n        out: Vec2Type[] = []\r\n    ): Vec2Type[] {\r\n\r\n        return RingToTileXYArray(this, centerTileXY, radius, out);\r\n    }\r\n\r\n    rotate(srcTileXY: Vec2Type,\r\n        dir: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Rotate(this, srcTileXY, dir, out);\r\n    }\r\n\r\n    restoreOrigin(): this {\r\n\r\n        RestoreOrigin(this);\r\n        return this\r\n    }\r\n\r\n    saveOrigin(): this {\r\n\r\n        SaveOrigin(this);\r\n        return this;\r\n    }\r\n}\r\n\r\nconst ALLDIR = [0, 1, 2, 3, 4, 5];\r\nconst HALFDIR = [0, 1, 2];", "import { Quad } from './quad/Quad';\r\nimport { Hexagon } from './hexagon/Hexagon';\r\n\r\nexport {\r\n    Quad,\r\n    Hexagon\r\n};", "export enum PathMode {\r\n    'random' = 0,\r\n    'diagonal' = 1,\r\n    'straight' = 2,\r\n    'line' = 3,\r\n    'astar' = 10,\r\n    'astar-random' = 11,\r\n    'astar-line' = 12\r\n}\r\n\r\nexport type PathModeString = 'random' | 'diagonal' | 'straight' | 'line' |\r\n    'astar' | 'astar-line' | 'astar-random';\r\n\r\nexport let IsAStarMode = function (pathMode: PathMode) {\r\n    return (pathMode === PathMode.astar) ||\r\n        (pathMode === PathMode['astar-line']) ||\r\n        (pathMode === PathMode['astar-random']);\r\n}", "import { INodeBase } from '../INodeBase';\r\nexport type CreateNodeCallbackType = () => INodeBase;", "export type CostValueType = number | null;", "export const BLOCKER = null;\r\nexport const INFINITY = undefined;", "import { PathMode, PathModeString } from './types/PathMode';\r\nexport { PathMode, PathModeString };\r\n\r\nimport { CreateNodeCallbackType } from './types/CreateNodeCallbackType';\r\nexport { CreateNodeCallbackType };\r\n\r\nimport { INodeBase } from './INodeBase';\r\n\r\nimport { CostValueType } from './types/CostValueType';\r\nexport { CostValueType };\r\nimport { BLOCKER, INFINITY } from './Const'\r\nexport { BLOCKER, INFINITY };\r\n\r\nimport { INodeManager } from './INodeManager';\r\n\r\nexport interface IAStar {\r\n    pathMode: PathMode;\r\n    nodeManager: INodeManager;\r\n\r\n    destroy(): void;\r\n\r\n    setPathMode(\r\n        mode: PathMode | PathModeString\r\n    ): this;\r\n\r\n    setWeight(\r\n        weight: number\r\n    ): this;\r\n\r\n    search(\r\n        startNodeKey: any,\r\n        endNodeKey: any,\r\n        movingPoints?: number\r\n    ): this;\r\n\r\n    getAllNodes(): Map<any, INodeBase>;\r\n\r\n    getNode(key: any): INodeBase;\r\n\r\n    getClosestNode(): INodeBase;\r\n\r\n    getNodePath(\r\n        startNodeKey: any,\r\n        endNodeKey: any\r\n    ): INodeBase[];\r\n}", "import { XYZType } from '../types';\r\nimport { IBaseBoard } from '../board/IBaseBoard';\r\nimport {\r\n    IAStar,\r\n    PathMode, PathModeString,\r\n    CostValueType, BLOCKER\r\n} from '../../utils/astar/IAStar';\r\n\r\nexport { PathMode, PathModeString };\r\nexport { CostValueType, BLOCKER };\r\nexport type CostNodeType = {\r\n    x: number,\r\n    y: number,\r\n    cost: number\r\n};\r\nexport type GetCostCallbackType = (currNode: CostNodeType, prevNode: CostNodeType, pathFinder: IPathFinder) => CostValueType;\r\n\r\nexport type SearchResultType = {\r\n    x: number,\r\n    y: number,\r\n    cost: number\r\n}[];\r\n\r\nexport interface IConfig {\r\n    board?: IBaseBoard;\r\n\r\n    cost?: number;\r\n    costCallback?: GetCostCallbackType;\r\n    costCallbackScope?: any;\r\n\r\n    occupiedTest?: boolean;\r\n    blockerTest?: boolean;\r\n    edgeBlockerTest?: boolean;\r\n\r\n    pathMode?: PathMode | PathModeString;\r\n\r\n    cacheCost?: boolean;\r\n\r\n    weight?: number;\r\n\r\n    shuffleNeighbors?: boolean;\r\n\r\n}\r\n\r\nexport interface IPathFinder {\r\n    board: IBaseBoard;\r\n    astar: IAStar;\r\n\r\n    constCost: number;\r\n    costCallback: GetCostCallbackType | null;\r\n    costCallbackScope: any;\r\n    pathMode: PathMode;\r\n    occupiedTest: boolean;\r\n    blockerTest: boolean;\r\n    edgeBlockerTest: boolean;\r\n\r\n    startTileXYZ: XYZType;\r\n    cacheCost: boolean;\r\n    weight: number;\r\n    shuffleNeighbors: boolean;\r\n\r\n    BLOCKER: CostValueType;\r\n\r\n    getCost(\r\n        currNode: CostNodeType,\r\n        prevNode: CostNodeType\r\n    ): CostValueType;\r\n}", "import { CreateNodeCallbackType } from './types/CreateNodeCallbackType';\r\nimport { INodeBase } from './INodeBase';\r\nimport { Stack } from '../../utils/struct/Stack';\r\n\r\nexport class NodeManager {\r\n    createNodeCallback: CreateNodeCallbackType;\r\n    weight: number;\r\n    nodePool: Stack;\r\n    nodes: Map<any, INodeBase>;\r\n    sn: number;\r\n    closestNode: INodeBase | null;\r\n\r\n    constructor(\r\n        createNodeCallback: CreateNodeCallbackType\r\n    ) {\r\n        this.createNodeCallback = createNodeCallback;\r\n        this.nodePool = new Stack();\r\n        this.nodes = new Map();\r\n        this.sn = 0;\r\n    }\r\n\r\n    destroy() {\r\n\r\n        this.freeAllNodes();\r\n        this.nodePool.destroy();\r\n    }\r\n\r\n    getNode(\r\n        key: any,\r\n        createNode: boolean = false\r\n    ): INodeBase | null {\r\n\r\n        if (!this.nodes.has(key)) {\r\n            if (!createNode) {\r\n                return null;\r\n            }\r\n\r\n            let node: INodeBase = this.nodePool.pop();\r\n            if (node === null) {\r\n                node = this.createNodeCallback();\r\n                node.manager = this;\r\n            }\r\n            node.sn = this.sn;\r\n            node.reset(key);\r\n            this.nodes.set(key, node);\r\n        }\r\n        this.sn++;\r\n        let node = this.nodes.get(key);\r\n        node.sn = this.sn;\r\n        return node;\r\n    }\r\n\r\n    freeAllNodes(): this {\r\n\r\n        let pool = this.nodePool;\r\n        for (const [key, node] of this.nodes) {\r\n            node.shutdown();\r\n            pool.push(node);\r\n        }\r\n        this.nodes.clear();\r\n        this.sn = 0;\r\n        return this;\r\n    }\r\n\r\n    getAllNodes(): Map<any, INodeBase> {\r\n\r\n        return this.nodes;\r\n    }\r\n}", "export class BinaryHeap {\r\n    content: object[];\r\n    scoreFunction: (node: object) => number;\r\n\r\n    constructor(scoreFunction) {\r\n        this.content = [];\r\n        this.scoreFunction = scoreFunction;\r\n    }\r\n\r\n    clear(): void {\r\n        this.content.length = 0;\r\n    }\r\n\r\n    push(element: object): void {\r\n        // Add the new element to the end of the array.\r\n        this.content.push(element);\r\n\r\n        // Allow it to sink down.\r\n        this.sinkDown(this.content.length - 1);\r\n    }\r\n\r\n    pop(): object {\r\n        // Store the first element so we can return it later.\r\n        let result = this.content[0];\r\n        // Get the element at the end of the array.\r\n        let end = this.content.pop();\r\n        // If there are any elements left, put the end element at the\r\n        // start, and let it bubble up.\r\n        if (this.content.length > 0) {\r\n            this.content[0] = end;\r\n            this.bubbleUp(0);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    remove(node: object) {\r\n\r\n        let i = this.content.indexOf(node);\r\n\r\n        // When it is found, the process seen in 'pop' is repeated\r\n        // to fill up the hole.\r\n        let end = this.content.pop();\r\n\r\n        if (i !== this.content.length - 1) {\r\n            this.content[i] = end;\r\n\r\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n                this.sinkDown(i);\r\n            } else {\r\n                this.bubbleUp(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    get size(): number {\r\n        return this.content.length;\r\n    }\r\n\r\n    rescoreElement(node: object) {\r\n\r\n        this.sinkDown(this.content.indexOf(node));\r\n    }\r\n\r\n    sinkDown(n: number): void {\r\n\r\n        // Fetch the element that has to be sunk.\r\n        let element = this.content[n];\r\n\r\n        // When at 0, an element can not sink any further.\r\n        while (n > 0) {\r\n\r\n            // Compute the parent element's index, and fetch it.\r\n            let parentN = ((n + 1) >> 1) - 1,\r\n                parent = this.content[parentN];\r\n            // Swap the elements if the parent is greater.\r\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n                this.content[parentN] = element;\r\n                this.content[n] = parent;\r\n                // Update 'n' to continue at the new position.\r\n                n = parentN;\r\n            }\r\n            // Found a parent that is less, no need to sink any further.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    bubbleUp(n: number): void {\r\n\r\n        // Look up the target element and its score.\r\n        let length = this.content.length,\r\n            element: object = this.content[n],\r\n            elemScore: number = this.scoreFunction(element);\r\n\r\n        while (true) {\r\n            // Compute the indices of the child elements.\r\n            let child2N = (n + 1) << 1,\r\n                child1N = child2N - 1;\r\n            // This is used to store the new position of the element, if any.\r\n            let swap: number = null,\r\n                child1Score: number;\r\n            // If the first child exists (is inside the array)...\r\n            if (child1N < length) {\r\n                // Look it up and compute its score.\r\n                let child1 = this.content[child1N];\r\n                child1Score = this.scoreFunction(child1);\r\n\r\n                // If the score is less than our element's, we need to swap.\r\n                if (child1Score < elemScore) {\r\n                    swap = child1N;\r\n                }\r\n            }\r\n\r\n            // Do the same checks for the other child.\r\n            if (child2N < length) {\r\n                let child2 = this.content[child2N],\r\n                    child2Score = this.scoreFunction(child2);\r\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n                    swap = child2N;\r\n                }\r\n            }\r\n\r\n            // If the element needs to be moved, swap it, and continue.\r\n            if (swap !== null) {\r\n                this.content[n] = this.content[swap];\r\n                this.content[swap] = element;\r\n                n = swap;\r\n            }\r\n            // Otherwise, we are done.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}", "/* \r\n\r\njavascript-astar 0.3.0\r\nhttp://github.com/bgrins/javascript-astar\r\nFreely distributable under the MIT License.\r\nImplements the astar search algorithm in javascript using a Binary Heap.\r\nIncludes Binary Heap (with modifications) from Marijn Haverbeke.\r\nhttp://eloquentjavascript.net/appendix2.html\r\n\r\n*/\r\n\r\nimport { IAStar } from './IAstar';\r\nimport { PathMode, IsAStarMode } from './types/PathMode';\r\nimport { CostValueType } from './types/CostValueType';\r\nimport { BLOCKER, INFINITY } from './Const';\r\nimport { INodeBase } from './INodeBase';\r\nimport { BinaryHeap } from '../struct/BinaryHeap';\r\n\r\nlet gOpenHeap = new BinaryHeap((node: INodeBase) => node.f);\r\n\r\nexport let Search = function (\r\n    astar: IAStar,\r\n    startNodeKey: any,\r\n    endNodeKey: any,\r\n    movingPoints?: number\r\n): void {\r\n\r\n    const isPathSearch = (endNodeKey !== null);\r\n    const isAStartMode = IsAStarMode(astar.pathMode);\r\n    const isShortestPathMode = isPathSearch && (!isAStartMode);\r\n    const astarMode = (isPathSearch && isAStartMode) ? astar.pathMode : null;\r\n\r\n    let nodeManager = astar.nodeManager;\r\n    nodeManager.freeAllNodes();\r\n\r\n    let startNode = nodeManager.getNode(startNodeKey, true);\r\n    let endNode = (isPathSearch) ? nodeManager.getNode(endNodeKey, true) : null;\r\n    startNode.h = startNode.heuristic(endNode, astarMode);\r\n\r\n    let closestNode: INodeBase = null;\r\n    if (isPathSearch) {\r\n        closestNode = startNode;\r\n        closestNode.closerH = closestNode.h || closestNode.heuristic(endNode, PathMode.astar);\r\n    }\r\n\r\n    gOpenHeap.push(startNode);\r\n    while (gOpenHeap.size > 0) {\r\n        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n        let currNode = gOpenHeap.pop() as INodeBase;\r\n        // console.log(currNode.key);\r\n\r\n        // End case -- result has been found, return the traced path.\r\n        if (isPathSearch && (currNode === endNode)) {\r\n            closestNode = endNode;\r\n            break;\r\n        }\r\n\r\n        // Normal case -- move currNode from open to closed, process each of its next-nodes.\r\n        currNode.closed = true;\r\n\r\n        // Find all next-nodes for the current node.\r\n        let nextNodes: INodeBase[] = currNode.getNextNodes();\r\n        let nextNode: INodeBase,\r\n            nextNodeCost: CostValueType;\r\n        for (let i = 0, cnt = nextNodes.length; i < cnt; ++i) {\r\n            nextNode = nextNodes[i];\r\n            nextNodeCost = nextNode.getCost(currNode);\r\n            if (nextNode.closed || (nextNodeCost === BLOCKER)) {\r\n                // Not a valid node to process, skip to next-node.\r\n                continue;\r\n            }\r\n\r\n            // The g score is the shortest distance from start to current node.\r\n            // We need to check if the path we have arrived at this next-node is the shortest one we have seen yet.\r\n            let gScore = currNode.g + nextNodeCost,\r\n                beenVisited = nextNode.visited;\r\n\r\n            if ((movingPoints !== INFINITY) && (gScore > movingPoints)) {\r\n                continue;\r\n            }\r\n\r\n            if ((!beenVisited) || (gScore < nextNode.g)) {\r\n\r\n                // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n                nextNode.visited = true;\r\n                nextNode.prevNodes.length = 0;\r\n                nextNode.prevNodes.push(currNode);\r\n                if (nextNode.h === undefined) {\r\n                    nextNode.h = nextNode.heuristic(endNode, astarMode, startNode);\r\n                }\r\n                nextNode.g = gScore;\r\n                nextNode.f = nextNode.g + nextNode.h;\r\n\r\n                // Nearest node\r\n                if (isPathSearch) {\r\n                    // If the next node is closer than the current closestNode or if it's equally close but has\r\n                    // a cheaper path than the current closest node then it becomes the closest node\r\n                    if (nextNode.closerH === undefined) {\r\n                        nextNode.closerH = nextNode.h || nextNode.heuristic(endNode, PathMode.astar);\r\n                    }\r\n                    if ((nextNode.closerH < closestNode.closerH) ||\r\n                        ((nextNode.closerH === closestNode.closerH) && (nextNode.g < closestNode.g))) {\r\n                        closestNode = nextNode;\r\n                    }\r\n                }\r\n                // Nearest node\r\n\r\n                if (!beenVisited) {\r\n                    // Pushing to heap will put it in proper place based on the 'f' value.\r\n                    gOpenHeap.push(nextNode);\r\n                } else {\r\n                    // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n                    gOpenHeap.rescoreElement(nextNode);\r\n                }\r\n            } else if (isShortestPathMode && (gScore == nextNode.g)) {\r\n\r\n                nextNode.prevNodes.push(currNode);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    nodeManager.closestNode = closestNode;\r\n    gOpenHeap.clear();\r\n}", "import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\n\r\nexport let GetAStarNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        currNode = currNode.prevNodes[0];\r\n    }\r\n\r\n    return out.reverse();\r\n}", "import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { GetRandomItem } from '../../array/GetRandom';\r\n\r\nexport let GetRandomNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if (currNode.prevNodes.length === 1) {\r\n            currNode = currNode.prevNodes[0];\r\n        } else {\r\n            currNode = GetRandomItem(currNode.prevNodes);\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}", "import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\n\r\nexport let GetLineNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    let targetAngle = endNode.angleTo(startNode);\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if (currNode.prevNodes.length === 1) {\r\n            currNode = currNode.prevNodes[0];\r\n        } else {\r\n            let minDeltaAngle = Infinity;\r\n            for (let i = 1, cnt = currNode.prevNodes.length; i < cnt; i++) {\r\n                let prevNode = currNode.prevNodes[i];\r\n                let deltaAngle = Math.abs(endNode.angleTo(prevNode) - targetAngle);\r\n                if (deltaAngle < minDeltaAngle) {\r\n                    minDeltaAngle = deltaAngle;\r\n                    currNode = prevNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}", "import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { INodeBase } from '../INodeBase';\r\n\r\nexport let GetDiagonalPath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    let currLogicDir: number;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if ((currNode.prevNodes.length === 1) || (currLogicDir === undefined)) {\r\n            let prevNode = currNode.prevNodes[0];\r\n            currLogicDir = prevNode.logicDirTo(currNode);\r\n            currNode = prevNode;\r\n        } else {\r\n            let prevNode: INodeBase;\r\n            let prevLogicDir: number;\r\n            for (let i = 0, cnt = currNode.prevNodes.length; i < cnt; i++) {\r\n                prevNode = currNode.prevNodes[i];\r\n                prevLogicDir = prevNode.logicDirTo(currNode);\r\n                if (prevLogicDir !== currLogicDir) {\r\n                    break;\r\n                }\r\n            }\r\n            currLogicDir = prevLogicDir;\r\n            currNode = prevNode;\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}", "import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { INodeBase } from '../INodeBase';\r\n\r\nexport let GetStraightNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    let currLogicDir: number;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if ((currNode.prevNodes.length === 1) || (currLogicDir === undefined)) {\r\n            let prevNode = currNode.prevNodes[0];\r\n            currLogicDir = prevNode.logicDirTo(currNode);\r\n            currNode = prevNode;\r\n        } else {\r\n            let prevNode: INodeBase;\r\n            let prevLogicDir: number;\r\n            for (let i = 0, cnt = currNode.prevNodes.length; i < cnt; i++) {\r\n                prevNode = currNode.prevNodes[i];\r\n                prevLogicDir = prevNode.logicDirTo(currNode);\r\n                if (prevLogicDir === currLogicDir) {\r\n                    break;\r\n                }\r\n            }\r\n            currLogicDir = prevLogicDir;\r\n            currNode = prevNode;\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}", "import { IAStar } from '../IAStar';\r\nimport { INodeBase } from '../INodeBase';\r\nimport { PathMode } from '../types/PathMode';\r\nimport { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { GetAStarNodePath } from './GetAStarNodePath';\r\nimport { GetRandomNodePath } from './GetRandomNodePath';\r\nimport { GetLineNodePath } from './GetLineNodePath';\r\nimport { GetDiagonalPath } from './GetDiagonalPath';\r\nimport { GetStraightNodePath } from './GetStraightNodePath';\r\n\r\nexport let GetNodePath = function (\r\n    astar: IAStar,\r\n    startNodeKey: any,\r\n    endNodeKey: any\r\n): INodeBase[] {\r\n\r\n    let nodeManager = astar.nodeManager;\r\n    let endNode = nodeManager.getNode(endNodeKey);\r\n    let path: INodeBase[] = [];\r\n    if (endNode === null) {\r\n        return path;\r\n    }\r\n\r\n    let startNode = nodeManager.getNode(startNodeKey);\r\n    return GetNodePathCallbacks[astar.pathMode](startNode, endNode, path);\r\n}\r\n\r\nlet GetNodePathCallbacks: { [mode: number]: GetNodePathCallbackType } = {};\r\nGetNodePathCallbacks[PathMode.astar] = GetAStarNodePath;\r\nGetNodePathCallbacks[PathMode['astar-line']] = GetAStarNodePath;\r\nGetNodePathCallbacks[PathMode['astar-random']] = GetAStarNodePath;\r\nGetNodePathCallbacks[PathMode.random] = GetRandomNodePath;\r\nGetNodePathCallbacks[PathMode.line] = GetLineNodePath;\r\nGetNodePathCallbacks[PathMode.diagonal] = GetDiagonalPath;\r\nGetNodePathCallbacks[PathMode.straight] = GetStraightNodePath;", "import {\r\n    PathMode, PathModeString,\r\n    CreateNodeCallbackType\r\n} from './IAStar';\r\n\r\nimport { INodeBase } from './INodeBase';\r\nimport { INodeManager } from './INodeManager';\r\nimport { NodeManager } from './NodeManager';\r\nimport { Search } from './Search';\r\nimport { GetNodePath } from './getnodepath/GetNodePath';\r\n\r\nexport class AStar {\r\n    pathMode: PathMode;\r\n    nodeManager: INodeManager;\r\n\r\n    constructor(\r\n        createNodeCallback: CreateNodeCallbackType\r\n    ) {\r\n\r\n        this.nodeManager = new NodeManager(createNodeCallback);\r\n    }\r\n\r\n    destroy() {\r\n\r\n        this.nodeManager.destroy();\r\n    }\r\n\r\n    setPathMode(\r\n        mode: PathMode | PathModeString\r\n    ): this {\r\n\r\n        if (typeof (mode) === 'string') {\r\n            mode = PathMode[mode];\r\n        }\r\n        this.pathMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setWeight(\r\n        weight: number\r\n    ): this {\r\n\r\n        this.nodeManager.weight = weight;\r\n        return this;\r\n    }\r\n\r\n    search(\r\n        startNodeKey: any,\r\n        endNodeKey: any,\r\n        movingPoints?: number\r\n    ): this {\r\n\r\n        Search(this, startNodeKey, endNodeKey, movingPoints);\r\n        return this;\r\n    }\r\n\r\n    getAllNodes(): Map<any, INodeBase> {\r\n\r\n        return this.nodeManager.getAllNodes();\r\n    }\r\n\r\n    getNode(key: any): INodeBase {\r\n\r\n        return this.nodeManager.getNode(key);\r\n    }\r\n\r\n    getClosestNode(): INodeBase | null {\r\n\r\n        return this.nodeManager.closestNode;\r\n    }\r\n\r\n    getNodePath(\r\n        startNodeKey: any,\r\n        endNodeKey: any\r\n    ): INodeBase[] {\r\n\r\n        return GetNodePath(this, startNodeKey, endNodeKey);\r\n    }\r\n}", "import { PathMode } from './types/PathMode';\r\nimport { CostValueType } from './types/CostValueType';\r\nimport { BLOCKER } from './Const';\r\nimport { INodeBase } from './INodeBase';\r\nimport { INodeManager } from './INodeManager';\r\n\r\nexport abstract class NodeBase {\r\n    manager: INodeManager;\r\n\r\n    f: number;\r\n    g: number;\r\n    h: number;\r\n    closerH: number;\r\n\r\n    visited: boolean;\r\n    closed: boolean;\r\n\r\n    prevNodes: INodeBase[];\r\n    key: any; // string, number or an object\r\n    sn: number; // For sorting by created order\r\n\r\n    constructor() {\r\n\r\n        this.prevNodes = [];\r\n    }\r\n\r\n    shutdown(): void {\r\n        this.key = undefined;\r\n        this.prevNodes.length = 0;\r\n    }\r\n\r\n    destroy(): void {\r\n        this.shutdown();\r\n    }\r\n\r\n    // Override\r\n    reset(key: any): void {\r\n        this.key = key;\r\n        this.f = 0;\r\n        this.g = 0; // path cost\r\n        this.h = undefined;\r\n        this.closerH = undefined;\r\n        this.visited = false;\r\n        this.closed = false;\r\n    }\r\n\r\n    heuristic(\r\n        endNode: INodeBase,\r\n        astarMode: PathMode | null,\r\n        baseNode?: INodeBase,\r\n    ): number {\r\n\r\n        if (astarMode === null) {\r\n            return 0;\r\n        }\r\n\r\n        let h: number;\r\n        let dist = this.distanceTo(endNode) * this.manager.weight;\r\n\r\n        switch (astarMode) {\r\n            case PathMode.astar:\r\n                h = dist;\r\n                break;\r\n            case PathMode['astar-line']:\r\n                if (baseNode !== undefined) {\r\n                    let deltaAngle = endNode.angleTo(baseNode) - this.angleTo(baseNode);\r\n                    h = dist + Math.abs(deltaAngle);\r\n                } else {\r\n                    h = dist;\r\n                }\r\n            case PathMode['astar-random']:\r\n                h = dist + Math.random();\r\n                break;\r\n            default:\r\n                h = dist;\r\n                break;\r\n        }\r\n        return h;\r\n    }\r\n\r\n    // Override\r\n    getNextNodes(): INodeBase[] {\r\n\r\n        return [];\r\n    }\r\n\r\n    // Override\r\n    getCost(\r\n        preNode: INodeBase\r\n    ): CostValueType {\r\n\r\n        return BLOCKER;\r\n    }\r\n\r\n    // Override\r\n    distanceTo(\r\n        node: INodeBase\r\n    ): number {\r\n\r\n        return 0;\r\n    }\r\n\r\n    // Override\r\n    angleTo(\r\n        node: INodeBase\r\n    ): number {\r\n\r\n        return 0;\r\n    }\r\n\r\n    // Override\r\n    logicDirTo(\r\n        node: INodeBase\r\n    ): number {\r\n\r\n        return 0;\r\n    }\r\n\r\n    getNode(\r\n        key: any,\r\n        createNode: boolean = false\r\n    ): INodeBase {\r\n\r\n        return this.manager.getNode(key, createNode);\r\n    }\r\n}", "export let Shuffle = function (array: any[]) {\r\n\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        let j = Math.floor(Math.random() * (i + 1));\r\n        let temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n\r\n    return array;\r\n};\r\n", "import { Vec2Type } from '../types';\r\n\r\nexport let XYToKey = function (x: number, y: number) {\r\n    return `${x}|${y}`;\r\n}\r\n\r\nexport let KeyToXY = function (key: string,\r\n    out?: Vec2Type\r\n): Vec2Type {\r\n\r\n    let xy = key.split('|');\r\n    if (out === undefined) {\r\n        out = globXY;\r\n    }\r\n    out.x = parseInt(xy[0]);\r\n    out.y = parseInt(xy[1]);\r\n    return out;\r\n}\r\n\r\nlet globXY: Vec2Type = { x: 0, y: 0 }", "import { IAStarNode } from './IAStarNode';\r\nimport { PathMode, CostValueType } from '../../../utils/astar/IAstar';\r\nimport { NodeBase } from '../../../utils/astar/NodeBase';\r\nimport { IPathFinder } from '../IPathFinder';\r\nimport { Shuffle } from '../../../utils/array/Shuffle';\r\nimport { XYZType } from '../../types';\r\nimport { XYToKey, KeyToXY } from '../../utils/StringKey';\r\nimport { Between as AngleBetween } from '../../../utils/math/angle/Between';\r\nimport { Nieghbors, TileXY, WorldXY } from '../../board';\r\n\r\nexport class AStarNode extends NodeBase {\r\n    pathFinder: IPathFinder;\r\n    isTileXYZ = true;\r\n\r\n    x: number;\r\n    y: number;\r\n    cost: number;\r\n    _px: number; // For worldX\r\n    _py: number; // For worldY\r\n\r\n    constructor(pathFinder: IPathFinder) {\r\n\r\n        super();\r\n        this.pathFinder = pathFinder;\r\n    }\r\n\r\n    reset(\r\n        key: string\r\n    ) {\r\n\r\n        super.reset(key);\r\n\r\n        this.key = key;\r\n        KeyToXY(key, this);\r\n        this._px = undefined;\r\n        this._py = undefined;\r\n        this.cost = undefined; // cost cache\r\n    }\r\n\r\n    getNextNodes(\r\n\r\n    ): IAStarNode[] {\r\n\r\n        let neighborsTileXY = Nieghbors.GetNeighborTileXY(this.board, this) as XYZType[];\r\n        if (this.pathFinder.shuffleNeighbors) {\r\n            Shuffle(neighborsTileXY);\r\n        }\r\n\r\n        let neighborNodes = [];\r\n        neighborsTileXY.forEach((tileXY) => {\r\n            let node = this.getNode(XYToKey(tileXY.x, tileXY.y), true);\r\n            neighborNodes.push(node);\r\n        })\r\n        return neighborNodes;\r\n    }\r\n\r\n    getCost(\r\n        preNode: IAStarNode\r\n    ): CostValueType {\r\n\r\n        if (this.pathFinder.cacheCost) {\r\n            if (this.cost === undefined) {\r\n                this.cost = this.pathFinder.getCost(this, preNode);\r\n            }\r\n        } else {\r\n            this.cost = this.pathFinder.getCost(this, preNode);\r\n        }\r\n        return this.cost;\r\n    }\r\n\r\n    distanceTo(\r\n        node: IAStarNode\r\n    ): number {\r\n\r\n        return TileXY.GetDistance(this.board, this, node, true);\r\n    }\r\n\r\n    angleTo(\r\n        node: IAStarNode\r\n    ): number {\r\n\r\n        return AngleBetween(this.worldX, this.wroldY, node.worldX, node.worldX);\r\n    }\r\n\r\n    logicDirTo(\r\n        node: IAStarNode\r\n    ): number {\r\n\r\n        return Nieghbors.GetNeighborTileDirection(this.board, this, node);\r\n    }\r\n\r\n    get board() {\r\n\r\n        return this.pathFinder.board;\r\n    }\r\n\r\n    get worldX() {\r\n        if (this._px === undefined) {\r\n            let worldXY = WorldXY.TileXYToWorldXY(this.board, this.x, this.y, true);\r\n            this._px = worldXY.x;\r\n            this._py = worldXY.y;\r\n        }\r\n        return this._px;\r\n    }\r\n\r\n    get wroldY() {\r\n        if (this._py === undefined) {\r\n            let worldXY = WorldXY.TileXYToWorldXY(this.board, this.x, this.y, true);\r\n            this._px = worldXY.x;\r\n            this._py = worldXY.y;\r\n        }\r\n        return this._py;\r\n    }\r\n}", "import { IPathFinder } from '../IPathFinder';\r\nimport { IAStar } from '../../../utils/astar/IAStar';\r\nimport { AStar } from '../../../utils/astar/AStar';\r\nimport { AStarNode } from './AStarNode';\r\n\r\nexport let CreateAStar = function (\r\n    pathFinder: IPathFinder\r\n): IAStar {\r\n\r\n    let CreateNodeCallback = function () {\r\n        return new AStarNode(pathFinder);\r\n    }\r\n    return new AStar(CreateNodeCallback);\r\n}", "import {\r\n    IPathFinder,\r\n    CostNodeType, CostValueType, BLOCKER\r\n} from './IPathFinder';\r\nimport { TileXY, Blocker } from '../board';\r\n\r\nexport let GetCost = function (\r\n    pathFinder: IPathFinder,\r\n    currNode: CostNodeType,\r\n    prevNode: CostNodeType\r\n): CostValueType {\r\n\r\n    let board = pathFinder.board;\r\n    // Occupied test\r\n    if (pathFinder.occupiedTest) {\r\n        if (TileXY.Contains(board, currNode.x, currNode.y, pathFinder.startTileXYZ.z)) {\r\n            return BLOCKER;\r\n        }\r\n    }\r\n    // Blocker test\r\n    if (pathFinder.blockerTest) {\r\n        if (Blocker.HasBlocker(board, currNode.x, currNode.y)) {\r\n            return BLOCKER;\r\n        }\r\n    }\r\n    // Edge-blocker test\r\n    if (pathFinder.edgeBlockerTest) {\r\n        // TODO\r\n    }\r\n\r\n    let callback = pathFinder.costCallback;\r\n    if (callback) {\r\n        let scope = pathFinder.costCallbackScope;\r\n        let cost: CostValueType;\r\n        if (scope) {\r\n            cost = callback.call(scope, currNode, prevNode, pathFinder);\r\n        } else {\r\n            cost = callback(currNode, prevNode, pathFinder);\r\n        }\r\n        if (cost === undefined) {\r\n            cost = BLOCKER;\r\n        }\r\n        return cost;\r\n    } else {\r\n        return pathFinder.constCost;\r\n    }\r\n}", "import { XYType } from '../types';\r\n\r\n\r\nexport let CopyTileXY = function (\r\n    src: XYType,\r\n    out: XYType = { x: 0, y: 0 }): XYType {\r\n\r\n    out.x = src.x;\r\n    out.y = src.y;\r\n    return out;\r\n}", "import { XYZType } from '../types';\r\n\r\n\r\nexport let CopyTileXYZ = function (\r\n    src: XYZType,\r\n    out: XYZType = { x: 0, y: 0, z: 0 }): XYZType {\r\n\r\n    out.x = src.x;\r\n    out.y = src.y;\r\n    out.z = src.z;\r\n    return out;\r\n}", "export let IsChess = function (obj) {\r\n    if (typeof (obj) === 'object') {\r\n        return obj.hasOwnProperty('rexChess');\r\n    } else {\r\n        return false;\r\n    }\r\n}", "import { CopyTileXY } from './CopyTileXY';\r\nimport { CopyTileXYZ } from './CopyTileXYZ';\r\nimport { IsChess } from './IsChess';\r\nimport { IsTileXYZ } from './IsTileXYZ';\r\n\r\nexport {\r\n    CopyTileXY,\r\n    CopyTileXYZ,\r\n    IsChess,\r\n    IsTileXYZ\r\n}", "import { IPathFinder, SearchResultType } from './IPathFinder';\r\nimport { IChess, XYZType } from '../types';\r\nimport { IsChess, IsTileXYZ } from '../utils';\r\nimport { XYToKey } from '../utils/StringKey';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\nimport { Chess, TileXY } from '../board';\r\nimport { CopyTileXYZ } from '../utils/CopyTileXYZ';\r\n\r\nexport let FindArea = function (\r\n    pathFinder: IPathFinder,\r\n    startChess: IChess | XYZType,\r\n    movingPoints?: number | undefined,\r\n    out: SearchResultType = []\r\n): SearchResultType {\r\n\r\n    // Negative moving points\r\n    if ((movingPoints !== undefined) && (movingPoints <= 0)) {\r\n        return out;\r\n    }\r\n    if (IsChess(startChess)) {\r\n        pathFinder.board = (startChess as IChess).rexChess.board;\r\n    } else if (!IsTileXYZ(startChess)) { // Not a chess, neither tileXYZ\r\n        return out;\r\n    }\r\n\r\n    let board = pathFinder.board;\r\n    let astar = pathFinder.astar;\r\n    let startTileXYZ = TileXY.ChessToTileXYZ(board, startChess) as XYZType,\r\n        startTileX = startTileXYZ.x,\r\n        startTileY = startTileXYZ.y;\r\n    CopyTileXYZ(startTileXYZ, pathFinder.startTileXYZ);\r\n    let startNodeKey = XYToKey(startTileX, startTileY);\r\n    astar.search(startNodeKey, null, movingPoints);\r\n\r\n    let nodesMap = astar.getAllNodes() as Map<string, IAStarNode>,\r\n        nodesList: IAStarNode[] = [];\r\n    for (const [key, node] of nodesMap) {\r\n        // Not include start node\r\n        if ((node.x === startTileX) && (node.y === startTileY)) {\r\n            continue;\r\n        }\r\n\r\n        if (!node.closed) {\r\n            continue;\r\n        }\r\n        nodesList.push(node);\r\n    }\r\n    // Sort by sn (creating order)\r\n    nodesList.sort(function (nodeA, nodeB) {\r\n        let snA = nodeA.sn;\r\n        let snB = nodeB.sn;\r\n        return (snA > snB) ? 1 :\r\n            (snA < snB) ? -1 :\r\n                0;\r\n    });\r\n    nodesList.forEach(function (node) {\r\n        out.push({\r\n            x: node.x,\r\n            y: node.y,\r\n            cost: node.g\r\n        });\r\n    })\r\n    return out;\r\n}", "import {\r\n    IPathFinder,\r\n    SearchResultType\r\n} from './IPathFinder';\r\nimport { XYType, IChess } from '../types';\r\nimport { XYToKey } from '../utils/StringKey';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\nimport { TileXY } from '../board';\r\n\r\nexport let GetPath = function (\r\n    pathFinder: IPathFinder,\r\n    endChess: IChess | XYType,\r\n    out: SearchResultType = []\r\n): SearchResultType {\r\n\r\n    let board = pathFinder.board;\r\n    let endTileXY: XYType = TileXY.ChessToTileXYZ(board, endChess);\r\n    let startTileXYZ = pathFinder.startTileXYZ;\r\n    let nodesList = pathFinder.astar\r\n        .setPathMode(pathFinder.pathMode)\r\n        .getNodePath(\r\n            XYToKey(startTileXYZ.x, startTileXYZ.y),\r\n            XYToKey(endTileXY.x, endTileXY.y)\r\n        ) as IAStarNode[];\r\n    nodesList.forEach(function (node) {\r\n        out.push({\r\n            x: node.x,\r\n            y: node.y,\r\n            cost: node.g\r\n        });\r\n    })\r\n    return out;\r\n}", "import {\r\n    IPathFinder,\r\n    SearchResultType\r\n} from './IPathFinder';\r\nimport { IChess, XYZType, XYType } from '../types';\r\nimport { IsChess, IsTileXYZ } from '../utils';\r\nimport { XYToKey } from '../utils/StringKey';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\nimport { GetPath } from './GetPath'\r\nimport { TileXY } from '../board';\r\nimport { CopyTileXYZ } from '../utils/CopyTileXYZ';\r\n\r\nexport let FindPath = function (\r\n    pathFinder: IPathFinder,\r\n    startChess: IChess,\r\n    endChess: IChess | XYType,\r\n    movingPoints?: number,\r\n    isClosest: boolean = true,\r\n    out: SearchResultType = []\r\n): SearchResultType {\r\n\r\n    // Negative moving points\r\n    if ((movingPoints !== undefined) && (movingPoints <= 0)) {\r\n        return out;\r\n    }\r\n    if (IsChess(startChess)) {\r\n        pathFinder.board = (startChess as IChess).rexChess.board;\r\n    } else if (!IsTileXYZ(startChess)) { // Not a chess, neither tileXYZ\r\n        return out;\r\n    }\r\n\r\n    let board = pathFinder.board;\r\n    let astar = pathFinder.astar;\r\n    let startTileXYZ = TileXY.ChessToTileXYZ(board, startChess) as XYZType;\r\n    let endTileXY = TileXY.ChessToTileXYZ(board, endChess) as XYType;\r\n    CopyTileXYZ(startTileXYZ, pathFinder.startTileXYZ);\r\n    let startNodeKey = XYToKey(startTileXYZ.x, startTileXYZ.y),\r\n        endNodeKey = XYToKey(endTileXY.x, endTileXY.y);\r\n\r\n    astar\r\n        .setPathMode(pathFinder.pathMode)\r\n        .setWeight(pathFinder.weight)\r\n        .search(startNodeKey, endNodeKey, movingPoints);\r\n\r\n    let endNode = ((isClosest) ? astar.getClosestNode() : astar.getNode(endNodeKey)) as IAStarNode;\r\n    if (endNode === null) {\r\n        return out;\r\n    }\r\n\r\n    return GetPath(pathFinder, (endNode as XYType), out);\r\n}\r\nexport default FindPath;", "import { IPathFinder, CostValueType } from './IPathFinder';\r\nimport { XType, YType } from '../types';\r\nimport { XYToKey } from '../utils/StringKey';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\n\r\nexport let TileXYToCost = function (\r\n    pathFinder: IPathFinder,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    pathCost: boolean = true\r\n): CostValueType {\r\n\r\n    let node = pathFinder.astar.getNode(XYToKey(tileX, tileY)) as IAStarNode;\r\n    if (node === null) {\r\n        return null;\r\n    }\r\n    return (pathCost) ? node.g : node.cost;\r\n}", "import {\r\n    IPathFinder, IConfig,\r\n    PathMode, PathModeString,\r\n    GetCostCallbackType, CostNodeType, CostValueType, BLOCKER,\r\n    SearchResultType\r\n} from './IPathFinder';\r\nimport { IBaseBoard } from '../board/IBaseBoard';\r\nimport { IChess, XYZType, XYType, XType, YType } from '../types';\r\nimport { IAStar } from '../../utils/astar/IAStar';\r\nimport { CreateAStar } from './astar/CreateAStar';\r\nimport { GetCost } from './GetCost';\r\nimport { FindArea } from './FindArea';\r\nimport { FindPath } from './FindPath';\r\nimport { GetPath } from './GetPath';\r\nimport { TileXYToCost } from './TileXYToCost';\r\n\r\nexport class PathFinder implements IPathFinder {\r\n    board: IBaseBoard;\r\n    astar: IAStar;\r\n\r\n    constCost: number;\r\n    costCallback: GetCostCallbackType | null;\r\n    costCallbackScope: any;\r\n    pathMode: PathMode;\r\n    occupiedTest: boolean;\r\n    blockerTest: boolean;\r\n    edgeBlockerTest: boolean;\r\n\r\n    startTileXYZ: XYZType = { x: 0, y: 0, z: 0 };\r\n    cacheCost: boolean;\r\n    weight: number;\r\n    shuffleNeighbors: boolean;\r\n\r\n    constructor({\r\n        board = undefined,\r\n\r\n        cost = 1,\r\n        costCallback = undefined,\r\n        costCallbackScope = undefined,\r\n\r\n        occupiedTest = false,\r\n        blockerTest = false,\r\n        edgeBlockerTest = false,\r\n\r\n        pathMode = PathMode['astar'],\r\n\r\n        cacheCost = true,\r\n\r\n        weight = 10,\r\n\r\n        shuffleNeighbors = false\r\n    }: IConfig = {}) {\r\n\r\n        this.setBoard(board);\r\n\r\n        if (costCallback) {\r\n            this.setCostFunction(costCallback, costCallbackScope);\r\n        } else {\r\n            this.setConstCost(cost);\r\n        }\r\n\r\n        this.setPathMode(pathMode);\r\n        this.setOccupiedTest(occupiedTest);\r\n        this.setBlockerTest(blockerTest);\r\n        this.setEdgeBlockerTest(edgeBlockerTest);\r\n\r\n        this.setCacheCostMode(cacheCost);\r\n        this.setWeight(weight);\r\n        this.setShuffleNeighborsMode(shuffleNeighbors);\r\n\r\n        this.astar = CreateAStar(this);\r\n    }\r\n\r\n    destroy() {\r\n\r\n        this.board = null;\r\n        this.astar.destroy();\r\n    }\r\n\r\n    setBoard(\r\n        board?: IBaseBoard\r\n    ): this {\r\n\r\n        this.board = board;\r\n        return this;\r\n    }\r\n\r\n    setConstCost(\r\n        cost?: number\r\n    ): this {\r\n\r\n        this.constCost = cost;\r\n\r\n        if (cost !== undefined) {\r\n            this.setCostFunction();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setCostFunction(\r\n        callback?: GetCostCallbackType,\r\n        scope?: any\r\n    ): this {\r\n\r\n        this.costCallback = callback;\r\n        this.costCallbackScope = scope;\r\n\r\n        if (callback) {\r\n            this.setConstCost();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setPathMode(\r\n        mode: PathMode | PathModeString\r\n    ): this {\r\n\r\n        if (typeof (mode) === 'string') {\r\n            mode = PathMode[mode];\r\n        }\r\n        this.pathMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setOccupiedTest(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.occupiedTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setBlockerTest(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.blockerTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setEdgeBlockerTest(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.edgeBlockerTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setCacheCostMode(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.cacheCost = enable;\r\n        return this;\r\n    }\r\n\r\n    setWeight(\r\n        value: number\r\n    ): this {\r\n\r\n        this.weight = value;\r\n        return this;\r\n    }\r\n\r\n    setShuffleNeighborsMode(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.shuffleNeighbors = enable;\r\n        return this;\r\n    }\r\n\r\n    getCost(\r\n        currNode: CostNodeType,\r\n        prevNode: CostNodeType\r\n    ): CostValueType {\r\n\r\n        return GetCost(this, currNode, prevNode);\r\n    }\r\n\r\n    findArea(\r\n        startChess: IChess,\r\n        movingPoints?: number,\r\n        out: SearchResultType = []\r\n    ): SearchResultType {\r\n\r\n        return FindArea(this, startChess, movingPoints, out);\r\n    }\r\n\r\n    get BLOCKER(): CostValueType {\r\n        return BLOCKER;\r\n    }\r\n\r\n    findPath(\r\n        startChess: IChess,\r\n        endChess: IChess | XYType,\r\n        movingPoints?: number,\r\n        isClosest: boolean = true,\r\n        out: SearchResultType = []\r\n    ): SearchResultType {\r\n\r\n        return FindPath(this, startChess, endChess, movingPoints, isClosest, out);\r\n    }\r\n\r\n    getPath(\r\n        endChess: IChess | XYZType | XYType,\r\n        out: SearchResultType = []\r\n    ): SearchResultType {\r\n\r\n        return GetPath(this, endChess, out);\r\n    }\r\n\r\n    tileXYToCost(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        pathCost: boolean = true\r\n    ): CostValueType {\r\n\r\n        return TileXYToCost(this, tileX, tileY, pathCost);\r\n    }\r\n}", "import { PathFinder } from './PathFinder';\r\n\r\nexport { PathFinder };", "import {\r\n    IMatch,\r\n    SymbolType,\r\n    MatchResult\r\n} from './IMatch';\r\nimport { XYType } from '../types';\r\nimport { Nieghbors } from '../board'\r\n\r\nexport let MatchAtDir = function (\r\n    match: IMatch,\r\n    pattern: number | SymbolType[],\r\n    startTileX: number,\r\n    startTileY: number,\r\n    direction: number\r\n): MatchResult | false {\r\n\r\n    let matchNMode = typeof (pattern) === 'number';\r\n    let patternLength: number,\r\n        currSymbol: SymbolType | null;\r\n    if (matchNMode) {\r\n        patternLength = pattern as number;\r\n        currSymbol = null;\r\n    } else {\r\n        patternLength = (pattern as SymbolType[]).length;\r\n    }\r\n\r\n    let symbol: SymbolType,\r\n        wildcard = match.wildcard;\r\n    let curTileXY: XYType;\r\n    let board = match.board;\r\n    let matchedTileXY: XYType[] = [];\r\n    for (let i = 0; i < patternLength; i++) {\r\n        if (curTileXY === undefined) {\r\n            curTileXY = {\r\n                x: startTileX,\r\n                y: startTileY\r\n            };\r\n        } else {\r\n            // Get next tileXY \r\n            curTileXY = Nieghbors.GetNeighborTileXY(board, curTileXY, direction, curTileXY) as XYType;\r\n            if (curTileXY === null) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        symbol = match.getSymbol(curTileXY.x, curTileXY.y);\r\n        if (symbol == null) {\r\n            return false;\r\n        }\r\n        if (symbol !== wildcard) {\r\n            if (matchNMode) { // Match N mode\r\n                if (currSymbol === null) {\r\n                    currSymbol = symbol;\r\n                } else if (currSymbol !== symbol) {\r\n                    return false;\r\n                }\r\n            } else if (pattern[i] !== symbol) { // Pattern list mode\r\n                return false;\r\n            }\r\n        }\r\n\r\n        matchedTileXY.push({\r\n            x: curTileXY.x,\r\n            y: curTileXY.y\r\n        });\r\n    }\r\n\r\n    return {\r\n        tileXY: matchedTileXY,\r\n        direction: direction,\r\n        pattern: pattern\r\n    };\r\n};", "import {\r\n    IMatch,\r\n    SymbolType,\r\n    MatchResult,\r\n    MatchCallbackType\r\n} from './IMatch';\r\nimport { MatchAtDir } from './MatchAtDir';\r\n\r\nexport let MatchAll = function (\r\n    match: IMatch,\r\n    pattern: number | SymbolType[],\r\n    callback?: MatchCallbackType,\r\n    scope?: any,\r\n    getFirst: boolean = false\r\n): MatchResult | void {\r\n\r\n    let board = match.board,\r\n        grid = board.grid;\r\n    let directions = grid.halfDirections,\r\n        dir: number,\r\n        dirMask = match.dirMask;\r\n    let width = board.width,\r\n        height = board.height;\r\n    let result: MatchResult | false;\r\n    for (let i = 0, cnt = directions.length; i < cnt; i++) {\r\n        dir = directions[i];\r\n        if (dirMask[dir] === false) {\r\n            continue;\r\n        }\r\n\r\n        for (let tileY = 0; tileY < height; tileY++) {\r\n            for (let tileX = 0; tileX < width; tileX++) {\r\n                result = MatchAtDir(match, pattern, tileX, tileY, dir);\r\n                if (result === false) {\r\n                    continue;\r\n                }\r\n\r\n                if (callback) {\r\n                    if (scope) {\r\n                        callback.call(scope, result, board);\r\n                    } else {\r\n                        callback(result, board);\r\n                    }\r\n                }\r\n                if (getFirst) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport let MatchAny = function (\r\n    match: IMatch,\r\n    pattern: number | SymbolType[],\r\n): MatchResult | false {\r\n\r\n    let result = MatchAll(match, pattern, null, null, true);\r\n    return (result) ? result : false;\r\n}", "import { IMatch, SymbolType } from './IMatch';\r\nimport { XYType } from '../types';\r\nimport { Nieghbors } from '../board';\r\n\r\nexport let Group = function (\r\n    match: IMatch,\r\n    startTileX: number,\r\n    startTileY: number,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let board = match.board;\r\n    let wildcard = match.wildcard;\r\n    let targetSymbol = match.getSymbol(startTileX, startTileY);\r\n    if ((targetSymbol == null) || (targetSymbol === wildcard)) {\r\n        return out;\r\n    }\r\n\r\n    let curTileXY: XYType,\r\n        symbol: SymbolType;\r\n    globalQueue.push(startTileX, startTileY);\r\n    while (globalQueue.length) {\r\n        curTileXY = globalQueue.pop();\r\n        symbol = match.getSymbol(curTileXY.x, curTileXY.y);\r\n        if ((symbol === targetSymbol) || (symbol === wildcard)) {\r\n            out.push(curTileXY);\r\n            globalQueue.push(Nieghbors.GetNeighborTileXY(board, curTileXY));\r\n        }\r\n    }\r\n\r\n    globalQueue.clear();\r\n    return out;\r\n}\r\n\r\nclass Queue {\r\n    data: XYType[] = [];\r\n    visited: Set<string> = new Set();\r\n\r\n    push(\r\n        x: number | XYType | XYType[],\r\n        y?: number\r\n    ): this {\r\n\r\n        if (Array.isArray(x)) { // XYType[]\r\n            let xyArray = x;\r\n            for (let i = 0, cnt = xyArray.length; i < cnt; i++) {\r\n                this.push(xyArray[i]);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (typeof (x) === 'object') { // XYType\r\n            let xy = x;\r\n            x = xy.x;\r\n            y = xy.y;\r\n        }\r\n        let key = `${x},${y}`;\r\n        if (this.visited.has(key)) {\r\n            return this;\r\n        }\r\n\r\n        this.data.push({ x: x, y: y });\r\n        this.visited.add(key);\r\n        return this;\r\n    }\r\n\r\n    pop(): XYType {\r\n        return this.data.pop();\r\n    }\r\n\r\n    get length(): number {\r\n        return this.data.length;\r\n    }\r\n\r\n    clear(): this {\r\n        this.data.length = 0;\r\n        this.visited.clear();\r\n        return this;\r\n    }\r\n}\r\n\r\nlet globalQueue = new Queue();", "import {\r\n    IMatch, IConfig,\r\n    IBaseBoard, SymbolType, DirMaskType,\r\n    GetSymbolCallback, MatchCallbackType, ForEachSymbolCallback, MatchResult\r\n} from './IMatch';\r\nimport { XYType } from '../types';\r\nimport { MatchAll, MatchAny } from './MatchBoard';\r\nimport { MatchAtDir } from './MatchAtDir';\r\nimport { Group } from './Group';\r\nimport { TileXY } from '../board'\r\n\r\nexport class Match implements IMatch {\r\n    board: IBaseBoard;\r\n    wildcard: SymbolType;\r\n    symbols: SymbolType[];\r\n    dirMask: DirMaskType;\r\n\r\n    constructor({\r\n        board,\r\n        wildcard,\r\n        dirMask\r\n    }: IConfig = {}) {\r\n\r\n        this.symbols = []; // tileX+(tileY*board.width)\r\n        this.dirMask = {};\r\n\r\n        this.setBoard(board);\r\n        this.setWildcard(wildcard);\r\n        if (dirMask !== undefined) {\r\n            this.setDirMask(dirMask);\r\n        }\r\n\r\n        this.boot();\r\n    }\r\n\r\n    boot() { }\r\n\r\n    destroy() {\r\n        this.board = undefined;\r\n        this.symbols = undefined;\r\n        this.dirMask = undefined;\r\n    }\r\n\r\n    setBoard(\r\n        board: IBaseBoard\r\n    ): this {\r\n\r\n        this.board = board;\r\n        if (board) {\r\n            this.clearSymbols();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setDirMask(\r\n        dir: number | DirMaskType,\r\n        value: boolean = false\r\n    ): this {\r\n\r\n        if (typeof (dir) === 'object') {\r\n            let dirMask: DirMaskType = dir;\r\n            for (let _dir in dirMask) {\r\n                this.dirMask[_dir] = dirMask[_dir];\r\n            }\r\n        } else {\r\n            this.dirMask[dir] = value;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setDirectionMode(\r\n        mode: number\r\n    ): this {\r\n\r\n        this.board.grid.setDirectionMode(mode);\r\n        return this;\r\n    }\r\n\r\n    clearSymbols(): this {\r\n\r\n        this.refreshSymbols(null);\r\n        return this;\r\n    }\r\n\r\n    setSymbol(\r\n        tileX: number,\r\n        tileY: number,\r\n        symbol: SymbolType\r\n    ) {\r\n\r\n        if (!TileXY.Contains(this.board, tileX, tileY)) {\r\n            return this;\r\n        }\r\n\r\n        this.symbols[this.tileXYToKey(tileX, tileY)] = symbol;\r\n        return this;\r\n    }\r\n\r\n    getSymbol(\r\n        tileX: number,\r\n        tileY: number\r\n    ): SymbolType {\r\n\r\n        return this.symbols[this.tileXYToKey(tileX, tileY)];\r\n    }\r\n\r\n    forEach(\r\n        callback: ForEachSymbolCallback,\r\n        scope?: any\r\n    ): this {\r\n\r\n        let board = this.board;\r\n        let tileXY: XYType,\r\n            symbol: SymbolType;\r\n        for (let i = 0, cnt = this.symbols.length; i < cnt; i++) {\r\n            symbol = this.symbols[i];\r\n            tileXY = this.keyToTileXY(i, true);\r\n            if (scope) {\r\n                callback.call(scope, symbol, tileXY, board);\r\n            } else {\r\n                callback(symbol, tileXY, board);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    refreshSymbols(\r\n        callback: SymbolType | GetSymbolCallback,\r\n        scope?: any\r\n    ): this {\r\n\r\n        let board = this.board;\r\n        let width = board.width,\r\n            height = board.height;\r\n        this.symbols.length = width * height;\r\n\r\n        let symbol: SymbolType,\r\n            tileXY: XYType;\r\n        if (typeof (callback) === 'function') {\r\n            // Get symbol by callback\r\n            for (let i = 0, cnt = this.symbols.length; i < cnt; i++) {\r\n                tileXY = this.keyToTileXY(i, true);\r\n                if (scope) {\r\n                    symbol = callback.call(scope, tileXY, board);\r\n                } else {\r\n                    symbol = callback(tileXY, board);\r\n                }\r\n                this.symbols[i] = symbol;\r\n            }\r\n\r\n        } else {\r\n            // Fill a given symbol\r\n            symbol = callback;\r\n            for (let i = 0, cnt = this.symbols.length; i < cnt; i++) {\r\n                this.symbols[i] = symbol;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setWildcard(\r\n        wildcard: SymbolType\r\n    ): this {\r\n\r\n        this.wildcard = wildcard;\r\n        return this;\r\n    }\r\n\r\n    tileXYToKey(\r\n        tileX: number,\r\n        tileY: number\r\n    ): number {\r\n\r\n        return tileX + (tileY * this.board.width);\r\n    }\r\n\r\n    keyToTileXY(\r\n        key: number,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        if (out === true) {\r\n            out = globTileXY;\r\n        }\r\n        let width = this.board.width;\r\n        out.x = key % width;\r\n        out.y = Math.floor(key / width);\r\n        return out;\r\n    }\r\n\r\n    group(\r\n        startTileX: number,\r\n        startTileY: number,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return Group(this, startTileX, startTileY, out);\r\n    }\r\n\r\n    match(pattern: number | SymbolType[],\r\n        callback?: MatchCallbackType,\r\n        scope?: any,\r\n        getFirst: boolean = false\r\n    ): this {\r\n\r\n        MatchAll(this, pattern, callback, scope, getFirst);\r\n        return this;\r\n    }\r\n\r\n    matchAny(\r\n        pattern: number | SymbolType[],\r\n    ): MatchResult | false {\r\n\r\n        return MatchAny(this, pattern);\r\n    }\r\n\r\n    matchAtDir(\r\n        pattern: number | SymbolType[],\r\n        startTileX: number,\r\n        startTileY: number,\r\n        direction: number\r\n    ): MatchResult | false {\r\n\r\n        return MatchAtDir(this, pattern, startTileX, startTileY, direction);\r\n    }\r\n\r\n}\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };", "import { Match } from './Match';\r\n\r\nexport { Match };", "import { XYType, XYZType, IChess } from '../types';\r\nimport { IBaseBoard } from '../board/IBaseBoard';\r\n\r\nexport const BLOCKER = null;\r\nexport type CostValueType = number | null;\r\nexport type PreTestCallbackType = (lineTileXYArray: XYType[], visiblePoints: number, fov: IFieldOfView) => boolean;\r\nexport type GetCostCallbackType = (currTileXY: XYType, fov: IFieldOfView, lineTileXYArray: XYType[]) => CostValueType;\r\n\r\nexport enum ConeType {\r\n    direction = 0,\r\n    angle = 1\r\n};\r\n\r\nexport type ConeTypeString = 'direction' | 'angle';\r\n\r\nexport interface IConfig {\r\n    chess?: IChess;\r\n\r\n    occupiedTest?: boolean;\r\n    blockerTest?: boolean;\r\n    edgeBlockerTest?: boolean;\r\n    costCallback?: GetCostCallbackType,\r\n    costCallbackScope?: any;\r\n    cost?: number;\r\n\r\n    face?: number;\r\n    coneMode?: ConeType | ConeTypeString;\r\n    cone?: number;\r\n};\r\n\r\nexport interface IFieldOfView {\r\n    occupiedTest: boolean;\r\n    blockerTest: boolean;\r\n    edgeBlockerTest: boolean;\r\n    costCallback: GetCostCallbackType,\r\n    costCallbackScope: any;\r\n    constCost: number;\r\n\r\n    chess: IChess;\r\n    board: IBaseBoard;\r\n    startTileXYZ: XYZType;\r\n    face: number;\r\n    faceAngle: number;\r\n    coneMode: ConeType;\r\n    cone: number | undefined;\r\n    coneRad: number;\r\n\r\n    costCache: Map<string, CostValueType>;\r\n}", "import { IFieldOfView, ConeType } from './IFieldOfView';\r\nimport { XYType } from '../types';\r\nimport { TileXY, WorldXY } from '../board';\r\n\r\nexport let IsInCone = function (\r\n    fov: IFieldOfView,\r\n    targetTileXY: XYType\r\n): boolean {\r\n\r\n    if (fov.cone === undefined) {\r\n        return true;\r\n    }\r\n\r\n    if (fov.coneMode === ConeType.direction) { // Direction\r\n        return TileXY.IsDirectionInCone(fov.board, fov.startTileXYZ, targetTileXY, fov.face, fov.cone);\r\n    } else { // Angle\r\n        return WorldXY.IsAngleInCone(fov.board, fov.startTileXYZ, targetTileXY, fov.faceAngle, fov.coneRad);\r\n    }\r\n}", "import { IFieldOfView, CostValueType, BLOCKER } from './IFieldOfView';\r\nimport { TileXY, Blocker } from '../board';\r\nimport { XYType } from '../types';\r\nimport { XYToKey } from '../utils/StringKey';\r\n\r\nexport let GetCost = function (\r\n    fov: IFieldOfView,\r\n    tileXY: XYType,\r\n    lineTileXYArray: XYType[]\r\n): CostValueType {\r\n\r\n    let cost: CostValueType;\r\n    let key = XYToKey(tileXY.x, tileXY.y);\r\n    let costCahce = fov.costCache;\r\n\r\n    if (costCahce.has(key)) {\r\n        cost = costCahce.get(key);\r\n        // console.log(`GetCost: ${key} in costCahe`);\r\n    } else {\r\n        let board = fov.board;\r\n        let tileX = tileXY.x,\r\n            tileY = tileXY.y,\r\n            tileZ = fov.startTileXYZ.z;\r\n\r\n        if (fov.occupiedTest &&  // Occupied test\r\n            TileXY.Contains(board, tileX, tileY, tileZ)\r\n        ) {\r\n\r\n            cost = BLOCKER;\r\n        } else if (fov.blockerTest &&  // Blocker test\r\n            Blocker.HasBlocker(board, tileX, tileY)) {\r\n\r\n            cost = BLOCKER;\r\n        } else if (fov.edgeBlockerTest && // Edge-blocker test\r\n            false) {\r\n            // TODO\r\n            cost = BLOCKER;\r\n        } else {\r\n            let callback = fov.costCallback;\r\n            if (callback) {\r\n                let scope = fov.costCallbackScope;\r\n                if (scope) {\r\n                    cost = callback.call(scope, tileXY, fov, lineTileXYArray);\r\n                } else {\r\n                    cost = callback(tileXY, fov, lineTileXYArray);\r\n                }\r\n                if (cost === undefined) {\r\n                    cost = BLOCKER;\r\n                }\r\n            } else {\r\n                cost = fov.constCost;\r\n            }\r\n        }\r\n\r\n        costCahce.set(key, cost);\r\n    }\r\n\r\n    return cost;\r\n}", "import {\r\n    IFieldOfView,\r\n    BLOCKER\r\n} from './IFieldOfView';\r\nimport { XYType } from '../types';\r\nimport { GetCost } from './GetCost';\r\n\r\nexport let IsPathVisible = function (\r\n    fov: IFieldOfView,\r\n    tileXYArray: XYType[],\r\n    visiblePoints?: number\r\n): boolean {\r\n\r\n    let behindBlocker = false;\r\n    for (let i = 1, cnt = tileXYArray.length; i < cnt; i++) {\r\n        let tileXY = tileXYArray[i];\r\n        if (behindBlocker) {\r\n            return false;\r\n        }\r\n\r\n        let cost = GetCost(fov, tileXY, tileXYArray);\r\n        if (cost === BLOCKER) {\r\n            behindBlocker = true;\r\n            continue;\r\n        }\r\n\r\n        if (visiblePoints !== undefined) {\r\n            visiblePoints -= cost;\r\n            if (visiblePoints < 0) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}", "import { IFieldOfView } from './IFieldOfView';\r\nimport { IChess, XYZType, XYType } from '../types';\r\nimport { TileXY, WorldXY, Shape } from '../board';\r\nimport { IsInCone } from './IsInCone';\r\nimport { IsPathVisible } from './IsPathVisible';\r\nimport { Between as AngleBetween } from '../../utils/math/angle/Between';\r\n\r\nconst LINEOFFSET = 0.001;\r\n\r\nexport let IsInLOS = function (\r\n    fov: IFieldOfView,\r\n    chess: IChess | XYZType,\r\n    visiblePoints?: number,\r\n    originTileXY: XYType = fov.startTileXYZ\r\n): boolean {\r\n\r\n    if ((visiblePoints !== undefined) && (visiblePoints <= 0)) {\r\n        return false;\r\n    }\r\n\r\n    let board = fov.board;\r\n    let targetTileXYZ = TileXY.ChessToTileXYZ(board, chess);\r\n    if (!IsInCone(fov, targetTileXYZ)) {\r\n        return false;\r\n    }\r\n\r\n    //if (this.debugLog) {\r\n    //    console.log('Visible test from (' + originTileXY.x + ',' + originTileXY.y + ') to (' + targetTileXYZ.x + ',' + targetTileXYZ.y + ')');\r\n    //}\r\n\r\n    let startTileXY = WorldXY.TileXYToWorldXY(board, originTileXY.x, originTileXY.y, true);\r\n    let startX = startTileXY.x,\r\n        startY = startTileXY.y;\r\n    let endTileXY = WorldXY.TileXYToWorldXY(board, targetTileXYZ.x, targetTileXYZ.y, true);\r\n    let endX = endTileXY.x,\r\n        endY = endTileXY.y;\r\n    let lineAngle = AngleBetween(startX, startY, endX, endY);\r\n    // Shift a small distance\r\n    lineAngle += (Math.PI / 2);\r\n    let offsetX = LINEOFFSET * Math.cos(lineAngle);\r\n    let offsetY = LINEOFFSET * Math.sin(lineAngle);\r\n    let line0TileXYArray = Shape.LineToTileXYArray(board,\r\n        (startX + offsetX),\r\n        (startY + offsetY),\r\n        (endX + offsetX),\r\n        (endY + offsetY));\r\n\r\n    // if (this.debugLog) {\r\n    //     console.log('Line 0: ' + JSON.stringify(line0TileXYArray));\r\n    // }\r\n\r\n    let isVisivle = IsPathVisible(fov, line0TileXYArray, visiblePoints);\r\n    if (isVisivle) {\r\n\r\n        // drawLine(\r\n        //     this.debugGraphics,\r\n        //     this.debugVisibleLineColor,\r\n        //     startX, startY, endX, endY\r\n        // );\r\n        return true;\r\n    }\r\n\r\n    // Shift a small distance\r\n    lineAngle += Math.PI;\r\n    offsetX = LINEOFFSET * Math.cos(lineAngle);\r\n    offsetY = LINEOFFSET * Math.sin(lineAngle);\r\n    let line1TileXYArray = Shape.LineToTileXYArray(board,\r\n        (startX + offsetX),\r\n        (startY + offsetY),\r\n        (endX + offsetX),\r\n        (endY + offsetY)\r\n    );\r\n\r\n    // if (this.debugLog) {\r\n    //     console.log('Line 1: ' + JSON.stringify(line1TileXYArray));\r\n    // }\r\n\r\n    // No need do visible checking if path is the same as previous one\r\n    let isEqual = (line0TileXYArray.length === line1TileXYArray.length);\r\n    if (isEqual) {\r\n        for (let i = 0, cnt = line0TileXYArray.length; i < cnt; i++) {\r\n            let tileXY0 = line0TileXYArray[i],\r\n                tileXY1 = line1TileXYArray[i];\r\n            isEqual = (tileXY0.x === tileXY1.x) && (tileXY0.y === tileXY1.y);\r\n            if (!isEqual) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!isEqual) {\r\n        isVisivle = IsPathVisible(fov, line1TileXYArray, visiblePoints);\r\n    }\r\n\r\n    // drawLine(\r\n    //     this.debugGraphics,\r\n    //     ((isVisivle) ? this.debugVisibleLineColor : this.debugInvisibleLineColor),\r\n    //     startX, startY, endX, endY\r\n    // );\r\n\r\n    return isVisivle;\r\n}\r\n\r\n// let drawLine = function (graphics, color, startX, startY, endX, endY) {\r\n//     if (graphics && (color !== undefined)) {\r\n//         graphics.lineStyle(1, color, 1).lineBetween(startX, startY, endX, endY);\r\n//     }\r\n// }", "import { IFieldOfView } from './IFieldOfView';\r\nimport { IChess, XYType } from '../types';\r\nimport { IsInLOS } from './IsInLOS';\r\n\r\nexport let LOS = function (\r\n    fov: IFieldOfView,\r\n    chessArray: IChess[] | XYType[] | IChess | XYType,\r\n    visiblePoints: number | undefined,\r\n    originTileXY: XYType = fov.startTileXYZ,\r\n    out?: IChess[] | XYType[]\r\n): IChess[] | XYType[] | boolean {\r\n\r\n    if (!Array.isArray(chessArray)) {\r\n        let chess = chessArray;\r\n        return IsInLOS(fov, chess, visiblePoints, originTileXY);\r\n    } else {\r\n        if (out === undefined) {\r\n            out = [];\r\n        }\r\n\r\n        let chess : IChess | XYType;\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            chess = chessArray[i];\r\n            if (!IsInLOS(fov, chess, visiblePoints, originTileXY)) {\r\n                continue;\r\n            }\r\n            out.push(chess)\r\n        }\r\n        return out;\r\n    }\r\n}", "import { IFieldOfView } from './IFieldOfView';\r\nimport { XYType } from '../types';\r\nimport { Ring } from '../board';\r\nimport { IsInLOS } from './IsInLOS';\r\n\r\nexport let FindFOV = function (\r\n    fov: IFieldOfView,\r\n    visiblePoints?: number,\r\n    originTileXY: XYType = fov.startTileXYZ,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let board = fov.board;\r\n    let isAnyVisible: boolean,\r\n        radius = 1,\r\n        ringTileXYArray: XYType[] = [],\r\n        targetTileXY: XYType;\r\n    do {\r\n        isAnyVisible = false;\r\n        ringTileXYArray.length = 0;\r\n        Ring.RingToTileXYArray(board, originTileXY, radius, ringTileXYArray);\r\n        for (let i = 0, cnt = ringTileXYArray.length; i < cnt; i++) {\r\n            targetTileXY = ringTileXYArray[i];\r\n            if (IsInLOS(fov, targetTileXY, visiblePoints, originTileXY)) {\r\n                isAnyVisible = true;\r\n                out.push(targetTileXY);\r\n            }\r\n        }\r\n        radius++;\r\n    } while (isAnyVisible)\r\n\r\n    return out;\r\n}", "import {\r\n    IFieldOfView,\r\n    IConfig,\r\n    PreTestCallbackType, GetCostCallbackType,\r\n    ConeType, ConeTypeString,\r\n    CostValueType, BLOCKER\r\n} from './IFieldOfView';\r\nimport { IChess, XYZType, XYType } from '../types';\r\nimport { IBaseBoard } from '../board/IBaseBoard';\r\nimport { WorldXY } from '../board'\r\nimport { DegToRad } from '../../utils/math/angle/DegToRad';\r\nimport { Normalize as AngleNormalize } from '../../utils/math/angle/Normalize';\r\nimport { IsInLOS } from './IsInLOS';\r\nimport { LOS } from './LOS';\r\nimport { FindFOV } from './FindFOV';\r\n\r\n\r\nexport class FieldOfView implements IFieldOfView {\r\n    occupiedTest: boolean;\r\n    blockerTest: boolean;\r\n    edgeBlockerTest: boolean;\r\n    costCallback: GetCostCallbackType;\r\n    costCallbackScope: any;\r\n    constCost: number;\r\n\r\n    chess: IChess;\r\n    _face: number;\r\n    faceAngle: number;\r\n    coneMode: ConeType;\r\n    _cone: number | undefined;\r\n    coneRad: number;\r\n\r\n    costCache: Map<string, CostValueType>;\r\n\r\n    constructor({\r\n        occupiedTest = false,\r\n        blockerTest = false,\r\n        edgeBlockerTest = false,\r\n\r\n        costCallback = undefined,\r\n        costCallbackScope = undefined,\r\n        cost = 1,\r\n\r\n        chess = undefined,\r\n        face = 0,\r\n        coneMode = ConeType.direction,\r\n        cone = undefined\r\n    }: IConfig = {}) {\r\n\r\n        this.setOccupiedTest(occupiedTest);\r\n        this.setBlockerTest(blockerTest);\r\n        this.setEdgeBlockerTest(edgeBlockerTest);\r\n        if (costCallback) {\r\n            this.setCostFunction(costCallback, costCallbackScope);\r\n        } else {\r\n            this.setConstCost(cost);\r\n        }\r\n\r\n        this.setChess(chess);\r\n        this.setFace(face);\r\n        this.setConeMode(coneMode);\r\n        this.setCone(cone);\r\n\r\n        this.costCache = new Map();\r\n    }\r\n\r\n    destroy() {\r\n    }\r\n\r\n    setChess(\r\n        chess?: IChess\r\n    ): this {\r\n\r\n        if (chess === undefined) {\r\n            this.chess = null;\r\n        } else {\r\n            this.chess = chess;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    get face(): number {\r\n        return this._face;\r\n    }\r\n\r\n    set face(direction: number) {\r\n        if (this.board === null) {\r\n            return;\r\n        }\r\n\r\n        direction = this.board.grid.directionNormalize(direction);\r\n        this._face = direction;\r\n        if (this.coneMode === 0) { // Direction\r\n            // Do nothing\r\n        } else { // Angle\r\n            var angle = WorldXY.AngleToward(this.board, this.startTileXYZ, direction); // -PI~PI\r\n            this.faceAngle = AngleNormalize(angle); // 0~2PI\r\n        }\r\n    }\r\n\r\n    setFace(\r\n        direction: number\r\n    ): this {\r\n\r\n        this.face = direction;\r\n        return this;\r\n    }\r\n\r\n    get cone(): number {\r\n        return this._cone;\r\n    }\r\n\r\n    set cone(value: number) {\r\n        this._cone = value;\r\n\r\n        if (value !== undefined) {\r\n            if (this.coneMode === 0) { // Direction\r\n            } else { // Angle\r\n                this.coneRad = DegToRad(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    setConeMode(\r\n        mode: ConeType | ConeTypeString\r\n    ): this {\r\n\r\n        if (typeof (mode) === 'string') {\r\n            mode = ConeType[mode];\r\n        }\r\n        this.coneMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setCone(\r\n        value?: number\r\n    ): this {\r\n\r\n        this.cone = value;\r\n        return this;\r\n    }\r\n\r\n    setOccupiedTest(\r\n        enable = true\r\n    ): this {\r\n\r\n        this.occupiedTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setBlockerTest(\r\n        enable = true\r\n    ): this {\r\n\r\n        this.blockerTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setEdgeBlockerTest(\r\n        enable = true\r\n    ): this {\r\n\r\n        this.edgeBlockerTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setCostFunction(\r\n        callback?: GetCostCallbackType,\r\n        scope?: any): this {\r\n\r\n        this.costCallback = callback;\r\n        this.costCallbackScope = scope;\r\n\r\n        if (callback) {\r\n            this.setConstCost();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setConstCost(\r\n        cost?: number\r\n    ): this {\r\n\r\n        this.constCost = cost;\r\n\r\n        if (cost !== undefined) {\r\n            this.setCostFunction();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // setDebugGraphics(graphics) {\r\n    //     this.debugGraphics = graphics;\r\n    //     return this;\r\n    // }\r\n\r\n    // setDebugLineColor(visibleLineColor, invisibleLineColor) {\r\n    //     this.debugVisibleLineColor = visibleLineColor;\r\n    //     this.debugInvisibleLineColor = invisibleLineColor;\r\n    //     return this;\r\n    // }\r\n\r\n    // setDebugLog(enabled) {\r\n    //     if (enabled === undefined) {\r\n    //         enabled = true;\r\n    //     }\r\n    //     this.debugLog = enabled;\r\n    //     return this;\r\n    // }\r\n\r\n    // clearDebugGraphics() {\r\n    //     if (this.debugGraphics) {\r\n    //         this.debugGraphics.clear();\r\n    //     }\r\n    //     return this;\r\n    // }\r\n\r\n    isInLos(\r\n        chess: IChess | XYZType,\r\n        visiblePoints?: number | undefined,\r\n        originTileXY: XYType = this.startTileXYZ\r\n    ): boolean {\r\n\r\n        let result = IsInLOS(this, chess, visiblePoints, originTileXY);\r\n        this.costCache.clear();\r\n        return result;\r\n    }\r\n\r\n    los(\r\n        chessArray: IChess[] | XYType[] | IChess | XYType,\r\n        visiblePoints: number | undefined,\r\n        originTileXY: XYType = this.startTileXYZ,\r\n        out?: IChess[] | XYType[]\r\n    ): IChess[] | XYType[] | boolean {\r\n\r\n        let result = LOS(this, chessArray, visiblePoints, originTileXY, out);\r\n        this.costCache.clear();\r\n        return result;\r\n    }\r\n\r\n    findFOV(\r\n        visiblePoints?: number,\r\n        originTileXY: XYType = this.startTileXYZ,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        let result = FindFOV(this, visiblePoints, originTileXY, out);\r\n        this.costCache.clear();\r\n        return result;\r\n    }\r\n\r\n    get board(): IBaseBoard {\r\n\r\n        return (this.chess && this.chess.rexChess) ? this.chess.rexChess.board : null;\r\n    }\r\n\r\n    get startTileXYZ(): XYZType {\r\n\r\n        return (this.chess && this.chess.rexChess) ? this.chess.rexChess.tileXYZ : null;\r\n    }\r\n\r\n    get BLOCKER() {\r\n        return BLOCKER;\r\n    }\r\n}", "import { FieldOfView } from './FieldOfView';\r\n\r\nexport {\r\n    FieldOfView\r\n}", "import { IBaseBoard } from '../board/IBaseBoard';\r\nimport { XYType } from '../types';\r\nimport { cube2cr } from '../grid/hexagon/CubeTransfer';\r\n\r\nexport let GetHexagonMap = function (\r\n    board: IBaseBoard,\r\n    radius: number,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let mode = board.grid.mode;\r\n    let r1: number,\r\n        r2: number;\r\n    for (let q = -radius; q <= radius; q++) {\r\n        r1 = Math.max(-radius, -q - radius);\r\n        r2 = Math.min(radius, -q + radius);\r\n        for (let r = r1; r <= r2; r++) {\r\n            out.push(cube2cr(mode, q, r, -q - r));\r\n        }\r\n    }\r\n\r\n    return out;\r\n}", "import { IBaseBoard } from '../board/IBaseBoard';\r\nimport { XYType } from '../types';\r\nimport { cube2cr } from '../grid/hexagon/CubeTransfer';\r\n\r\nexport let GetTriangleMap = function (\r\n    board: IBaseBoard,\r\n    type: number,\r\n    height: number,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let mode = board.grid.mode;\r\n    let rStart: number,\r\n        rEnd: number;\r\n    for (let q = 0; q <= height; q++) {\r\n        if (type === 1) {\r\n            rStart = height - q;\r\n            rEnd = height;\r\n        } else {\r\n            rStart = 0;\r\n            rEnd = height - q;\r\n        }\r\n\r\n        for (let r = rStart; r <= rEnd; r++) {\r\n            out.push(cube2cr(mode, q, r, -q - r));\r\n        }\r\n    }\r\n\r\n    return out;\r\n}", "import { IBaseBoard } from '../board/IBaseBoard';\r\nimport { XYType } from '../types';\r\nimport { cube2cr } from '../grid/hexagon/CubeTransfer';\r\n\r\nexport let GetParallelogramMap = function (\r\n    board: IBaseBoard,\r\n    type: number,\r\n    width: number,\r\n    height: number,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let mode = board.grid.mode;\r\n    switch (type) {\r\n        case 1:\r\n            for (let s = 0; s <= width; s++) {\r\n                for (let q = 0; q <= height; q++) {\r\n                    out.push(cube2cr(mode, q, -q - s, s));\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n            for (let r = 0; r <= width; r++) {\r\n                for (let s = 0; s <= height; s++) {\r\n                    out.push(cube2cr(mode, -r - s, r, s));\r\n                }\r\n            }\r\n            break;\r\n        default: // case 0\r\n            for (let q = 0; q <= width; q++) {\r\n                for (let r = 0; r <= height; r++) {\r\n                    out.push(cube2cr(mode, q, r, -q - r));\r\n                }\r\n            }\r\n            break;\r\n    }\r\n\r\n    return out;\r\n}", "import { GetHexagonMap } from './GetHexagonMap';\r\nimport { GetTriangleMap } from './GetTriangleMap';\r\nimport { GetParallelogramMap } from './GetParallelogramMap';\r\n\r\nexport {\r\n    GetHexagonMap,\r\n    GetTriangleMap,\r\n    GetParallelogramMap,\r\n};", "// Boards\r\nimport { BaseBoard, LogicBoard, Board } from './board';\r\n\r\n// Grids\r\nimport {\r\n    Quad as QuadGrid,\r\n    Hexagon as HexagonGrid\r\n} from './grid';\r\n\r\n// Path finder\r\nimport { PathFinder } from './pathfinder';\r\n\r\n// Match\r\nimport { Match } from './match';\r\n\r\n// Field of view\r\nimport { FieldOfView } from './fieldofview';\r\n\r\n// HexagonMap\r\nimport * as HexagonMap from './hexagonmap';\r\n\r\nexport {\r\n    // Board\r\n    BaseBoard, LogicBoard, Board,\r\n\r\n    // Grids\r\n    QuadGrid, HexagonGrid,\r\n\r\n    // Path finder\r\n    PathFinder,\r\n\r\n    // Match\r\n    Match,\r\n\r\n    // Field of view\r\n    FieldOfView,\r\n\r\n    // HexagonMap\r\n    HexagonMap\r\n}", "import '../../renderer/BindingQueue.js';\nimport '../Frame.js';\nimport { Texture } from '../Texture.js';\nimport { CreateCanvas } from '../CreateCanvas.js';\n\nfunction CanvasTexture(width = 32, height = 32) {\r\n    const ctx = CreateCanvas(width, height);\r\n    return new Texture(ctx.canvas);\r\n}\n\nexport { CanvasTexture };\n", "import { TextureManagerInstance } from '@phaserjs/phaser/textures/TextureManagerInstance';\r\nimport { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { CanvasTexture } from '@phaserjs/phaser/textures/types/CanvasTexture';\r\n\r\n/**\r\n * Draw on canvas texture.\r\n *\r\n * @param {(string | Texture)} key Texture key, or texture object.\r\n * @param {(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D) => void} callback Drawing callback.\r\n * @param {*} [scope] Context of drawing callback.\r\n * @param {number} [resolution=1] Resolution of canvas.\r\n * @returns {Texture} Texture object.\r\n */\r\nexport let DrawCanvasTexture = function (\r\n    key: string | Texture,\r\n    callback: (canvas: HTMLCanvasElement, context: CanvasRenderingContext2D) => void,\r\n    scope?: any,\r\n    resolution: number = 1\r\n): Texture {\r\n\r\n    let texture: Texture;\r\n    if (typeof (key) === 'string') {\r\n        let textureManager = TextureManagerInstance.get();\r\n        if (!textureManager.has(key)) {\r\n            textureManager.add(key, CanvasTexture());\r\n        }\r\n        texture = textureManager.get(key);\r\n    } else {\r\n        texture = key;\r\n    }\r\n\r\n    let canvas = texture.image as HTMLCanvasElement;\r\n    let context = canvas.getContext('2d');\r\n\r\n    if (scope) {\r\n        callback.call(scope, canvas, context);\r\n    } else {\r\n        callback(canvas, context);\r\n    }\r\n\r\n    texture.setSize(\r\n        canvas.width / resolution,\r\n        canvas.height / resolution\r\n    );\r\n    if (texture.binding) {\r\n        texture.binding.update();\r\n    }\r\n\r\n    return texture;\r\n}", "import { GetCanvasGradientCallbackType } from '../types/GetCanvasGradientCallbackType';\r\n\r\nexport let GetStyle = function (\r\n    style: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    canvas: HTMLCanvasElement,\r\n    context: CanvasRenderingContext2D\r\n): string | CanvasGradient | CanvasPattern {\r\n\r\n    switch (typeof (style)) {\r\n        case 'number': return `#${style.toString(16)}`;\r\n        case 'function': return style(canvas, context);\r\n        default: return style;\r\n    }\r\n}", "import { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { DrawCanvasTexture } from './DrawCanvasTexture';\r\nimport { GetCanvasGradientCallbackType } from '../../utils/types/GetCanvasGradientCallbackType';\r\nimport { GetStyle } from '../../utils/canvas/GetStyle';\r\n\r\nexport interface IConfig {\r\n    width?: number,\r\n    height?: number,\r\n    fillStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    strokeStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    lineWidth?: number\r\n}\r\n\r\nexport let CreateCircleTexture = function (\r\n    key: string | Texture,\r\n    {\r\n        width = 32,\r\n        height = width,\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth = 2\r\n    }: IConfig = {}\r\n): Texture {\r\n\r\n    return DrawCanvasTexture(key, function (canvas, context) {\r\n        if (!strokeStyle) {\r\n            lineWidth = 0;\r\n        }\r\n\r\n        canvas.width = Math.ceil(width);\r\n        canvas.height = Math.ceil(height);\r\n\r\n        let x = canvas.width / 2;\r\n        let y = canvas.height / 2;\r\n        let rx = (width - lineWidth) / 2;\r\n        let ry = (height - lineWidth) / 2;\r\n\r\n        context.beginPath();\r\n        context.ellipse(x, y, rx, ry, 0, 0, (2 * Math.PI));\r\n\r\n        if (fillStyle) {\r\n            context.fillStyle = GetStyle(fillStyle, canvas, context);\r\n            context.fill();\r\n        }\r\n\r\n        if (strokeStyle) {\r\n            context.strokeStyle = GetStyle(strokeStyle, canvas, context);\r\n            context.lineWidth = lineWidth;\r\n            context.stroke();\r\n        }\r\n\r\n    });\r\n}", "import { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { DrawCanvasTexture } from './DrawCanvasTexture';\r\nimport { GetCanvasGradientCallbackType } from '../../utils/types/GetCanvasGradientCallbackType';\r\nimport { GetStyle } from '../../utils/canvas/GetStyle';\r\n\r\nexport interface IConfig {\r\n    width?: number,\r\n    height?: number,\r\n    fillStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    strokeStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    lineWidth?: number\r\n}\r\n\r\nexport let CreateRectangleTexture = function (\r\n    key: string | Texture,\r\n    {\r\n        width = 32,\r\n        height = width,\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth = 2\r\n    }: IConfig = {}\r\n): Texture {\r\n\r\n    return DrawCanvasTexture(key, function (canvas, context) {\r\n        if (!strokeStyle) {\r\n            lineWidth = 0;\r\n        }\r\n\r\n        canvas.width = Math.ceil(width);\r\n        canvas.height = Math.ceil(height);\r\n\r\n        context.beginPath();\r\n\r\n        let halfLineWidth = lineWidth / 2;\r\n        context.rect(\r\n            halfLineWidth,\r\n            halfLineWidth,\r\n            (width - lineWidth),\r\n            (height - lineWidth)\r\n        );\r\n\r\n        if (fillStyle) {\r\n            context.fillStyle = GetStyle(fillStyle, canvas, context);\r\n            context.fill();\r\n        }\r\n\r\n        if (strokeStyle) {\r\n            context.strokeStyle = GetStyle(strokeStyle, canvas, context);\r\n            context.lineWidth = lineWidth;\r\n            context.stroke();\r\n        }\r\n\r\n    });\r\n}", "import { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { DrawCanvasTexture } from './DrawCanvasTexture';\r\nimport { Vec2Type } from '../../utils/types/VectorType';\r\nimport { GetCanvasGradientCallbackType } from '../../utils/types/GetCanvasGradientCallbackType';\r\nimport { GetStyle } from '../../utils/canvas/GetStyle';\r\n\r\nexport interface IConfig {\r\n    points: Vec2Type[],\r\n    fillStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    strokeStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    lineWidth?: number,\r\n    lineJoin?: 'bevel' | 'round' | 'miter'\r\n}\r\n\r\nexport let CreatePolygonTexture = function (\r\n    key: string | Texture,\r\n    {\r\n        points,\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth = 2,\r\n        lineJoin = 'round'\r\n    }: IConfig = { points: [] }\r\n): Texture {\r\n\r\n    return DrawCanvasTexture(key, function (canvas, context) {\r\n        if (points.length === 0) {\r\n            canvas.width = 1;\r\n            canvas.height = 1;\r\n            return;\r\n        }\r\n\r\n        if (!strokeStyle) {\r\n            lineWidth = 0;\r\n        }\r\n\r\n        let minX = GetMinProperty(points, 'x');\r\n        let minY = GetMinProperty(points, 'y');\r\n        let maxX = GetMaxProperty(points, 'x');\r\n        let maxY = GetMaxProperty(points, 'y');\r\n\r\n        let width = maxX - minX ;\r\n        let height = maxY - minY ;\r\n\r\n        let halfW = width / 2;\r\n        let halfH = height / 2;\r\n        let halfLW = lineWidth / 2;\r\n\r\n        canvas.width = Math.ceil(width);\r\n        canvas.height = Math.ceil(height);\r\n\r\n        context.beginPath();\r\n        context.lineJoin = lineJoin;\r\n\r\n        let point = points[0];\r\n\r\n        context.moveTo(\r\n            Indent((point.x - minX), halfW, halfLW),\r\n            Indent((point.y - minY), halfH, halfLW)\r\n        );\r\n\r\n        for (let i = 1, cnt = points.length; i < cnt; i++) {\r\n            point = points[i];\r\n            context.lineTo(\r\n                Indent((point.x - minX), halfW, halfLW),\r\n                Indent((point.y - minY), halfH, halfLW)\r\n            )\r\n        }\r\n\r\n        context.closePath();\r\n\r\n        if (fillStyle) {\r\n            context.fillStyle = GetStyle(fillStyle, canvas, context);\r\n            context.fill();\r\n        }\r\n\r\n        if (strokeStyle) {\r\n            context.strokeStyle = GetStyle(strokeStyle, canvas, context);\r\n            context.lineWidth = lineWidth;\r\n            context.stroke();\r\n        }\r\n\r\n    });\r\n}\r\n\r\nlet GetMaxProperty = function (\r\n    items: object[],\r\n    key: string\r\n): number {\r\n\r\n    let result = -Infinity;\r\n    for (let i = 0, cnt = items.length; i < cnt; i++) {\r\n        result = Math.max(result, items[i][key]);\r\n    }\r\n    return result;\r\n}\r\n\r\nlet GetMinProperty = function (\r\n    items: object[],\r\n    key: string\r\n): number {\r\n\r\n    let result = Infinity;\r\n    for (let i = 0, cnt = items.length; i < cnt; i++) {\r\n        result = Math.min(result, items[i][key]);\r\n    }\r\n    return result;\r\n}\r\n\r\nlet Indent = function (\r\n    value: number,\r\n    halfBound: number,\r\n    offset: number\r\n): number {\r\n\r\n    if (value < halfBound) {\r\n        return (value + offset);\r\n    } else if (value > halfBound) {\r\n        return (value - offset);\r\n    } else {\r\n        return value;\r\n    }\r\n}", "import { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { CreatePolygonTexture } from './CreatePolygonTexture';\r\nimport { GetCanvasGradientCallbackType } from '../../utils/types/GetCanvasGradientCallbackType';\r\n\r\nexport enum Direction {\r\n    right = 0,\r\n    down = 1,\r\n    left = 2,\r\n    up = 3\r\n}\r\n\r\nexport interface IConfig {\r\n    direction?: Direction,\r\n    width?: number,\r\n    height?: number,\r\n    fillStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    strokeStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    lineWidth?: number\r\n}\r\n\r\nexport let CreateTriangleTexture = function (\r\n    key: string | Texture,\r\n    {\r\n        direction = Direction.right,\r\n        width = 32,\r\n        height = width,\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth = 2\r\n    }: IConfig = {}\r\n): Texture {\r\n\r\n    let x1: number, y1: number,\r\n        x2: number, y2: number,\r\n        x3: number, y3: number;\r\n    switch (direction) {\r\n        case Direction.down:\r\n            x1 = 0;\r\n            y1 = 0;\r\n            x2 = width;\r\n            y2 = 0;\r\n            x3 = width / 2;\r\n            y3 = height;\r\n            break;\r\n        case Direction.left:\r\n            x1 = 0;\r\n            y1 = height / 2;\r\n            x2 = width;\r\n            y2 = 0;\r\n            x3 = width;\r\n            y3 = height;\r\n            break;\r\n        case Direction.up:\r\n            x1 = 0;\r\n            y1 = height;\r\n            x2 = width / 2;\r\n            y2 = 0;\r\n            x3 = width;\r\n            y3 = height;\r\n            break;\r\n        default: // Direction.right\r\n            x1 = 0;\r\n            y1 = 0;\r\n            x2 = 0;\r\n            y2 = height;\r\n            x3 = width;\r\n            y3 = height / 2;\r\n            break;\r\n    }\r\n\r\n    return CreatePolygonTexture(key, {\r\n        points: [\r\n            { x: x1, y: y1 },\r\n            { x: x2, y: y2 },\r\n            { x: x3, y: y3 }\r\n        ],\r\n        fillStyle: fillStyle,\r\n        strokeStyle: strokeStyle,\r\n        lineWidth: lineWidth\r\n    })\r\n}", "import { DrawCanvasTexture } from './DrawCanvasTexture';\r\n\r\nimport { CreateCircleTexture } from './CreateCircleTexture';\r\nimport { CreateRectangleTexture } from './CreateRectangleTexture';\r\nimport { CreatePolygonTexture } from './CreatePolygonTexture';\r\nimport { CreateTriangleTexture } from './CreateTriangleTexture';\r\n\r\nexport {\r\n    DrawCanvasTexture,\r\n\r\n    CreateCircleTexture,\r\n    CreateRectangleTexture,\r\n    CreatePolygonTexture,\r\n    CreateTriangleTexture\r\n}", "import { BackgroundColor, Parent, Scenes, Size, WebGLRenderer } from '@phaserjs/phaser/config';\r\nimport { Game } from '@phaserjs/phaser/Game';\r\nimport { Scene } from '@phaserjs/phaser/scenes/Scene';\r\nimport { StaticWorld } from '@phaserjs/phaser/world';\r\nimport { AddChild } from '@phaserjs/phaser/display/';\r\nimport { Sprite, SetTint, SetAlpha } from '@phaserjs/phaser/gameobjects/sprite';\r\n\r\nimport { Board, HexagonGrid, FieldOfView } from '../../src/board';\r\nimport { CreatePolygonTexture } from '../../src/texture/canvastexture';\r\nimport { Shuffle } from '../../src/utils/array/Shuffle';\r\n\r\nclass Chess extends Sprite {\r\n    fov: FieldOfView;\r\n}\r\n\r\nclass MyBoard extends Board {\r\n    world: StaticWorld;\r\n\r\n\r\n    constructor(config) {\r\n        super(config);\r\n\r\n        CreatePolygonTexture('tile', {\r\n            points: this.getGridPoints(),\r\n            strokeStyle: 'white',\r\n            lineWidth: 1,\r\n            lineJoin: 'miter'\r\n        })\r\n\r\n        CreatePolygonTexture('chess', {\r\n            points: this.getGridPoints(),\r\n            fillStyle: 'white'\r\n        })\r\n    }\r\n\r\n    setWorld(world: StaticWorld): this {\r\n\r\n        this.world = world;\r\n        return this;\r\n    }\r\n\r\n    strokeGrid(): this {\r\n\r\n        this.forEachTileXY((tileXY) => {\r\n            let worldXY = this.tileXYToWorldXY(tileXY.x, tileXY.y, true);\r\n            let tile = new Sprite(worldXY.x, worldXY.y, 'tile');\r\n            AddChild(this.world, tile);\r\n        })\r\n        return this;\r\n    }\r\n\r\n    createChess(\r\n        x: number,\r\n        y: number,\r\n        z: number,\r\n        color?: number\r\n    ) {\r\n\r\n        let chess = new Chess(0, 0, 'chess');\r\n        AddChild(this.world, chess);\r\n        if (color !== undefined) {\r\n            SetTint(color, chess);\r\n        }\r\n        this.addChess(chess, x, y, z);\r\n        return chess;\r\n    }\r\n\r\n}\r\n\r\nclass Demo extends Scene {\r\n    constructor() {\r\n        super();\r\n\r\n        const world = new StaticWorld(this);\r\n\r\n        const board = new MyBoard({\r\n            grid: (new HexagonGrid({\r\n                x: 40, y: 40,\r\n                cellWidth: 30, cellHeight: 36\r\n            })),\r\n\r\n            width: 18, height: 18\r\n        })\r\n        board\r\n            .setWorld(world)\r\n            .strokeGrid();\r\n\r\n        // Add chess\r\n        let chessA = board.createChess(9, 9, 1, 0xffffff);\r\n        // Add some blockers (z=1, to block chessA)\r\n        let emptyTileXYArray = Shuffle(board.getEmptyTileXYArray(1))\r\n        for (let i = 0; i < 30; i++) {\r\n            let emptyTileXY = emptyTileXYArray[i];\r\n            board.createChess(emptyTileXY.x, emptyTileXY.y, 1, 0x808080);\r\n        }\r\n\r\n        chessA.fov = new FieldOfView({\r\n            chess: chessA,\r\n            face: 3,\r\n            cone: 2,\r\n            occupiedTest: true\r\n        })\r\n        let tileXYArray = chessA.fov.findFOV();\r\n        tileXYArray.forEach((tileXY) => {\r\n            let marker = board.createChess(tileXY.x, tileXY.y, -1, 0x400000);\r\n            SetAlpha(0.5, marker);\r\n        })\r\n    }\r\n}\r\n\r\nnew Game(\r\n    WebGLRenderer(),\r\n    Size(800, 600),\r\n    Parent('game'),\r\n    BackgroundColor(0x2d2d2d),\r\n    Scenes(Demo)\r\n);\r\n"],
  "mappings": "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",
  "names": []
}
