{"version":3,"file":"bundle.js","sources":["../../node_modules/@phaserjs/phaser/GameInstance.js","../../node_modules/@phaserjs/phaser/config/BackgroundColor.js","../../node_modules/@phaserjs/phaser/config/Size.js","../../node_modules/@phaserjs/phaser/renderer/BindingQueue.js","../../node_modules/@phaserjs/phaser/config/SetRenderer.js","../../node_modules/@phaserjs/phaser/config/DefaultOrigin.js","../../node_modules/@phaserjs/phaser/config/Parent.js","../../node_modules/@phaserjs/phaser/config/MaxTextures.js","../../node_modules/@phaserjs/phaser/dom/GetElement.js","../../node_modules/@phaserjs/phaser/config/Scenes.js","../../node_modules/@phaserjs/phaser/config/WebGLContext.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/GL.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/fbo/FBOSystem.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/textures/CreateGLTexture.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/textures/DeleteGLTexture.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/textures/GLTextureBinding.js","../../node_modules/@phaserjs/phaser/math/pow2/IsSizePowerOfTwo.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/textures/SetGLTextureFilterMode.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/textures/UpdateGLTexture.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/fbo/DeleteFramebuffer.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/buffers/IndexedBuffer.js","../../node_modules/@phaserjs/phaser/textures/Frame.js","../../node_modules/@phaserjs/phaser/textures/Texture.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/WebGLRendererInstance.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/shaders/SingleTextureQuadShader.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/fbo/CreateFramebuffer.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/shaders/MultiTextureQuadShader.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/shaders/ShaderSystem.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/shaders/CheckShaderMaxIfStatements.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/textures/TextureSystem.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/WebGLRenderer.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/cameras/Ortho.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/colors/GetRGBArray.js","../../node_modules/@phaserjs/phaser/math/matrix2d-funcs/ExactEquals.js","../../node_modules/@phaserjs/phaser/math/matrix2d/Matrix2D.js","../../node_modules/@phaserjs/phaser/geom/rectangle/Rectangle.js","../../node_modules/@phaserjs/phaser/geom/rectangle/Contains.js","../../node_modules/@phaserjs/phaser/utils/NOOP.js","../../node_modules/@phaserjs/phaser/math/vec2/Vec2Callback.js","../../node_modules/@phaserjs/phaser/camera/StaticCamera.js","../../node_modules/@phaserjs/phaser/display/RemoveChild.js","../../node_modules/@phaserjs/phaser/display/GetChildIndex.js","../../node_modules/@phaserjs/phaser/display/RemoveChildAt.js","../../node_modules/@phaserjs/phaser/events/Emit.js","../../node_modules/@phaserjs/phaser/display/SetParent.js","../../node_modules/@phaserjs/phaser/display/SetWorld.js","../../node_modules/@phaserjs/phaser/gameobjects/events/RemovedFromWorldEvent.js","../../node_modules/@phaserjs/phaser/gameobjects/events/AddedToWorldEvent.js","../../node_modules/@phaserjs/phaser/display/DepthFirstSearch.js","../../node_modules/@phaserjs/phaser/display/AddChild.js","../../node_modules/@phaserjs/phaser/gameobjects/DIRTY_CONST.js","../../node_modules/@phaserjs/phaser/display/RemoveChildrenBetween.js","../../node_modules/@phaserjs/phaser/events/EventInstance.js","../../node_modules/@phaserjs/phaser/events/Off.js","../../node_modules/@phaserjs/phaser/events/On.js","../../node_modules/@phaserjs/phaser/events/Once.js","../../node_modules/@phaserjs/phaser/scenes/SceneManagerInstance.js","../../node_modules/@phaserjs/phaser/scenes/SceneManager.js","../../node_modules/@phaserjs/phaser/scenes/CreateSceneRenderData.js","../../node_modules/@phaserjs/phaser/scenes/ResetSceneRenderData.js","../../node_modules/@phaserjs/phaser/textures/CreateCanvas.js","../../node_modules/@phaserjs/phaser/textures/TextureManagerInstance.js","../../node_modules/@phaserjs/phaser/textures/TextureManager.js","../../node_modules/@phaserjs/phaser/gameobjects/components/transform/GetVertices.js","../../node_modules/@phaserjs/phaser/gameobjects/components/bounds/BoundsComponent.js","../../node_modules/@phaserjs/phaser/gameobjects/components/input/InputComponent.js","../../node_modules/@phaserjs/phaser/math/vec2/Vec2.js","../../node_modules/@phaserjs/phaser/math/matrix2d/Copy.js","../../node_modules/@phaserjs/phaser/gameobjects/components/transform/TransformComponent.js","../../node_modules/@phaserjs/phaser/gameobjects/components/transform/UpdateLocalTransform.js","../../node_modules/@phaserjs/phaser/gameobjects/components/transform/UpdateWorldTransform.js","../../node_modules/@phaserjs/phaser/gameobjects/GameObject.js","../../node_modules/@phaserjs/phaser/display/ReparentChildren.js","../../node_modules/@phaserjs/phaser/display/DestroyChildren.js","../../node_modules/@phaserjs/phaser/gameobjects/events/DestroyEvent.js","../../node_modules/@phaserjs/phaser/gameobjects/container/Container.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/colors/PackColor.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/colors/PackColors.js","../../node_modules/@phaserjs/phaser/gameobjects/sprite/SetFrame.js","../../node_modules/@phaserjs/phaser/gameobjects/sprite/Sprite.js","../../node_modules/@phaserjs/phaser/gameobjects/sprite/SetTexture.js","../../node_modules/@phaserjs/phaser/gameobjects/sprite/UpdateVertices.js","../../node_modules/@phaserjs/phaser/renderer/webgl1/draw/BatchTexturedQuad.js","../../node_modules/@phaserjs/phaser/renderer/canvas/draw/DrawTexturedQuad.js","../../node_modules/@phaserjs/phaser/textures/types/CanvasTexture.js","../../node_modules/@phaserjs/phaser/gameobjects/text/Text.js","../../node_modules/@phaserjs/phaser/world/UpdateCachedLayers.js","../../node_modules/@phaserjs/phaser/world/HasDirtyChildren.js","../../node_modules/@phaserjs/phaser/world/BuildRenderList.js","../../node_modules/@phaserjs/phaser/world/WorldDepthFirstSearch.js","../../node_modules/@phaserjs/phaser/world/CalculateTotalRenderable.js","../../node_modules/@phaserjs/phaser/world/ResetWorldRenderData.js","../../node_modules/@phaserjs/phaser/world/BaseWorld.js","../../node_modules/@phaserjs/phaser/gameobjects/events/UpdateEvent.js","../../node_modules/@phaserjs/phaser/gameobjects/events/PostUpdateEvent.js","../../node_modules/@phaserjs/phaser/world/events/WorldRenderEvent.js","../../node_modules/@phaserjs/phaser/world/MergeRenderData.js","../../node_modules/@phaserjs/phaser/display/RemoveChildren.js","../../node_modules/@phaserjs/phaser/world/events/WorldShutdownEvent.js","../../node_modules/@phaserjs/phaser/world/StaticWorld.js","../../node_modules/@phaserjs/phaser/world/CreateWorldRenderData.js","../../node_modules/@phaserjs/phaser/scenes/Install.js","../../node_modules/@phaserjs/phaser/scenes/GetConfigValue.js","../../src/board/board/boarddata/methods/Key.ts","../../src/utils/struct/Stack.ts","../../src/utils/pool/EmptyMap.ts","../../src/board/board/boarddata/methods/ZMap.ts","../../src/utils/pool/EmptySet.ts","../../src/board/board/boarddata/methods/ChessSet.ts","../../src/board/board/boarddata/methods/GetChess.ts","../../src/board/board/boarddata/methods/GetMaxMinMapKey.ts","../../src/board/board/boarddata/BoardData.ts","../../src/board/board/boarddata/methods/AddChess.ts","../../src/board/board/boarddata/methods/RemoveChess.ts","../../src/board/board/boarddata/methods/HasChess.ts","../../src/board/board/boarddata/methods/Contains.ts","../../src/board/board/boarddata/methods/GetXYZ.ts","../../src/board/board/boarddata/SetBoardWidth.ts","../../src/board/board/boarddata/SetBoardHeight.ts","../../src/board/board/tileposition/TileXYZToChess.ts","../../src/board/chess/ChessData.ts","../../src/board/chess/GetChessData.ts","../../src/board/board/worldposition/GridAlign.ts","../../src/utils/math/angle/Between.ts","../../src/utils/math/angle/RadToDeg.ts","../../src/utils/math/angle/ShortestBetween.ts","../../src/board/board/worldposition/AngleToward.ts","../../src/board/grid/IGrid.ts","../../src/board/board/ILogicBoard.ts","../../src/board/board/tileposition/ForEachTileXY.ts","../../src/utils/math/RandomInt.ts","../../src/utils/array/GetRandom.ts","../../src/board/board/empty/GetRandomEmptyTileXY.ts","../../src/board/board/neighbors/GetTileXYAtDirection.ts","../../src/utils/math/Wrap.ts","../../src/board/board/tileposition/GetWrapTileXY.ts","../../src/board/board/blocker/HasEdgeBlocker.ts","../../src/utils/math/angle/Normalize.ts","../../src/utils/math/fuzzy/Equal.ts","../../src/board/board/worldposition/IsAngleInCone.ts","../../src/board/board/tileposition/IsDirectionInCone.ts","../../src/board/board/transform/Mirror.ts","../../src/board/board/transform/Offset.ts","../../src/board/board/transform/Rotate.ts","../../src/board/board/tileposition/TileXYToChessArray.ts","../../src/board/board/worldposition/WorldXYSnapToGrid.ts","../../src/board/grid/quad/IQuadBase.ts","../../src/board/grid/quad/DirectionToDeltaXY.ts","../../src/board/grid/quad/DeltaTileXYToDirection.ts","../../src/board/grid/hexagon/IHexagonBase.ts","../../src/board/grid/hexagon/HexagonBase.ts","../../src/board/grid/hexagon/CubeTransfer.ts","../../src/board/grid/hexagon/DirectionBetween.ts","../../src/board/grid/hexagon/GetDistance.ts","../../src/board/grid/hexagon/GetWorldXY.ts","../../src/utils/math/angle/DegToRad.ts","../../src/board/grid/hexagon/GetGridPoints.ts","../../src/board/grid/hexagon/DirectionToDeltaTileXY.ts","../../src/board/grid/hexagon/DeltaTileXYToDirection.ts","../../src/board/grid/hexagon/GetParity.ts","../../src/board/grid/hexagon/GetNeighborTileDirection.ts","../../src/board/grid/hexagon/GetTileXYAtDirection.ts","../../src/board/grid/hexagon/GetTileXY.ts","../../src/board/grid/hexagon/Mirror.ts","../../src/board/grid/hexagon/Offset.ts","../../src/board/grid/hexagon/Rotate.ts","../../src/board/grid/hexagon/Hexagon.ts","../../src/board/grid/utils/DirectionNormalize.ts","../../src/board/grid/utils/FillPositionArray.ts","../../src/board/grid/hexagon/GetNeighborTileXY.ts","../../src/board/grid/hexagon/GetOppositeDirection.ts","../../src/board/grid/hexagon/RingToTileXYArray.ts","../../src/board/grid/utils/SaveOrigin.ts","../../src/utils/astar/types/PathMode.ts","../../src/utils/astar/NodeManager.ts","../../src/utils/astar/Search.ts","../../src/utils/struct/BinaryHeap.ts","../../src/utils/astar/Const.ts","../../src/utils/astar/getnodepath/GetAStarNodePath.ts","../../src/utils/astar/getnodepath/GetNodePath.ts","../../src/utils/astar/getnodepath/GetRandomNodePath.ts","../../src/utils/astar/getnodepath/GetLineNodePath.ts","../../src/utils/astar/getnodepath/GetDiagonalPath.ts","../../src/utils/astar/getnodepath/GetStraightNodePath.ts","../../src/utils/astar/AStar.ts","../../src/utils/array/Shuffle.ts","../../src/board/pathfinder/astar/Key.ts","../../src/board/pathfinder/astar/AStarNode.ts","../../src/utils/astar/NodeBase.ts","../../src/board/pathfinder/astar/CreateAStar.ts","../../src/board/pathfinder/GetPath.ts","../../src/board/pathfinder/PathFinder.ts","../../src/board/pathfinder/GetCost.ts","../../src/board/pathfinder/FindArea.ts","../../src/board/pathfinder/FindPath.ts","../../src/board/pathfinder/TileXYToCost.ts","../../src/texture/canvastexture/DrawCanvasTexture.ts","../../src/utils/canvas/GetStyle.ts","../../src/texture/canvastexture/CreatePolygonTexture.ts","../../src/texture/canvastexture/CreateTriangleTexture.ts","../../examples/board-pathfinder/find-path.ts","../../src/board/board/LogicBoard.ts","../../src/board/board/chess/AddChess.ts","../../src/board/board/worldposition/AngleBetween.ts","../../src/board/board/worldposition/AngleSnapToDirection.ts","../../src/board/board/neighbors/AreNeighbors.ts","../../src/board/board/tileposition/ChessToTileXYZ.ts","../../src/board/board/utils/IsTileXYZ.ts","../../src/utils/object/IsPlainObject.ts","../../src/board/board/tileposition/Contains.ts","../../src/board/board/tileposition/DirectionBetween.ts","../../src/board/board/ring/FilledRingToTileXYArray.ts","../../src/board/board/transform/Fit.ts","../../src/board/board/chess/GetAllChess.ts","../../src/board/board/tileposition/GetDistance.ts","../../src/board/board/empty/GetEmptyTileXYArray.ts","../../src/board/board/worldposition/GetGridPoints.ts","../../src/board/board/neighbors/GetNeighborChess.ts","../../src/board/board/neighbors/GetNeighborChessDirection.ts","../../src/board/board/neighbors/GetNeighborTileDirection.ts","../../src/board/board/neighbors/GetNeighborTileXY.ts","../../src/board/board/neighbors/GetNeighborTileXYAtAngle.ts","../../src/board/board/tileposition/GetOppositeDirection.ts","../../src/board/board/blocker/HasBlocker.ts","../../src/board/board/chess/HasChess.ts","../../src/board/board/worldposition/IsOverlappingPoint.ts","../../src/board/board/chess/RemoveAllChess.ts","../../src/board/board/chess/RemoveChess.ts","../../src/board/board/ring/RingToTileXYArray.ts","../../src/board/board/chess/SwapChess.ts","../../src/board/board/tileposition/TileXYArrayToChessArray.ts","../../src/board/board/tileposition/TileZToChessArray.ts","../../src/board/board/worldposition/TileXYArrayToWorldXYArray.ts","../../src/board/board/worldposition/TileXYToWorldXY.ts","../../src/board/board/worldposition/WorldXYToChess.ts","../../src/board/board/worldposition/WorldXYToTileXY.ts","../../node_modules/@phaserjs/phaser/gameobjects/sprite/SetTint.js","../../node_modules/@phaserjs/phaser/Game.js","../../node_modules/@phaserjs/phaser/events/EventEmitter.js","../../node_modules/@phaserjs/phaser/dom/DOMContentLoaded.js","../../node_modules/@phaserjs/phaser/dom/AddToDOM.js","../../node_modules/@phaserjs/phaser/config/Banner.js","../../node_modules/@phaserjs/phaser/config/WebGLRenderer.js","../../node_modules/@phaserjs/phaser/scenes/Scene.js","../../node_modules/@phaserjs/phaser/gameobjects/sprite/SetAlpha.js"],"sourcesContent":["let instance;\r\nlet frame = 0;\r\nlet elapsed = 0;\r\nconst GameInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (game) => {\r\n        instance = game;\r\n    },\r\n    getFrame: () => {\r\n        return frame;\r\n    },\r\n    setFrame: (current) => {\r\n        frame = current;\r\n    },\r\n    getElapsed: () => {\r\n        return elapsed;\r\n    },\r\n    setElapsed: (current) => {\r\n        elapsed = current;\r\n    }\r\n};\n\nexport { GameInstance, elapsed, frame, instance };\n","let bgColor = 0;\r\nfunction BackgroundColor(color = 0) {\r\n    return () => {\r\n        bgColor = color;\r\n    };\r\n}\r\nfunction GetBackgroundColor() {\r\n    return bgColor;\r\n}\n\nexport { BackgroundColor, GetBackgroundColor };\n","let _width = 800;\r\nlet _height = 600;\r\nlet _resolution = 1;\r\nfunction Size(width = 800, height = 600, resolution = 1) {\r\n    if (resolution === 0) {\r\n        resolution = window.devicePixelRatio;\r\n    }\r\n    return () => {\r\n        _width = width;\r\n        _height = height;\r\n        _resolution = resolution;\r\n    };\r\n}\r\nfunction GetWidth() {\r\n    return _width;\r\n}\r\nfunction GetHeight() {\r\n    return _height;\r\n}\r\nfunction GetResolution() {\r\n    return _resolution;\r\n}\n\nexport { GetHeight, GetResolution, GetWidth, Size };\n","const queue = [];\r\nconst BindingQueue = {\r\n    add: (texture) => {\r\n        queue.push(texture);\r\n    },\r\n    get: () => {\r\n        return queue;\r\n    },\r\n    clear: () => {\r\n        queue.length = 0;\r\n    }\r\n};\n\nexport { BindingQueue };\n","let instance;\r\nfunction SetRenderer(renderer) {\r\n    instance = renderer;\r\n}\r\nfunction GetRenderer() {\r\n    return instance;\r\n}\n\nexport { GetRenderer, SetRenderer };\n","let originX = 0.5;\r\nlet originY = 0.5;\r\nfunction DefaultOrigin(x = 0.5, y = x) {\r\n    return () => {\r\n        originX = x;\r\n        originY = y;\r\n    };\r\n}\n\nexport { DefaultOrigin, originX, originY };\n","import { GetElement } from '../dom/GetElement.js';\n\nlet parent;\r\nfunction Parent(parentElement) {\r\n    return () => {\r\n        if (parentElement) {\r\n            parent = GetElement(parentElement);\r\n        }\r\n    };\r\n}\r\nfunction GetParent() {\r\n    return parent;\r\n}\n\nexport { GetParent, Parent };\n","let maxTextures = 0;\r\nfunction MaxTextures(max = 0) {\r\n    return () => {\r\n        maxTextures = max;\r\n    };\r\n}\r\nfunction SetMaxTextures(max) {\r\n    maxTextures = max;\r\n}\r\nfunction GetMaxTextures() {\r\n    return maxTextures;\r\n}\n\nexport { GetMaxTextures, MaxTextures, SetMaxTextures };\n","function GetElement(target) {\r\n    let element;\r\n    if (target) {\r\n        if (typeof target === 'string') {\r\n            element = document.getElementById(target);\r\n        }\r\n        else if (typeof target === 'object' && target.nodeType === 1) {\r\n            element = target;\r\n        }\r\n    }\r\n    if (!element) {\r\n        element = document.body;\r\n    }\r\n    return element;\r\n}\n\nexport { GetElement };\n","let _scenes = [];\r\nfunction Scenes(scenes) {\r\n    return () => {\r\n        _scenes = [].concat(scenes);\r\n    };\r\n}\r\nfunction GetScenes() {\r\n    return _scenes;\r\n}\n\nexport { GetScenes, Scenes };\n","let _contextAttributes = {\r\n    alpha: false,\r\n    antialias: false,\r\n    depth: false,\r\n    premultipliedAlpha: false\r\n};\r\nfunction WebGLContext(contextAttributes) {\r\n    return () => {\r\n        _contextAttributes = contextAttributes;\r\n    };\r\n}\r\nfunction GetWebGLContext() {\r\n    return _contextAttributes;\r\n}\n\nexport { GetWebGLContext, WebGLContext };\n","let gl;\r\nconst GL = {\r\n    get: () => {\r\n        return gl;\r\n    },\r\n    set: (context) => {\r\n        gl = context;\r\n    }\r\n};\n\nexport { GL };\n","class FBOSystem {\r\n    constructor(renderer) {\r\n        this.stack = [];\r\n        this.current = null;\r\n        this.renderer = renderer;\r\n    }\r\n    reset() {\r\n        this.stack = [];\r\n        this.current = null;\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.viewport(0, 0, renderer.width, renderer.height);\r\n    }\r\n    add(framebuffer, clear = true, width = 0, height = 0) {\r\n        this.stack.push({ framebuffer, width, height });\r\n        this.set(framebuffer, clear, width, height);\r\n    }\r\n    set(framebuffer, clear = true, width = 0, height = 0) {\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        if (clear) {\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n        if (width > 0) {\r\n            gl.viewport(0, 0, width, height);\r\n        }\r\n        this.current = framebuffer;\r\n    }\r\n    pop() {\r\n        this.stack.pop();\r\n        const len = this.stack.length;\r\n        if (len > 0) {\r\n            const entry = this.stack[len - 1];\r\n            this.set(entry.framebuffer, false, entry.width, entry.height);\r\n        }\r\n        else {\r\n            this.reset();\r\n        }\r\n    }\r\n    rebind() {\r\n        const gl = this.renderer.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.current);\r\n    }\r\n    destroy() {\r\n        this.stack = [];\r\n    }\r\n}\n\nexport { FBOSystem };\n","import { GL } from '../GL.js';\n\nfunction CreateGLTexture(binding) {\r\n    const gl = GL.get();\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const { parent, flipY, unpackPremultiplyAlpha, minFilter, magFilter, wrapS, wrapT, generateMipmap, isPOT } = binding;\r\n    const source = parent.image;\r\n    let width = parent.width;\r\n    let height = parent.height;\r\n    const glTexture = gl.createTexture();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\r\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, unpackPremultiplyAlpha);\r\n    if (source) {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n        width = source.width;\r\n        height = source.height;\r\n    }\r\n    else {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n    }\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n    if (generateMipmap && isPOT) {\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    binding.texture = glTexture;\r\n    return glTexture;\r\n}\n\nexport { CreateGLTexture };\n","import { GL } from '../GL.js';\n\nfunction DeleteGLTexture(texture) {\r\n    const gl = GL.get();\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    if (gl.isTexture(texture)) {\r\n        gl.deleteTexture(texture);\r\n    }\r\n}\n\nexport { DeleteGLTexture };\n","import { GL } from '../GL.js';\nimport { CreateGLTexture } from './CreateGLTexture.js';\nimport { DeleteFramebuffer } from '../fbo/DeleteFramebuffer.js';\nimport { DeleteGLTexture } from './DeleteGLTexture.js';\nimport { IsSizePowerOfTwo } from '../../../math/pow2/IsSizePowerOfTwo.js';\nimport { SetGLTextureFilterMode } from './SetGLTextureFilterMode.js';\nimport { UpdateGLTexture } from './UpdateGLTexture.js';\n\nclass GLTextureBinding {\r\n    constructor(parent, config = {}) {\r\n        this.index = 0;\r\n        this.indexCounter = -1;\r\n        this.dirtyIndex = true;\r\n        this.unpackPremultiplyAlpha = true;\r\n        this.flipY = false;\r\n        this.isPOT = false;\r\n        this.generateMipmap = false;\r\n        const gl = GL.get();\r\n        this.parent = parent;\r\n        this.isPOT = IsSizePowerOfTwo(parent.width, parent.height);\r\n        const { texture = null, framebuffer = null, unpackPremultiplyAlpha = true, minFilter = gl.LINEAR, magFilter = gl.LINEAR, wrapS = gl.CLAMP_TO_EDGE, wrapT = gl.CLAMP_TO_EDGE, generateMipmap = this.isPOT, flipY = false } = config;\r\n        this.minFilter = minFilter;\r\n        this.magFilter = magFilter;\r\n        this.wrapS = wrapS;\r\n        this.wrapT = wrapT;\r\n        this.generateMipmap = generateMipmap;\r\n        this.flipY = flipY;\r\n        this.unpackPremultiplyAlpha = unpackPremultiplyAlpha;\r\n        if (framebuffer) {\r\n            this.framebuffer = framebuffer;\r\n        }\r\n        if (texture) {\r\n            this.texture = texture;\r\n        }\r\n        else {\r\n            CreateGLTexture(this);\r\n        }\r\n    }\r\n    setFilter(linear) {\r\n        if (this.texture) {\r\n            SetGLTextureFilterMode(this.texture, linear);\r\n        }\r\n    }\r\n    create() {\r\n        const texture = this.texture;\r\n        if (texture) {\r\n            DeleteGLTexture(texture);\r\n        }\r\n        return CreateGLTexture(this);\r\n    }\r\n    update() {\r\n        const texture = this.texture;\r\n        if (!texture) {\r\n            return CreateGLTexture(this);\r\n        }\r\n        else {\r\n            return UpdateGLTexture(this);\r\n        }\r\n    }\r\n    setIndex(index) {\r\n        this.dirtyIndex = (index !== this.index);\r\n        this.index = index;\r\n    }\r\n    destroy() {\r\n        DeleteGLTexture(this.texture);\r\n        DeleteFramebuffer(this.framebuffer);\r\n        this.parent = null;\r\n        this.texture = null;\r\n        this.framebuffer = null;\r\n    }\r\n}\n\nexport { GLTextureBinding };\n","function IsSizePowerOfTwo(width, height) {\r\n    if (width < 1 || height < 1) {\r\n        return false;\r\n    }\r\n    return ((width & (width - 1)) === 0) && ((height & (height - 1)) === 0);\r\n}\n\nexport { IsSizePowerOfTwo };\n","import { GL } from '../GL.js';\n\nfunction SetGLTextureFilterMode(texture, linear = true) {\r\n    const gl = GL.get();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    const mode = (linear) ? gl.LINEAR : gl.NEAREST;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);\r\n}\n\nexport { SetGLTextureFilterMode };\n","import { GL } from '../GL.js';\n\nfunction UpdateGLTexture(binding) {\r\n    const gl = GL.get();\r\n    const source = binding.parent.image;\r\n    const width = source.width;\r\n    const height = source.height;\r\n    if (width > 0 && height > 0) {\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, binding.flipY);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n    }\r\n    return binding.texture;\r\n}\n\nexport { UpdateGLTexture };\n","import { GL } from '../GL.js';\n\nfunction DeleteFramebuffer(framebuffer) {\r\n    const gl = GL.get();\r\n    if (gl && gl.isFramebuffer(framebuffer)) {\r\n        gl.deleteFramebuffer(framebuffer);\r\n    }\r\n}\n\nexport { DeleteFramebuffer };\n","import { GL } from '../GL.js';\n\nclass IndexedBuffer {\r\n    constructor(batchSize, dataSize, indexSize, vertexElementSize, quadIndexSize) {\r\n        this.batchSize = batchSize;\r\n        this.dataSize = dataSize;\r\n        this.indexSize = indexSize;\r\n        this.vertexElementSize = vertexElementSize;\r\n        this.quadIndexSize = quadIndexSize;\r\n        this.vertexByteSize = vertexElementSize * dataSize;\r\n        this.quadByteSize = this.vertexByteSize * 4;\r\n        this.quadElementSize = vertexElementSize * 4;\r\n        this.bufferByteSize = batchSize * this.quadByteSize;\r\n        this.create();\r\n    }\r\n    create() {\r\n        let ibo = [];\r\n        for (let i = 0; i < (this.batchSize * this.indexSize); i += this.indexSize) {\r\n            ibo.push(i + 0, i + 1, i + 2, i + 2, i + 3, i + 0);\r\n        }\r\n        this.data = new ArrayBuffer(this.bufferByteSize);\r\n        this.index = new Uint16Array(ibo);\r\n        this.vertexViewF32 = new Float32Array(this.data);\r\n        this.vertexViewU32 = new Uint32Array(this.data);\r\n        const gl = GL.get();\r\n        this.vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);\r\n        this.indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.index, gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        ibo = [];\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { IndexedBuffer };\n","class Frame {\r\n    constructor(texture, key, x, y, width, height) {\r\n        this.trimmed = false;\r\n        this.texture = texture;\r\n        this.key = key;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.updateUVs();\r\n    }\r\n    setPivot(x, y) {\r\n        this.pivot = { x, y };\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.updateUVs();\r\n    }\r\n    setSourceSize(width, height) {\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n    }\r\n    setTrim(width, height, x, y, w, h) {\r\n        this.trimmed = true;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.spriteSourceSizeX = x;\r\n        this.spriteSourceSizeY = y;\r\n        this.spriteSourceSizeWidth = w;\r\n        this.spriteSourceSizeHeight = h;\r\n    }\r\n    getExtent(originX, originY) {\r\n        const sourceSizeWidth = this.sourceSizeWidth;\r\n        const sourceSizeHeight = this.sourceSizeHeight;\r\n        let left;\r\n        let right;\r\n        let top;\r\n        let bottom;\r\n        if (this.trimmed) {\r\n            left = this.spriteSourceSizeX - (originX * sourceSizeWidth);\r\n            right = left + this.spriteSourceSizeWidth;\r\n            top = this.spriteSourceSizeY - (originY * sourceSizeHeight);\r\n            bottom = top + this.spriteSourceSizeHeight;\r\n        }\r\n        else {\r\n            left = -originX * sourceSizeWidth;\r\n            right = left + sourceSizeWidth;\r\n            top = -originY * sourceSizeHeight;\r\n            bottom = top + sourceSizeHeight;\r\n        }\r\n        return { left, right, top, bottom };\r\n    }\r\n    setExtent(child) {\r\n        const transform = child.transform;\r\n        const originX = transform.origin.x;\r\n        const originY = transform.origin.y;\r\n        const sourceSizeWidth = this.sourceSizeWidth;\r\n        const sourceSizeHeight = this.sourceSizeHeight;\r\n        let x;\r\n        let y;\r\n        let width;\r\n        let height;\r\n        if (this.trimmed) {\r\n            x = this.spriteSourceSizeX - (originX * sourceSizeWidth);\r\n            y = this.spriteSourceSizeY - (originY * sourceSizeHeight);\r\n            width = this.spriteSourceSizeWidth;\r\n            height = this.spriteSourceSizeHeight;\r\n        }\r\n        else {\r\n            x = -originX * sourceSizeWidth;\r\n            y = -originY * sourceSizeHeight;\r\n            width = sourceSizeWidth;\r\n            height = sourceSizeHeight;\r\n        }\r\n        transform.setExtent(x, y, width, height);\r\n    }\r\n    updateUVs() {\r\n        const { x, y, width, height } = this;\r\n        const baseTextureWidth = this.texture.width;\r\n        const baseTextureHeight = this.texture.height;\r\n        this.u0 = x / baseTextureWidth;\r\n        this.v0 = y / baseTextureHeight;\r\n        this.u1 = (x + width) / baseTextureWidth;\r\n        this.v1 = (y + height) / baseTextureHeight;\r\n    }\r\n}\n\nexport { Frame };\n","import { BindingQueue } from '../renderer/BindingQueue.js';\nimport { Frame } from './Frame.js';\n\nclass Texture {\r\n    constructor(image, width, height) {\r\n        this.key = '';\r\n        if (image) {\r\n            width = image.width;\r\n            height = image.height;\r\n        }\r\n        this.image = image;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.frames = new Map();\r\n        this.data = {};\r\n        this.addFrame('__BASE', 0, 0, width, height);\r\n        BindingQueue.add(this);\r\n    }\r\n    addFrame(key, x, y, width, height) {\r\n        if (this.frames.has(key)) {\r\n            return null;\r\n        }\r\n        const frame = new Frame(this, key, x, y, width, height);\r\n        this.frames.set(key, frame);\r\n        if (!this.firstFrame || this.firstFrame.key === '__BASE') {\r\n            this.firstFrame = frame;\r\n        }\r\n        return frame;\r\n    }\r\n    getFrame(key) {\r\n        if (!key) {\r\n            return this.firstFrame;\r\n        }\r\n        if (key instanceof Frame) {\r\n            key = key.key;\r\n        }\r\n        let frame = this.frames.get(key);\r\n        if (!frame) {\r\n            console.warn(`Frame missing: ${key}`);\r\n            frame = this.firstFrame;\r\n        }\r\n        return frame;\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        const frame = this.frames.get('__BASE');\r\n        frame.setSize(width, height);\r\n    }\r\n    destroy() {\r\n        if (this.binding) {\r\n            this.binding.destroy();\r\n        }\r\n        this.frames.clear();\r\n        this.data = null;\r\n        this.image = null;\r\n        this.firstFrame = null;\r\n    }\r\n}\n\nexport { Texture };\n","let instance;\r\nconst WebGLRendererInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (renderer) => {\r\n        instance = renderer;\r\n    }\r\n};\n\nexport { WebGLRendererInstance, instance };\n","import { GetWidth, GetHeight, GetResolution } from '../../../config/Size.js';\nimport '../../BindingQueue.js';\nimport '../GL.js';\nimport { CreateFramebuffer } from '../fbo/CreateFramebuffer.js';\nimport '../textures/CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport '../textures/DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport '../textures/SetGLTextureFilterMode.js';\nimport '../textures/UpdateGLTexture.js';\nimport { GLTextureBinding } from '../textures/GLTextureBinding.js';\nimport { IndexedBuffer } from '../buffers/IndexedBuffer.js';\nimport '../../../textures/Frame.js';\nimport { Texture } from '../../../textures/Texture.js';\nimport { WebGLRendererInstance } from '../WebGLRendererInstance.js';\n\nconst shaderSource = {\r\n    fragmentShader: `\r\n#define SHADER_NAME SINGLE_QUAD_FRAG\r\n\r\nprecision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nuniform sampler2D uTexture;\r\n\r\nvoid main (void)\r\n{\r\n    vec4 color = texture2D(uTexture, vTextureCoord);\r\n\r\n    gl_FragColor = color * vec4(vTintColor.bgr * vTintColor.a, vTintColor.a);\r\n}`,\r\n    vertexShader: `\r\n#define SHADER_NAME SINGLE_QUAD_VERT\r\n\r\nprecision highp float;\r\n\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute float aTextureId;\r\nattribute vec4 aTintColor;\r\n\r\nuniform mat4 uProjectionMatrix;\r\nuniform mat4 uCameraMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nvoid main (void)\r\n{\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vTintColor = aTintColor;\r\n\r\n    gl_Position = uProjectionMatrix * uCameraMatrix * vec4(aVertexPosition, 0.0, 1.0);\r\n}`\r\n};\r\nclass SingleTextureQuadShader {\r\n    constructor(config = {}) {\r\n        this.attribs = { aVertexPosition: 0, aTextureCoord: 0, aTextureId: 0, aTintColor: 0 };\r\n        this.uniforms = { uProjectionMatrix: 0, uCameraMatrix: 0, uTexture: 0, uTime: 0, uResolution: 0 };\r\n        this.renderToFBO = false;\r\n        this.renderer = WebGLRendererInstance.get();\r\n        const { batchSize = 4096, dataSize = 4, indexSize = 4, vertexElementSize = 6, quadIndexSize = 6, fragmentShader = shaderSource.fragmentShader, vertexShader = shaderSource.vertexShader, width = GetWidth(), height = GetHeight(), resolution = GetResolution(), renderToFBO = false } = config;\r\n        this.buffer = new IndexedBuffer(batchSize, dataSize, indexSize, vertexElementSize, quadIndexSize);\r\n        this.createShaders(fragmentShader, vertexShader);\r\n        this.count = 0;\r\n        this.renderToFBO = renderToFBO;\r\n        const texture = new Texture(null, width * resolution, height * resolution);\r\n        const binding = new GLTextureBinding(texture);\r\n        texture.binding = binding;\r\n        binding.framebuffer = CreateFramebuffer(binding.texture);\r\n        this.texture = texture;\r\n        this.framebuffer = binding.framebuffer;\r\n    }\r\n    createShaders(fragmentShaderSource, vertexShaderSource) {\r\n        const gl = this.renderer.gl;\r\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n        gl.compileShader(fragmentShader);\r\n        let failed = false;\r\n        let message = gl.getShaderInfoLog(fragmentShader);\r\n        if (message.length > 0) {\r\n            failed = true;\r\n            console.error(message);\r\n        }\r\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertexShader, vertexShaderSource);\r\n        gl.compileShader(vertexShader);\r\n        message = gl.getShaderInfoLog(fragmentShader);\r\n        if (message.length > 0) {\r\n            failed = true;\r\n            console.error(message);\r\n        }\r\n        if (failed) {\r\n            return;\r\n        }\r\n        const program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n        gl.useProgram(program);\r\n        this.program = program;\r\n        for (const key of Object.keys(this.attribs)) {\r\n            const location = gl.getAttribLocation(program, key);\r\n            gl.enableVertexAttribArray(location);\r\n            this.attribs[key] = location;\r\n        }\r\n        for (const key of Object.keys(this.uniforms)) {\r\n            this.uniforms[key] = gl.getUniformLocation(program, key);\r\n        }\r\n    }\r\n    bind(projectionMatrix, cameraMatrix, textureID) {\r\n        if (!this.program) {\r\n            return false;\r\n        }\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        const uniforms = this.uniforms;\r\n        gl.useProgram(this.program);\r\n        gl.uniformMatrix4fv(uniforms.uProjectionMatrix, false, projectionMatrix);\r\n        gl.uniformMatrix4fv(uniforms.uCameraMatrix, false, cameraMatrix);\r\n        gl.uniform1i(uniforms.uTexture, renderer.textures.textureIndex[textureID]);\r\n        gl.uniform1f(uniforms.uTime, performance.now());\r\n        gl.uniform2f(uniforms.uResolution, renderer.width, renderer.height);\r\n        this.bindBuffers(this.buffer.indexBuffer, this.buffer.vertexBuffer);\r\n        return true;\r\n    }\r\n    bindBuffers(indexBuffer, vertexBuffer) {\r\n        const gl = this.renderer.gl;\r\n        const stride = this.buffer.vertexByteSize;\r\n        const attribs = this.attribs;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.vertexAttribPointer(attribs.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\r\n        gl.vertexAttribPointer(attribs.aTextureCoord, 2, gl.FLOAT, false, stride, 8);\r\n        gl.vertexAttribPointer(attribs.aTextureId, 1, gl.FLOAT, false, stride, 16);\r\n        gl.vertexAttribPointer(attribs.aTintColor, 4, gl.UNSIGNED_BYTE, true, stride, 20);\r\n        this.count = 0;\r\n    }\r\n    draw(count) {\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        const buffer = this.buffer;\r\n        if (count === buffer.batchSize) {\r\n            gl.bufferData(gl.ARRAY_BUFFER, buffer.data, gl.DYNAMIC_DRAW);\r\n        }\r\n        else {\r\n            const view = buffer.vertexViewF32.subarray(0, count * buffer.quadElementSize);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\r\n        }\r\n        if (this.renderToFBO) {\r\n            renderer.fbo.add(this.framebuffer, true);\r\n        }\r\n        gl.drawElements(gl.TRIANGLES, count * buffer.quadIndexSize, gl.UNSIGNED_SHORT, 0);\r\n        if (this.renderToFBO) {\r\n            renderer.fbo.pop();\r\n        }\r\n    }\r\n    flush() {\r\n        const count = this.count;\r\n        if (count === 0) {\r\n            return false;\r\n        }\r\n        this.draw(count);\r\n        this.prevCount = count;\r\n        this.count = 0;\r\n        return true;\r\n    }\r\n}\n\nexport { SingleTextureQuadShader };\n","import { GL } from '../GL.js';\n\nfunction CreateFramebuffer(texture, attachment) {\r\n    const gl = GL.get();\r\n    if (!attachment) {\r\n        attachment = gl.COLOR_ATTACHMENT0;\r\n    }\r\n    const framebuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, 0);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    return framebuffer;\r\n}\n\nexport { CreateFramebuffer };\n","import '../../../config/Size.js';\nimport '../../BindingQueue.js';\nimport { GetMaxTextures } from '../../../config/MaxTextures.js';\nimport '../GL.js';\nimport '../fbo/CreateFramebuffer.js';\nimport '../textures/CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport '../textures/DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport '../textures/SetGLTextureFilterMode.js';\nimport '../textures/UpdateGLTexture.js';\nimport '../textures/GLTextureBinding.js';\nimport '../buffers/IndexedBuffer.js';\nimport '../../../textures/Frame.js';\nimport '../../../textures/Texture.js';\nimport '../WebGLRendererInstance.js';\nimport { SingleTextureQuadShader } from './SingleTextureQuadShader.js';\n\nconst fragmentShader = `\r\n#define SHADER_NAME MULTI_QUAD_FRAG\r\n\r\nprecision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nuniform sampler2D uTexture[%count%];\r\n\r\nvoid main (void)\r\n{\r\n    vec4 color;\r\n\r\n    %forloop%\r\n\r\n    gl_FragColor = color * vec4(vTintColor.bgr * vTintColor.a, vTintColor.a);\r\n}`;\r\nclass MultiTextureQuadShader extends SingleTextureQuadShader {\r\n    constructor(config = { fragmentShader }) {\r\n        super(config);\r\n    }\r\n    createShaders(fragmentShaderSource, vertexShaderSource) {\r\n        const maxTextures = GetMaxTextures();\r\n        let src = '';\r\n        for (let i = 1; i < maxTextures; i++) {\r\n            if (i > 1) {\r\n                src += '\\n\\telse ';\r\n            }\r\n            if (i < maxTextures - 1) {\r\n                src += `if (vTextureId < ${i}.5)`;\r\n            }\r\n            src += '\\n\\t{';\r\n            src += `\\n\\t\\tcolor = texture2D(uTexture[${i}], vTextureCoord);`;\r\n            src += '\\n\\t}';\r\n        }\r\n        fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, `${maxTextures}`);\r\n        fragmentShaderSource = fragmentShaderSource.replace(/%forloop%/gi, src);\r\n        super.createShaders(fragmentShaderSource, vertexShaderSource);\r\n    }\r\n    bind(projectionMatrix, cameraMatrix) {\r\n        if (!this.program) {\r\n            return false;\r\n        }\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        const uniforms = this.uniforms;\r\n        gl.useProgram(this.program);\r\n        gl.uniformMatrix4fv(uniforms.uProjectionMatrix, false, projectionMatrix);\r\n        gl.uniformMatrix4fv(uniforms.uCameraMatrix, false, cameraMatrix);\r\n        gl.uniform1iv(uniforms.uTexture, renderer.textures.textureIndex);\r\n        gl.uniform1f(uniforms.uTime, performance.now());\r\n        gl.uniform2f(uniforms.uResolution, renderer.width, renderer.height);\r\n        this.bindBuffers(this.buffer.indexBuffer, this.buffer.vertexBuffer);\r\n        return true;\r\n    }\r\n}\n\nexport { MultiTextureQuadShader };\n","import '../../../config/Size.js';\nimport '../../BindingQueue.js';\nimport '../GL.js';\nimport '../fbo/CreateFramebuffer.js';\nimport '../textures/CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport '../textures/DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport '../textures/SetGLTextureFilterMode.js';\nimport '../textures/UpdateGLTexture.js';\nimport '../textures/GLTextureBinding.js';\nimport '../buffers/IndexedBuffer.js';\nimport '../../../textures/Frame.js';\nimport '../../../textures/Texture.js';\nimport '../WebGLRendererInstance.js';\nimport { SingleTextureQuadShader } from './SingleTextureQuadShader.js';\n\nclass ShaderSystem {\r\n    constructor(renderer, currentShader) {\r\n        this.renderer = renderer;\r\n        const stackEntry = {\r\n            shader: new currentShader()\r\n        };\r\n        this.stack = [stackEntry];\r\n        this.currentEntry = stackEntry;\r\n        this.current = stackEntry.shader;\r\n        this.singleQuadShader = new SingleTextureQuadShader();\r\n    }\r\n    add(shader, textureID) {\r\n        const stackEntry = { shader, textureID };\r\n        this.stack.push(stackEntry);\r\n        return stackEntry;\r\n    }\r\n    set(shader, textureID) {\r\n        this.flush();\r\n        const renderer = this.renderer;\r\n        const projectionMatrix = renderer.projectionMatrix;\r\n        const cameraMatrix = renderer.currentCamera.matrix;\r\n        const success = shader.bind(projectionMatrix, cameraMatrix, textureID);\r\n        if (success) {\r\n            const entry = this.add(shader, textureID);\r\n            this.currentEntry = entry;\r\n            this.current = shader;\r\n        }\r\n        return success;\r\n    }\r\n    setDefault(textureID) {\r\n        this.set(this.singleQuadShader, textureID);\r\n    }\r\n    pop() {\r\n        this.flush();\r\n        const stack = this.stack;\r\n        if (stack.length > 1) {\r\n            stack.pop();\r\n        }\r\n        this.currentEntry = stack[stack.length - 1];\r\n        this.current = this.currentEntry.shader;\r\n    }\r\n    reset() {\r\n        this.pop();\r\n        this.rebind();\r\n    }\r\n    flush() {\r\n        if (this.current.flush()) {\r\n            this.renderer.flushTotal++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    rebind() {\r\n        const renderer = this.renderer;\r\n        const projectionMatrix = renderer.projectionMatrix;\r\n        const cameraMatrix = renderer.currentCamera.matrix;\r\n        const current = this.currentEntry;\r\n        current.shader.bind(projectionMatrix, cameraMatrix, current.textureID);\r\n    }\r\n    popAndRebind() {\r\n        this.pop();\r\n        this.rebind();\r\n    }\r\n    clear() {\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { ShaderSystem };\n","const fragTemplate = [\r\n    'precision mediump float;',\r\n    'void main(void){',\r\n    'float test = 0.1;',\r\n    '%forloop%',\r\n    'gl_FragColor = vec4(0.0);',\r\n    '}'\r\n].join('\\n');\r\nfunction GenerateSrc(maxIfs) {\r\n    let src = '';\r\n    for (let i = 0; i < maxIfs; ++i) {\r\n        if (i > 0) {\r\n            src += '\\nelse ';\r\n        }\r\n        if (i < maxIfs - 1) {\r\n            src += `if(test == ${i}.0){}`;\r\n        }\r\n    }\r\n    return src;\r\n}\r\nfunction CheckShaderMaxIfStatements(maxIfs, gl) {\r\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    while (true) {\r\n        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxIfs));\r\n        gl.shaderSource(shader, fragmentSrc);\r\n        gl.compileShader(shader);\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            maxIfs = (maxIfs / 2) | 0;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return maxIfs;\r\n}\n\nexport { CheckShaderMaxIfStatements };\n","import { BindingQueue } from '../../BindingQueue.js';\nimport { SetMaxTextures, GetMaxTextures } from '../../../config/MaxTextures.js';\nimport '../GL.js';\nimport './CreateGLTexture.js';\nimport '../fbo/DeleteFramebuffer.js';\nimport './DeleteGLTexture.js';\nimport '../../../math/pow2/IsSizePowerOfTwo.js';\nimport './SetGLTextureFilterMode.js';\nimport './UpdateGLTexture.js';\nimport { GLTextureBinding } from './GLTextureBinding.js';\nimport { CheckShaderMaxIfStatements } from '../shaders/CheckShaderMaxIfStatements.js';\n\nclass TextureSystem {\r\n    constructor(renderer) {\r\n        this.startActiveTexture = 0;\r\n        this.renderer = renderer;\r\n        this.tempTextures = [];\r\n        this.textureIndex = [];\r\n    }\r\n    init() {\r\n        const gl = this.renderer.gl;\r\n        let maxGPUTextures = CheckShaderMaxIfStatements(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), gl);\r\n        const maxConfigTextures = GetMaxTextures();\r\n        if (maxConfigTextures === 0 || (maxConfigTextures > 0 && maxConfigTextures > maxGPUTextures)) {\r\n            SetMaxTextures(maxGPUTextures);\r\n        }\r\n        else if (maxConfigTextures > 0 && maxConfigTextures < maxGPUTextures) {\r\n            maxGPUTextures = Math.max(8, maxConfigTextures);\r\n        }\r\n        const tempTextures = this.tempTextures;\r\n        if (tempTextures.length) {\r\n            tempTextures.forEach(texture => {\r\n                gl.deleteTexture(texture);\r\n            });\r\n        }\r\n        const index = [];\r\n        for (let texturesIndex = 0; texturesIndex < maxGPUTextures; texturesIndex++) {\r\n            const tempTexture = gl.createTexture();\r\n            gl.activeTexture(gl.TEXTURE0 + texturesIndex);\r\n            gl.bindTexture(gl.TEXTURE_2D, tempTexture);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n            tempTextures[texturesIndex] = tempTexture;\r\n            index.push(texturesIndex);\r\n        }\r\n        this.maxTextures = maxGPUTextures;\r\n        this.textureIndex = index;\r\n        this.currentActiveTexture = 1;\r\n    }\r\n    update() {\r\n        const queue = BindingQueue.get();\r\n        for (let i = 0; i < queue.length; i++) {\r\n            const texture = queue[i];\r\n            if (!texture.binding) {\r\n                texture.binding = new GLTextureBinding(texture);\r\n            }\r\n        }\r\n        BindingQueue.clear();\r\n    }\r\n    reset() {\r\n        const gl = this.renderer.gl;\r\n        const temp = this.tempTextures;\r\n        for (let i = 0; i < temp.length; i++) {\r\n            gl.activeTexture(gl.TEXTURE0 + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, temp[i]);\r\n        }\r\n        this.currentActiveTexture = 1;\r\n        this.startActiveTexture++;\r\n    }\r\n    bind(texture, index = 0) {\r\n        const gl = this.renderer.gl;\r\n        const binding = texture.binding;\r\n        binding.setIndex(index);\r\n        gl.activeTexture(gl.TEXTURE0 + index);\r\n        gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n    }\r\n    unbind(index = 0) {\r\n        const gl = this.renderer.gl;\r\n        gl.activeTexture(gl.TEXTURE0 + index);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.tempTextures[index]);\r\n        if (index > 0) {\r\n            this.startActiveTexture++;\r\n        }\r\n    }\r\n    request(texture) {\r\n        const gl = this.renderer.gl;\r\n        const binding = texture.binding;\r\n        const currentActiveTexture = this.currentActiveTexture;\r\n        if (binding.indexCounter >= this.startActiveTexture) {\r\n            return false;\r\n        }\r\n        binding.indexCounter = this.startActiveTexture;\r\n        if (currentActiveTexture < this.maxTextures) {\r\n            binding.setIndex(currentActiveTexture);\r\n            gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);\r\n            gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n            this.currentActiveTexture++;\r\n        }\r\n        else {\r\n            this.renderer.flush();\r\n            this.startActiveTexture++;\r\n            binding.indexCounter = this.startActiveTexture;\r\n            binding.setIndex(1);\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, binding.texture);\r\n            this.currentActiveTexture = 2;\r\n        }\r\n        return true;\r\n    }\r\n}\n\nexport { TextureSystem };\n","import { GetBackgroundColor } from '../../config/BackgroundColor.js';\nimport { GetWidth, GetHeight, GetResolution } from '../../config/Size.js';\nimport '../BindingQueue.js';\nimport '../../config/MaxTextures.js';\nimport { GetWebGLContext } from '../../config/WebGLContext.js';\nimport { FBOSystem } from './fbo/FBOSystem.js';\nimport { GL } from './GL.js';\nimport { GetRGBArray } from './colors/GetRGBArray.js';\nimport { ExactEquals } from '../../math/matrix2d-funcs/ExactEquals.js';\nimport './fbo/CreateFramebuffer.js';\nimport './textures/CreateGLTexture.js';\nimport './fbo/DeleteFramebuffer.js';\nimport './textures/DeleteGLTexture.js';\nimport '../../math/pow2/IsSizePowerOfTwo.js';\nimport './textures/SetGLTextureFilterMode.js';\nimport './textures/UpdateGLTexture.js';\nimport './textures/GLTextureBinding.js';\nimport './buffers/IndexedBuffer.js';\nimport '../../textures/Frame.js';\nimport '../../textures/Texture.js';\nimport { WebGLRendererInstance } from './WebGLRendererInstance.js';\nimport './shaders/SingleTextureQuadShader.js';\nimport { MultiTextureQuadShader } from './shaders/MultiTextureQuadShader.js';\nimport { Ortho } from './cameras/Ortho.js';\nimport { ShaderSystem } from './shaders/ShaderSystem.js';\nimport './shaders/CheckShaderMaxIfStatements.js';\nimport { TextureSystem } from './textures/TextureSystem.js';\n\nclass WebGLRenderer {\r\n    constructor() {\r\n        this.clearColor = [0, 0, 0, 1];\r\n        this.flushTotal = 0;\r\n        this.clearBeforeRender = true;\r\n        this.optimizeRedraw = false;\r\n        this.autoResize = true;\r\n        this.contextLost = false;\r\n        this.currentCamera = null;\r\n        this.width = GetWidth();\r\n        this.height = GetHeight();\r\n        this.resolution = GetResolution();\r\n        this.setBackgroundColor(GetBackgroundColor());\r\n        const canvas = document.createElement('canvas');\r\n        canvas.addEventListener('webglcontextlost', (event) => this.onContextLost(event), false);\r\n        canvas.addEventListener('webglcontextrestored', () => this.onContextRestored(), false);\r\n        this.canvas = canvas;\r\n        this.fbo = new FBOSystem(this);\r\n        this.textures = new TextureSystem(this);\r\n        this.initContext();\r\n        WebGLRendererInstance.set(this);\r\n        this.shaders = new ShaderSystem(this, MultiTextureQuadShader);\r\n    }\r\n    initContext() {\r\n        const gl = this.canvas.getContext('webgl', GetWebGLContext());\r\n        GL.set(gl);\r\n        this.gl = gl;\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n        this.resize(this.width, this.height, this.resolution);\r\n        this.textures.init();\r\n    }\r\n    resize(width, height, resolution = 1) {\r\n        this.width = width * resolution;\r\n        this.height = height * resolution;\r\n        this.resolution = resolution;\r\n        const canvas = this.canvas;\r\n        canvas.width = this.width;\r\n        canvas.height = this.height;\r\n        if (this.autoResize) {\r\n            canvas.style.width = (this.width / resolution).toString() + 'px';\r\n            canvas.style.height = (this.height / resolution).toString() + 'px';\r\n        }\r\n        this.gl.viewport(0, 0, this.width, this.height);\r\n        this.projectionMatrix = Ortho(width, height);\r\n    }\r\n    onContextLost(event) {\r\n        event.preventDefault();\r\n        this.contextLost = true;\r\n    }\r\n    onContextRestored() {\r\n        this.contextLost = false;\r\n        this.initContext();\r\n    }\r\n    setBackgroundColor(color) {\r\n        GetRGBArray(color, this.clearColor);\r\n        return this;\r\n    }\r\n    reset(framebuffer = null, width = this.width, height = this.height) {\r\n        const gl = this.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        gl.viewport(0, 0, width, height);\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        this.flushTotal = 0;\r\n        this.currentCamera = null;\r\n        this.textures.update();\r\n    }\r\n    render(renderData) {\r\n        if (this.contextLost) {\r\n            return;\r\n        }\r\n        this.reset();\r\n        if (this.optimizeRedraw && renderData.numDirtyFrames === 0 && renderData.numDirtyCameras === 0) {\r\n            return;\r\n        }\r\n        const gl = this.gl;\r\n        if (this.clearBeforeRender) {\r\n            const cls = this.clearColor;\r\n            gl.clearColor(cls[0], cls[1], cls[2], cls[3]);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n        const worlds = renderData.worldData;\r\n        for (let i = 0; i < worlds.length; i++) {\r\n            const { camera, renderList } = worlds[i];\r\n            if (!this.currentCamera || !ExactEquals(camera.worldTransform, this.currentCamera.worldTransform)) {\r\n                this.flush();\r\n                this.currentCamera = camera;\r\n                this.shaders.rebind();\r\n            }\r\n            renderList.forEach(entry => {\r\n                if (entry.children.length) {\r\n                    this.renderNode(entry);\r\n                }\r\n                else {\r\n                    entry.node.renderGL(this);\r\n                }\r\n            });\r\n        }\r\n        this.flush();\r\n    }\r\n    renderNode(entry) {\r\n        entry.node.renderGL(this);\r\n        entry.children.forEach(child => {\r\n            if (child.children.length > 0) {\r\n                this.renderNode(child);\r\n            }\r\n            else {\r\n                child.node.renderGL(this);\r\n            }\r\n        });\r\n        entry.node.postRenderGL(this);\r\n    }\r\n    flush() {\r\n        this.shaders.flush();\r\n    }\r\n    destroy() {\r\n        WebGLRendererInstance.set(undefined);\r\n    }\r\n}\n\nexport { WebGLRenderer };\n","function Ortho(width, height, near = -1, far = 1) {\r\n    const m00 = -2 * (1 / -width);\r\n    const m11 = -2 * (1 / height);\r\n    const m22 = 2 * (1 / (near - far));\r\n    return new Float32Array([m00, 0, 0, 0, 0, m11, 0, 0, 0, 0, m22, 0, -1, 1, 0, 1]);\r\n}\n\nexport { Ortho };\n","function GetRGBArray(color, output = []) {\r\n    const r = color >> 16 & 0xFF;\r\n    const g = color >> 8 & 0xFF;\r\n    const b = color & 0xFF;\r\n    const a = (color > 16777215) ? color >>> 24 : 255;\r\n    output[0] = r / 255;\r\n    output[1] = g / 255;\r\n    output[2] = b / 255;\r\n    output[3] = a / 255;\r\n    return output;\r\n}\n\nexport { GetRGBArray };\n","function ExactEquals(a, b) {\r\n    return (a.a === b.a &&\r\n        a.b === b.b &&\r\n        a.c === b.c &&\r\n        a.d === b.d &&\r\n        a.tx === b.tx &&\r\n        a.ty === b.ty);\r\n}\n\nexport { ExactEquals };\n","class Matrix2D {\r\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.set(a, b, c, d, tx, ty);\r\n    }\r\n    set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n        return this;\r\n    }\r\n    identity() {\r\n        return this.set();\r\n    }\r\n    toArray() {\r\n        return [this.a, this.b, this.c, this.d, this.tx, this.ty];\r\n    }\r\n    fromArray(src) {\r\n        return this.set(src[0], src[1], src[2], src[3], src[4], src[5]);\r\n    }\r\n}\n\nexport { Matrix2D };\n","import { Contains } from './Contains.js';\n\nclass Rectangle {\r\n    constructor(x = 0, y = 0, width = 0, height = 0) {\r\n        this.set(x, y, width, height);\r\n    }\r\n    set(x = 0, y = 0, width = 0, height = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    contains(x, y) {\r\n        return Contains(this, x, y);\r\n    }\r\n    set right(value) {\r\n        if (value <= this.x) {\r\n            this.width = 0;\r\n        }\r\n        else {\r\n            this.width = value - this.x;\r\n        }\r\n    }\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    set bottom(value) {\r\n        if (value <= this.y) {\r\n            this.height = 0;\r\n        }\r\n        else {\r\n            this.height = value - this.y;\r\n        }\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n}\n\nexport { Rectangle };\n","function Contains(rect, x, y) {\r\n    if (rect.width <= 0 || rect.height <= 0) {\r\n        return false;\r\n    }\r\n    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);\r\n}\n\nexport { Contains };\n","function NOOP() {\r\n}\n\nexport { NOOP };\n","import { NOOP } from '../../utils/NOOP.js';\n\nclass Vec2Callback {\r\n    constructor(callback, x = 0, y = 0, compareValue = false) {\r\n        this.compareValue = false;\r\n        this._x = x;\r\n        this._y = y;\r\n        this.callback = callback;\r\n        this.compareValue = compareValue;\r\n    }\r\n    set(x = 0, y = 0) {\r\n        this._x = x;\r\n        this._y = y;\r\n        this.callback(this);\r\n        return this;\r\n    }\r\n    destroy() {\r\n        this.callback = NOOP;\r\n    }\r\n    set x(value) {\r\n        if (!this.compareValue || (this.compareValue && value !== this._x)) {\r\n            this._x = value;\r\n            this.callback(this);\r\n        }\r\n    }\r\n    get x() {\r\n        return this._x;\r\n    }\r\n    set y(value) {\r\n        if (!this.compareValue || (this.compareValue && value !== this._x)) {\r\n            this._y = value;\r\n            this.callback(this);\r\n        }\r\n    }\r\n    get y() {\r\n        return this._y;\r\n    }\r\n}\n\nexport { Vec2Callback };\n","import { GameInstance } from '../GameInstance.js';\nimport { Matrix2D } from '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport { Rectangle } from '../geom/rectangle/Rectangle.js';\n\nclass StaticCamera {\r\n    constructor() {\r\n        this.type = 'StaticCamera';\r\n        this.dirtyRender = true;\r\n        const game = GameInstance.get();\r\n        this.renderer = game.renderer;\r\n        this.matrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n        this.bounds = new Rectangle();\r\n        this.worldTransform = new Matrix2D();\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        const width = this.renderer.width;\r\n        const height = this.renderer.height;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.bounds.set(0, 0, width, height);\r\n    }\r\n    destroy() {\r\n        this.world = null;\r\n        this.worldTransform = null;\r\n        this.renderer = null;\r\n        this.matrix = null;\r\n        this.bounds = null;\r\n    }\r\n}\n\nexport { StaticCamera };\n","import { GetChildIndex } from './GetChildIndex.js';\nimport { RemoveChildAt } from './RemoveChildAt.js';\n\nfunction RemoveChild(parent, child) {\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex > -1) {\r\n        RemoveChildAt(parent, currentIndex);\r\n    }\r\n    return child;\r\n}\n\nexport { RemoveChild };\n","function GetChildIndex(parent, child) {\r\n    return parent.children.indexOf(child);\r\n}\n\nexport { GetChildIndex };\n","function RemoveChildAt(parent, index) {\r\n    const children = parent.children;\r\n    let child;\r\n    if (index >= 0 && index < children.length) {\r\n        const removed = children.splice(index, 1);\r\n        if (removed[0]) {\r\n            child = removed[0];\r\n            child.parent = null;\r\n        }\r\n    }\r\n    return child;\r\n}\n\nexport { RemoveChildAt };\n","function Emit(emitter, event, ...args) {\r\n    if (emitter.events.size === 0 || !emitter.events.has(event)) {\r\n        return false;\r\n    }\r\n    const listeners = emitter.events.get(event);\r\n    for (const ee of listeners) {\r\n        ee.callback.apply(ee.context, args);\r\n        if (ee.once) {\r\n            listeners.delete(ee);\r\n        }\r\n    }\r\n    if (listeners.size === 0) {\r\n        emitter.events.delete(event);\r\n    }\r\n    return true;\r\n}\n\nexport { Emit };\n","import { DepthFirstSearch } from './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport { RemoveChild } from './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport { SetWorld } from './SetWorld.js';\n\nfunction SetParent(parent, ...children) {\r\n    children.forEach(child => {\r\n        if (child.parent) {\r\n            RemoveChild(child.parent, child);\r\n        }\r\n        child.parent = parent;\r\n    });\r\n    const parentWorld = parent.world;\r\n    if (parentWorld) {\r\n        SetWorld(parentWorld, ...DepthFirstSearch(parent));\r\n    }\r\n    return children;\r\n}\n\nexport { SetParent };\n","import { AddedToWorldEvent } from '../gameobjects/events/AddedToWorldEvent.js';\nimport { RemovedFromWorldEvent } from '../gameobjects/events/RemovedFromWorldEvent.js';\nimport { Emit } from '../events/Emit.js';\n\nfunction SetWorld(world, ...children) {\r\n    children.forEach(child => {\r\n        if (child.world) {\r\n            Emit(child.world, RemovedFromWorldEvent, child, child.world);\r\n            Emit(child, RemovedFromWorldEvent, child, child.world);\r\n        }\r\n        child.world = world;\r\n        Emit(world, AddedToWorldEvent, child, world);\r\n        Emit(child, AddedToWorldEvent, child, world);\r\n    });\r\n    return children;\r\n}\n\nexport { SetWorld };\n","const RemovedFromWorldEvent = 'removedfromworld';\n\nexport { RemovedFromWorldEvent };\n","const AddedToWorldEvent = 'addedtoworld';\n\nexport { AddedToWorldEvent };\n","function DepthFirstSearch(parent) {\r\n    const stack = [parent];\r\n    const output = [];\r\n    while (stack.length > 0) {\r\n        const node = stack.shift();\r\n        output.push(node);\r\n        const numChildren = node.numChildren;\r\n        if (numChildren > 0) {\r\n            for (let i = numChildren - 1; i >= 0; i--) {\r\n                stack.unshift(node.children[i]);\r\n            }\r\n        }\r\n    }\r\n    output.shift();\r\n    return output;\r\n}\n\nexport { DepthFirstSearch };\n","import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport { SetParent } from './SetParent.js';\n\nfunction AddChild(parent, child) {\r\n    parent.children.push(child);\r\n    SetParent(parent, child);\r\n    child.transform.updateWorld();\r\n    return child;\r\n}\n\nexport { AddChild };\n","const DIRTY_CONST = {\r\n    CLEAR: 0,\r\n    TRANSFORM: 1,\r\n    UPDATE: 2,\r\n    CHILD_CACHE: 4,\r\n    POST_RENDER: 8,\r\n    COLORS: 16,\r\n    BOUNDS: 32,\r\n    TEXTURE: 64,\r\n    FRAME: 128,\r\n    ALPHA: 256,\r\n    CHILD: 512,\r\n    DEFAULT: 1 + 2 + 16 + 32,\r\n    USER1: 536870912,\r\n    USER2: 1073741824,\r\n    USER3: 2147483648,\r\n    USER4: 4294967296\r\n};\n\nexport { DIRTY_CONST };\n","function RemoveChildrenBetween(parent, beginIndex = 0, endIndex) {\r\n    const children = parent.children;\r\n    if (endIndex === undefined) {\r\n        endIndex = children.length;\r\n    }\r\n    const range = endIndex - beginIndex;\r\n    if (range > 0 && range <= endIndex) {\r\n        const removed = children.splice(beginIndex, range);\r\n        removed.forEach(child => {\r\n            child.parent = null;\r\n        });\r\n        return removed;\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\n\nexport { RemoveChildrenBetween };\n","class EventInstance {\r\n    constructor(callback, context, once = false) {\r\n        this.callback = callback;\r\n        this.context = context;\r\n        this.once = once;\r\n    }\r\n}\n\nexport { EventInstance };\n","import { EventInstance } from './EventInstance.js';\n\nfunction Off(emitter, event, callback, context, once) {\r\n    const events = emitter.events;\r\n    const listeners = events.get(event);\r\n    if (!callback) {\r\n        events.delete(event);\r\n    }\r\n    else if (callback instanceof EventInstance) {\r\n        listeners.delete(callback);\r\n    }\r\n    else {\r\n        const hasContext = !context;\r\n        const hasOnce = (once !== undefined);\r\n        for (const listener of listeners) {\r\n            if ((listener.callback === callback) &&\r\n                (hasContext && listener.context === context) &&\r\n                (hasOnce && listener.once === once)) {\r\n                listeners.delete(listener);\r\n            }\r\n        }\r\n    }\r\n    if (listeners.size === 0) {\r\n        events.delete(event);\r\n    }\r\n    return emitter;\r\n}\n\nexport { Off };\n","import { EventInstance } from './EventInstance.js';\n\nfunction On(emitter, event, callback, context = emitter, once = false) {\r\n    if (typeof callback !== 'function') {\r\n        throw new TypeError('Listener not a function');\r\n    }\r\n    const listener = new EventInstance(callback, context, once);\r\n    const listeners = emitter.events.get(event);\r\n    if (!listeners) {\r\n        emitter.events.set(event, new Set([listener]));\r\n    }\r\n    else {\r\n        listeners.add(listener);\r\n    }\r\n    return listener;\r\n}\n\nexport { On };\n","import './EventInstance.js';\nimport { On } from './On.js';\n\nfunction Once(emitter, event, callback, context = emitter) {\r\n    return On(emitter, event, callback, context, true);\r\n}\n\nexport { Once };\n","let instance;\r\nconst SceneManagerInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (manager) => {\r\n        instance = manager;\r\n    }\r\n};\n\nexport { SceneManagerInstance };\n","import { GameInstance } from '../GameInstance.js';\nimport { GetScenes } from '../config/Scenes.js';\nimport { Emit } from '../events/Emit.js';\nimport '../events/EventInstance.js';\nimport '../events/On.js';\nimport { Once } from '../events/Once.js';\nimport { CreateSceneRenderData } from './CreateSceneRenderData.js';\nimport { ResetSceneRenderData } from './ResetSceneRenderData.js';\nimport { SceneManagerInstance } from './SceneManagerInstance.js';\n\nclass SceneManager {\r\n    constructor() {\r\n        this.scenes = new Map();\r\n        this.sceneIndex = 0;\r\n        this.flush = false;\r\n        this.renderResult = CreateSceneRenderData();\r\n        this.game = GameInstance.get();\r\n        SceneManagerInstance.set(this);\r\n        Once(this.game, 'boot', () => this.boot());\r\n    }\r\n    boot() {\r\n        GetScenes().forEach(scene => new scene());\r\n    }\r\n    update(delta, time) {\r\n        for (const scene of this.scenes.values()) {\r\n            Emit(scene, 'update', delta, time);\r\n        }\r\n    }\r\n    render(gameFrame) {\r\n        const results = this.renderResult;\r\n        ResetSceneRenderData(results, gameFrame);\r\n        for (const scene of this.scenes.values()) {\r\n            Emit(scene, 'render', results);\r\n        }\r\n        if (this.flush) {\r\n            results.numDirtyFrames++;\r\n            this.flush = false;\r\n        }\r\n        return results;\r\n    }\r\n}\n\nexport { SceneManager };\n","function CreateSceneRenderData() {\r\n    return {\r\n        gameFrame: 0,\r\n        numTotalFrames: 0,\r\n        numDirtyFrames: 0,\r\n        numDirtyCameras: 0,\r\n        worldData: []\r\n    };\r\n}\n\nexport { CreateSceneRenderData };\n","function ResetSceneRenderData(renderData, gameFrame = 0) {\r\n    renderData.gameFrame = gameFrame;\r\n    renderData.numTotalFrames = 0;\r\n    renderData.numDirtyFrames = 0;\r\n    renderData.numDirtyCameras = 0;\r\n    renderData.worldData.length = 0;\r\n}\n\nexport { ResetSceneRenderData };\n","function CreateCanvas(width, height) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas.getContext('2d');\r\n}\n\nexport { CreateCanvas };\n","let instance;\r\nconst TextureManagerInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (manager) => {\r\n        instance = manager;\r\n    }\r\n};\n\nexport { TextureManagerInstance };\n","import '../renderer/BindingQueue.js';\nimport './Frame.js';\nimport { Texture } from './Texture.js';\nimport { CreateCanvas } from './CreateCanvas.js';\nimport { TextureManagerInstance } from './TextureManagerInstance.js';\n\nclass TextureManager {\r\n    constructor() {\r\n        this.textures = new Map();\r\n        this.createDefaultTextures();\r\n        TextureManagerInstance.set(this);\r\n    }\r\n    createDefaultTextures() {\r\n        this.add('__BLANK', new Texture(CreateCanvas(32, 32).canvas));\r\n        const missing = CreateCanvas(32, 32);\r\n        missing.strokeStyle = '#0f0';\r\n        missing.moveTo(0, 0);\r\n        missing.lineTo(32, 32);\r\n        missing.stroke();\r\n        missing.strokeRect(0.5, 0.5, 31, 31);\r\n        this.add('__MISSING', new Texture(missing.canvas));\r\n    }\r\n    get(key) {\r\n        const textures = this.textures;\r\n        if (textures.has(key)) {\r\n            return textures.get(key);\r\n        }\r\n        else {\r\n            return textures.get('__MISSING');\r\n        }\r\n    }\r\n    has(key) {\r\n        return this.textures.has(key);\r\n    }\r\n    add(key, source) {\r\n        let texture;\r\n        const textures = this.textures;\r\n        if (!textures.has(key)) {\r\n            if (source instanceof Texture) {\r\n                texture = source;\r\n            }\r\n            else {\r\n                texture = new Texture(source);\r\n            }\r\n            texture.key = key;\r\n            textures.set(key, texture);\r\n        }\r\n        return texture;\r\n    }\r\n}\n\nexport { TextureManager };\n","function GetVertices(transform) {\r\n    const { a, b, c, d, tx, ty } = transform.world;\r\n    const { x, y, right, bottom } = transform.extent;\r\n    const x0 = (x * a) + (y * c) + tx;\r\n    const y0 = (x * b) + (y * d) + ty;\r\n    const x1 = (x * a) + (bottom * c) + tx;\r\n    const y1 = (x * b) + (bottom * d) + ty;\r\n    const x2 = (right * a) + (bottom * c) + tx;\r\n    const y2 = (right * b) + (bottom * d) + ty;\r\n    const x3 = (right * a) + (y * c) + tx;\r\n    const y3 = (right * b) + (y * d) + ty;\r\n    return { x0, y0, x1, y1, x2, y2, x3, y3 };\r\n}\n\nexport { GetVertices };\n","import '../../../geom/rectangle/Contains.js';\nimport { Rectangle } from '../../../geom/rectangle/Rectangle.js';\nimport { DIRTY_CONST } from '../../DIRTY_CONST.js';\nimport { GetVertices } from '../transform/GetVertices.js';\n\nclass BoundsComponent {\r\n    constructor(entity) {\r\n        this.fixed = false;\r\n        this.includeChildren = true;\r\n        this.visibleOnly = true;\r\n        this.entity = entity;\r\n        this.area = new Rectangle();\r\n    }\r\n    set(x, y, width, height) {\r\n        this.area.set(x, y, width, height);\r\n    }\r\n    get() {\r\n        if (this.entity.isDirty(DIRTY_CONST.BOUNDS) && !this.fixed) {\r\n            this.update();\r\n        }\r\n        return this.area;\r\n    }\r\n    updateLocal() {\r\n        const { x0, y0, x1, y1, x2, y2, x3, y3 } = GetVertices(this.entity.transform);\r\n        const x = Math.min(x0, x1, x2, x3);\r\n        const y = Math.min(y0, y1, y2, y3);\r\n        const right = Math.max(x0, x1, x2, x3);\r\n        const bottom = Math.max(y0, y1, y2, y3);\r\n        return this.area.set(x, y, right - x, bottom - y);\r\n    }\r\n    update() {\r\n        const bounds = this.updateLocal();\r\n        this.entity.clearDirty(DIRTY_CONST.BOUNDS);\r\n        if (!this.includeChildren || !this.entity.numChildren) {\r\n            return bounds;\r\n        }\r\n        const visibleOnly = this.visibleOnly;\r\n        const children = this.entity.children;\r\n        let x = bounds.x;\r\n        let y = bounds.y;\r\n        let right = bounds.right;\r\n        let bottom = bounds.bottom;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            if (!child || (visibleOnly && !child.visible)) {\r\n                continue;\r\n            }\r\n            const childBounds = child.bounds.get();\r\n            if (childBounds.x < x) {\r\n                x = childBounds.x;\r\n            }\r\n            if (childBounds.y < y) {\r\n                y = childBounds.y;\r\n            }\r\n            if (childBounds.right > right) {\r\n                right = childBounds.right;\r\n            }\r\n            if (childBounds.bottom > bottom) {\r\n                bottom = childBounds.bottom;\r\n            }\r\n        }\r\n        return bounds.set(x, y, right - x, bottom - y);\r\n    }\r\n    destroy() {\r\n        this.entity = null;\r\n        this.area = null;\r\n    }\r\n}\n\nexport { BoundsComponent };\n","class InputComponent {\r\n    constructor(entity) {\r\n        this.enabled = false;\r\n        this.enabledChildren = true;\r\n        this.entity = entity;\r\n    }\r\n    destroy() {\r\n        this.entity = null;\r\n        this.hitArea = null;\r\n    }\r\n}\n\nexport { InputComponent };\n","class Vec2 {\r\n    constructor(x = 0, y = 0) {\r\n        this.set(x, y);\r\n    }\r\n    set(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    getArray() {\r\n        return [this.x, this.y];\r\n    }\r\n    fromArray(src) {\r\n        return this.set(src[0], src[1]);\r\n    }\r\n    toString() {\r\n        return `[x=${this.x}, y=${this.y}]`;\r\n    }\r\n}\n\nexport { Vec2 };\n","function Copy(src, target) {\r\n    return target.set(src.a, src.b, src.c, src.d, src.tx, src.ty);\r\n}\n\nexport { Copy };\n","import { Matrix2D } from '../../../math/matrix2d/Matrix2D.js';\nimport '../../../geom/rectangle/Contains.js';\nimport { Rectangle } from '../../../geom/rectangle/Rectangle.js';\nimport '../../../utils/NOOP.js';\nimport { Vec2Callback } from '../../../math/vec2/Vec2Callback.js';\nimport { originX, originY } from '../../../config/DefaultOrigin.js';\nimport { DIRTY_CONST } from '../../DIRTY_CONST.js';\nimport { Vec2 } from '../../../math/vec2/Vec2.js';\nimport { UpdateLocalTransform } from './UpdateLocalTransform.js';\nimport '../../../math/matrix2d/Copy.js';\nimport { UpdateWorldTransform } from './UpdateWorldTransform.js';\n\nclass TransformComponent {\r\n    constructor(entity, x = 0, y = 0) {\r\n        this.passthru = false;\r\n        this._rotation = 0;\r\n        this.entity = entity;\r\n        this.local = new Matrix2D();\r\n        this.world = new Matrix2D();\r\n        this.position = new Vec2Callback(() => this.update(), x, y);\r\n        this.scale = new Vec2Callback(() => this.update(), 1, 1, true);\r\n        this.skew = new Vec2Callback(() => this.update(), 0, 0, true);\r\n        this.origin = new Vec2Callback(() => this.updateExtent(), originX, originY);\r\n        this.extent = new Rectangle();\r\n    }\r\n    update() {\r\n        this.updateLocal();\r\n        this.updateWorld();\r\n    }\r\n    updateLocal() {\r\n        this.entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n        UpdateLocalTransform(this);\r\n    }\r\n    updateWorld() {\r\n        const entity = this.entity;\r\n        entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n        UpdateWorldTransform(entity);\r\n        if (entity.numChildren) {\r\n            this.updateChildren();\r\n        }\r\n    }\r\n    updateChildren() {\r\n        const children = this.entity.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            child.transform.updateWorld();\r\n        }\r\n    }\r\n    globalToLocal(x, y, out = new Vec2()) {\r\n        const { a, b, c, d, tx, ty } = this.world;\r\n        const id = 1 / ((a * d) + (c * -b));\r\n        out.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\r\n        out.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\r\n        return out;\r\n    }\r\n    localToGlobal(x, y, out = new Vec2()) {\r\n        const { a, b, c, d, tx, ty } = this.world;\r\n        out.x = (a * x) + (c * y) + tx;\r\n        out.y = (b * x) + (d * y) + ty;\r\n        return out;\r\n    }\r\n    setExtent(x, y, width, height) {\r\n        this.extent.set(x, y, width, height);\r\n        this.entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n    }\r\n    updateExtent(width, height) {\r\n        const extent = this.extent;\r\n        const entity = this.entity;\r\n        if (width !== undefined) {\r\n            extent.width = width;\r\n        }\r\n        if (height !== undefined) {\r\n            extent.height = height;\r\n        }\r\n        extent.x = -(this.origin.x) * extent.width;\r\n        extent.y = -(this.origin.y) * extent.height;\r\n        entity.setDirty(DIRTY_CONST.TRANSFORM, DIRTY_CONST.BOUNDS);\r\n    }\r\n    set rotation(value) {\r\n        if (value !== this._rotation) {\r\n            this._rotation = value;\r\n            this.update();\r\n        }\r\n    }\r\n    get rotation() {\r\n        return this._rotation;\r\n    }\r\n    destroy() {\r\n        this.position.destroy();\r\n        this.scale.destroy();\r\n        this.skew.destroy();\r\n        this.origin.destroy();\r\n        this.entity = null;\r\n        this.local = null;\r\n        this.world = null;\r\n        this.position = null;\r\n        this.scale = null;\r\n        this.skew = null;\r\n        this.origin = null;\r\n        this.extent = null;\r\n    }\r\n}\n\nexport { TransformComponent };\n","function UpdateLocalTransform(transform) {\r\n    const local = transform.local;\r\n    const x = transform.position.x;\r\n    const y = transform.position.y;\r\n    const rotation = transform.rotation;\r\n    const scaleX = transform.scale.x;\r\n    const scaleY = transform.scale.y;\r\n    const skewX = transform.skew.x;\r\n    const skewY = transform.skew.y;\r\n    local.set(Math.cos(rotation + skewY) * scaleX, Math.sin(rotation + skewY) * scaleX, -Math.sin(rotation - skewX) * scaleY, Math.cos(rotation - skewX) * scaleY, x, y);\r\n}\n\nexport { UpdateLocalTransform };\n","import { Copy } from '../../../math/matrix2d/Copy.js';\n\nfunction UpdateWorldTransform(gameObject) {\r\n    const parent = gameObject.parent;\r\n    const transform = gameObject.transform;\r\n    const lt = transform.local;\r\n    const wt = transform.world;\r\n    if (!parent) {\r\n        Copy(lt, wt);\r\n    }\r\n    else if (transform.passthru) {\r\n        Copy(parent.transform.world, wt);\r\n    }\r\n    else {\r\n        const { a, b, c, d, tx, ty } = lt;\r\n        const { a: pa, b: pb, c: pc, d: pd, tx: ptx, ty: pty } = parent.transform.world;\r\n        wt.set(a * pa + b * pc, a * pb + b * pd, c * pa + d * pc, c * pb + d * pd, tx * pa + ty * pc + ptx, tx * pb + ty * pd + pty);\r\n    }\r\n}\n\nexport { UpdateWorldTransform };\n","import { GameInstance } from '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport './events/AddedToWorldEvent.js';\nimport { DestroyEvent } from './events/DestroyEvent.js';\nimport './events/RemovedFromWorldEvent.js';\nimport { Emit } from '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport { DIRTY_CONST } from './DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport { DestroyChildren } from '../display/DestroyChildren.js';\nimport { ReparentChildren } from '../display/ReparentChildren.js';\nimport './components/transform/GetVertices.js';\nimport { BoundsComponent } from './components/bounds/BoundsComponent.js';\nimport { InputComponent } from './components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport './components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport './components/transform/UpdateWorldTransform.js';\nimport { TransformComponent } from './components/transform/TransformComponent.js';\n\nclass GameObject {\r\n    constructor(x = 0, y = 0) {\r\n        this.type = 'GameObject';\r\n        this.name = '';\r\n        this.willUpdate = true;\r\n        this.willUpdateChildren = true;\r\n        this.willRender = true;\r\n        this.willRenderChildren = true;\r\n        this.willCacheChildren = false;\r\n        this.dirty = 0;\r\n        this.dirtyFrame = 0;\r\n        this.visible = true;\r\n        this.children = [];\r\n        this.events = new Map();\r\n        this.transform = new TransformComponent(this, x, y);\r\n        this.bounds = new BoundsComponent(this);\r\n        this.input = new InputComponent(this);\r\n        this.dirty = DIRTY_CONST.DEFAULT;\r\n        this.transform.update();\r\n    }\r\n    isRenderable() {\r\n        return (this.visible && this.willRender);\r\n    }\r\n    isDirty(flag) {\r\n        return (this.dirty & flag) !== 0;\r\n    }\r\n    clearDirty(flag) {\r\n        if (this.isDirty(flag)) {\r\n            this.dirty ^= flag;\r\n        }\r\n        return this;\r\n    }\r\n    setDirty(flag, flag2) {\r\n        if (!this.isDirty(flag)) {\r\n            this.dirty ^= flag;\r\n            this.dirtyFrame = GameInstance.getFrame();\r\n        }\r\n        if (!this.isDirty(flag2)) {\r\n            this.dirty ^= flag2;\r\n        }\r\n        return this;\r\n    }\r\n    update(delta, time) {\r\n        if (this.willUpdateChildren) {\r\n            const children = this.children;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child && child.willUpdate) {\r\n                    child.update(delta, time);\r\n                }\r\n            }\r\n        }\r\n        this.postUpdate(delta, time);\r\n    }\r\n    postUpdate(delta, time) {\r\n    }\r\n    renderGL(renderer) {\r\n    }\r\n    renderCanvas(renderer) {\r\n    }\r\n    postRenderGL(renderer) {\r\n    }\r\n    postRenderCanvas(renderer) {\r\n    }\r\n    get numChildren() {\r\n        return this.children.length;\r\n    }\r\n    destroy(reparentChildren) {\r\n        if (reparentChildren) {\r\n            ReparentChildren(this, reparentChildren);\r\n        }\r\n        else {\r\n            DestroyChildren(this);\r\n        }\r\n        Emit(this, DestroyEvent, this);\r\n        this.transform.destroy();\r\n        this.bounds.destroy();\r\n        this.input.destroy();\r\n        this.events.clear();\r\n        this.world = null;\r\n        this.parent = null;\r\n        this.children = null;\r\n    }\r\n}\n\nexport { GameObject };\n","import './DepthFirstSearch.js';\nimport './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport './RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../events/Emit.js';\nimport './SetWorld.js';\nimport { SetParent } from './SetParent.js';\nimport { RemoveChildrenBetween } from './RemoveChildrenBetween.js';\n\nfunction ReparentChildren(parent, newParent, beginIndex = 0, endIndex) {\r\n    const moved = RemoveChildrenBetween(parent, beginIndex, endIndex);\r\n    SetParent(newParent, ...moved);\r\n    moved.forEach(child => {\r\n        child.transform.updateWorld();\r\n    });\r\n    return moved;\r\n}\n\nexport { ReparentChildren };\n","import { RemoveChildrenBetween } from './RemoveChildrenBetween.js';\n\nfunction DestroyChildren(parent, beginIndex = 0, endIndex) {\r\n    const removed = RemoveChildrenBetween(parent, beginIndex, endIndex);\r\n    removed.forEach(child => {\r\n        child.destroy();\r\n    });\r\n}\n\nexport { DestroyChildren };\n","const DestroyEvent = 'destroy';\n\nexport { DestroyEvent };\n","import '../../GameInstance.js';\nimport '../../math/matrix2d/Matrix2D.js';\nimport '../../geom/rectangle/Contains.js';\nimport '../../geom/rectangle/Rectangle.js';\nimport '../../utils/NOOP.js';\nimport '../../math/vec2/Vec2Callback.js';\nimport '../../config/DefaultOrigin.js';\nimport '../../display/DepthFirstSearch.js';\nimport '../../display/GetChildIndex.js';\nimport '../../display/RemoveChildAt.js';\nimport '../../display/RemoveChild.js';\nimport '../events/AddedToWorldEvent.js';\nimport '../events/DestroyEvent.js';\nimport '../events/RemovedFromWorldEvent.js';\nimport '../../events/Emit.js';\nimport '../../display/SetWorld.js';\nimport '../../display/SetParent.js';\nimport { DIRTY_CONST } from '../DIRTY_CONST.js';\nimport '../../display/RemoveChildrenBetween.js';\nimport '../../display/DestroyChildren.js';\nimport '../../display/ReparentChildren.js';\nimport '../components/transform/GetVertices.js';\nimport '../components/bounds/BoundsComponent.js';\nimport '../components/input/InputComponent.js';\nimport '../../math/vec2/Vec2.js';\nimport '../components/transform/UpdateLocalTransform.js';\nimport '../../math/matrix2d/Copy.js';\nimport '../components/transform/UpdateWorldTransform.js';\nimport '../components/transform/TransformComponent.js';\nimport { GameObject } from '../GameObject.js';\n\nclass Container extends GameObject {\r\n    constructor(x = 0, y = 0) {\r\n        super(x, y);\r\n        this._alpha = 1;\r\n        this.type = 'Container';\r\n    }\r\n    setSize(width, height = width) {\r\n        this.transform.updateExtent(width, height);\r\n        return this;\r\n    }\r\n    setPosition(x, y) {\r\n        this.transform.position.set(x, y);\r\n        return this;\r\n    }\r\n    setOrigin(x, y = x) {\r\n        this.transform.origin.set(x, y);\r\n        return this;\r\n    }\r\n    setSkew(x, y = x) {\r\n        this.transform.skew.set(x, y);\r\n        return this;\r\n    }\r\n    setScale(x, y = x) {\r\n        this.transform.scale.set(x, y);\r\n        return this;\r\n    }\r\n    setRotation(value) {\r\n        this.transform.rotation = value;\r\n        return this;\r\n    }\r\n    set width(value) {\r\n        this.transform.updateExtent(value);\r\n    }\r\n    get width() {\r\n        return this.transform.extent.width;\r\n    }\r\n    set height(value) {\r\n        this.transform.updateExtent(undefined, value);\r\n    }\r\n    get height() {\r\n        return this.transform.extent.height;\r\n    }\r\n    set x(value) {\r\n        this.transform.position.x = value;\r\n    }\r\n    get x() {\r\n        return this.transform.position.x;\r\n    }\r\n    set y(value) {\r\n        this.transform.position.y = value;\r\n    }\r\n    get y() {\r\n        return this.transform.position.y;\r\n    }\r\n    set originX(value) {\r\n        this.transform.origin.x = value;\r\n    }\r\n    get originX() {\r\n        return this.transform.origin.x;\r\n    }\r\n    set originY(value) {\r\n        this.transform.origin.y = value;\r\n    }\r\n    get originY() {\r\n        return this.transform.origin.y;\r\n    }\r\n    set skewX(value) {\r\n        this.transform.skew.x = value;\r\n    }\r\n    get skewX() {\r\n        return this.transform.skew.x;\r\n    }\r\n    set skewY(value) {\r\n        this.transform.skew.y = value;\r\n    }\r\n    get skewY() {\r\n        return this.transform.skew.y;\r\n    }\r\n    set scaleX(value) {\r\n        this.transform.scale.x = value;\r\n    }\r\n    get scaleX() {\r\n        return this.transform.scale.x;\r\n    }\r\n    set scaleY(value) {\r\n        this.transform.scale.y = value;\r\n    }\r\n    get scaleY() {\r\n        return this.transform.scale.y;\r\n    }\r\n    set rotation(value) {\r\n        this.transform.rotation = value;\r\n    }\r\n    get rotation() {\r\n        return this.transform.rotation;\r\n    }\r\n    get alpha() {\r\n        return this._alpha;\r\n    }\r\n    set alpha(value) {\r\n        if (value !== this._alpha) {\r\n            this._alpha = value;\r\n            this.setDirty(DIRTY_CONST.TRANSFORM);\r\n        }\r\n    }\r\n}\n\nexport { Container };\n","function PackColor(rgb, alpha) {\r\n    const ua = ((alpha * 255) | 0) & 0xFF;\r\n    return ((ua << 24) | rgb) >>> 0;\r\n}\n\nexport { PackColor };\n","import { PackColor } from './PackColor.js';\n\nfunction PackColors(sprite) {\r\n    const alpha = sprite.vertexAlpha;\r\n    const tint = sprite.vertexTint;\r\n    const color = sprite.vertexColor;\r\n    color[0] = PackColor(tint[0], alpha[0]);\r\n    color[1] = PackColor(tint[1], alpha[1]);\r\n    color[2] = PackColor(tint[2], alpha[2]);\r\n    color[3] = PackColor(tint[3], alpha[3]);\r\n    return sprite;\r\n}\n\nexport { PackColors };\n","function SetFrame(texture, key, ...children) {\r\n    const frame = texture.getFrame(key);\r\n    const { u0, u1, v0, v1, pivot } = frame;\r\n    children.forEach(child => {\r\n        if (!child || frame === child.frame) {\r\n            return;\r\n        }\r\n        child.frame = frame;\r\n        if (pivot) {\r\n            child.setOrigin(pivot.x, pivot.y);\r\n        }\r\n        child.frame.setExtent(child);\r\n        child.hasTexture = true;\r\n        const data = child.vertexData;\r\n        data[2] = u0;\r\n        data[3] = v0;\r\n        data[8] = u0;\r\n        data[9] = v1;\r\n        data[14] = u1;\r\n        data[15] = v1;\r\n        data[20] = u1;\r\n        data[21] = v0;\r\n    });\r\n    return children;\r\n}\n\nexport { SetFrame };\n","import '../../GameInstance.js';\nimport '../../math/matrix2d/Matrix2D.js';\nimport '../../geom/rectangle/Contains.js';\nimport '../../geom/rectangle/Rectangle.js';\nimport '../../utils/NOOP.js';\nimport '../../math/vec2/Vec2Callback.js';\nimport '../../renderer/BindingQueue.js';\nimport '../../config/DefaultOrigin.js';\nimport '../../textures/Frame.js';\nimport '../../textures/Texture.js';\nimport '../../display/DepthFirstSearch.js';\nimport '../../display/GetChildIndex.js';\nimport '../../display/RemoveChildAt.js';\nimport '../../display/RemoveChild.js';\nimport '../events/AddedToWorldEvent.js';\nimport '../events/DestroyEvent.js';\nimport '../events/RemovedFromWorldEvent.js';\nimport '../../events/Emit.js';\nimport '../../display/SetWorld.js';\nimport '../../display/SetParent.js';\nimport { DIRTY_CONST } from '../DIRTY_CONST.js';\nimport '../../display/RemoveChildrenBetween.js';\nimport '../../display/DestroyChildren.js';\nimport '../../display/ReparentChildren.js';\nimport '../../textures/TextureManagerInstance.js';\nimport { BatchTexturedQuad } from '../../renderer/webgl1/draw/BatchTexturedQuad.js';\nimport '../components/transform/GetVertices.js';\nimport '../components/bounds/BoundsComponent.js';\nimport '../components/input/InputComponent.js';\nimport '../../math/vec2/Vec2.js';\nimport '../components/transform/UpdateLocalTransform.js';\nimport '../../math/matrix2d/Copy.js';\nimport '../components/transform/UpdateWorldTransform.js';\nimport '../components/transform/TransformComponent.js';\nimport '../GameObject.js';\nimport { Container } from '../container/Container.js';\nimport { DrawTexturedQuad } from '../../renderer/canvas/draw/DrawTexturedQuad.js';\nimport '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\nimport { SetFrame } from './SetFrame.js';\nimport { SetTexture } from './SetTexture.js';\nimport { UpdateVertices } from './UpdateVertices.js';\n\nclass Sprite extends Container {\r\n    constructor(x, y, texture, frame) {\r\n        super(x, y);\r\n        this.hasTexture = false;\r\n        this._tint = 0xffffff;\r\n        this.type = 'Sprite';\r\n        this.vertexData = new Float32Array(24).fill(0);\r\n        this.vertexColor = new Uint32Array(4).fill(4294967295);\r\n        this.vertexAlpha = new Float32Array(4).fill(1);\r\n        this.vertexTint = new Uint32Array(4).fill(0xffffff);\r\n        this.setTexture(texture, frame);\r\n    }\r\n    setTexture(key, frame) {\r\n        SetTexture(key, frame, this);\r\n        return this;\r\n    }\r\n    setFrame(key) {\r\n        SetFrame(this.texture, key, this);\r\n        return this;\r\n    }\r\n    isRenderable() {\r\n        return (this.visible && this.willRender && this.hasTexture && this.alpha > 0);\r\n    }\r\n    preRender() {\r\n        if (this.isDirty(DIRTY_CONST.COLORS)) {\r\n            PackColors(this);\r\n            this.clearDirty(DIRTY_CONST.COLORS);\r\n        }\r\n        if (this.isDirty(DIRTY_CONST.TRANSFORM)) {\r\n            UpdateVertices(this);\r\n            this.clearDirty(DIRTY_CONST.TRANSFORM);\r\n        }\r\n    }\r\n    renderGL(renderer) {\r\n        this.preRender();\r\n        BatchTexturedQuad(this, renderer);\r\n    }\r\n    renderCanvas(renderer) {\r\n        this.preRender();\r\n        DrawTexturedQuad(this, renderer);\r\n    }\r\n    get alpha() {\r\n        return this._alpha;\r\n    }\r\n    set alpha(value) {\r\n        if (value !== this._alpha) {\r\n            this._alpha = value;\r\n            const vertexAlpha = this.vertexAlpha;\r\n            vertexAlpha[0] = value;\r\n            vertexAlpha[1] = value;\r\n            vertexAlpha[2] = value;\r\n            vertexAlpha[3] = value;\r\n            this.setDirty(DIRTY_CONST.ALPHA);\r\n        }\r\n    }\r\n    get tint() {\r\n        return this._tint;\r\n    }\r\n    set tint(value) {\r\n        if (value !== this._tint) {\r\n            this._tint = value;\r\n            const vertexTint = this.vertexTint;\r\n            vertexTint[0] = value;\r\n            vertexTint[1] = value;\r\n            vertexTint[2] = value;\r\n            vertexTint[3] = value;\r\n            this.setDirty(DIRTY_CONST.COLORS);\r\n        }\r\n    }\r\n    destroy(reparentChildren) {\r\n        super.destroy(reparentChildren);\r\n        this.texture = null;\r\n        this.frame = null;\r\n        this.hasTexture = false;\r\n        this.vertexData = null;\r\n        this.vertexColor = null;\r\n        this.vertexAlpha = null;\r\n        this.vertexTint = null;\r\n    }\r\n}\n\nexport { Sprite };\n","import '../../renderer/BindingQueue.js';\nimport '../../textures/Frame.js';\nimport { Texture } from '../../textures/Texture.js';\nimport { TextureManagerInstance } from '../../textures/TextureManagerInstance.js';\nimport { SetFrame } from './SetFrame.js';\n\nfunction SetTexture(key, frame, ...children) {\r\n    if (!key) {\r\n        children.forEach(child => {\r\n            child.texture = null;\r\n            child.frame = null;\r\n            child.hasTexture = false;\r\n        });\r\n    }\r\n    else {\r\n        let texture;\r\n        if (key instanceof Texture) {\r\n            texture = key;\r\n        }\r\n        else {\r\n            texture = TextureManagerInstance.get().get(key);\r\n        }\r\n        if (!texture) {\r\n            console.warn(`Invalid Texture key: ${key}`);\r\n        }\r\n        else {\r\n            children.forEach(child => {\r\n                child.texture = texture;\r\n            });\r\n            SetFrame(texture, frame, ...children);\r\n        }\r\n    }\r\n    return children;\r\n}\n\nexport { SetTexture };\n","import { GetVertices } from '../components/transform/GetVertices.js';\n\nfunction UpdateVertices(sprite) {\r\n    const data = sprite.vertexData;\r\n    const { x0, y0, x1, y1, x2, y2, x3, y3 } = GetVertices(sprite.transform);\r\n    data[0] = x0;\r\n    data[1] = y0;\r\n    data[6] = x1;\r\n    data[7] = y1;\r\n    data[12] = x2;\r\n    data[13] = y2;\r\n    data[18] = x3;\r\n    data[19] = y3;\r\n    return sprite;\r\n}\n\nexport { UpdateVertices };\n","function BatchTexturedQuad(sprite, renderer) {\r\n    const texture = sprite.texture;\r\n    const shader = renderer.shaders.current;\r\n    const buffer = shader.buffer;\r\n    const binding = texture.binding;\r\n    if (shader.count === buffer.batchSize) {\r\n        renderer.flush();\r\n    }\r\n    const data = sprite.vertexData;\r\n    renderer.textures.request(texture);\r\n    const textureIndex = binding.index;\r\n    data[4] = textureIndex;\r\n    data[10] = textureIndex;\r\n    data[16] = textureIndex;\r\n    data[22] = textureIndex;\r\n    const offset = shader.count * buffer.quadElementSize;\r\n    buffer.vertexViewF32.set(data, offset);\r\n    const color = sprite.vertexColor;\r\n    const U32 = buffer.vertexViewU32;\r\n    U32[offset + 5] = color[0];\r\n    U32[offset + 11] = color[2];\r\n    U32[offset + 17] = color[3];\r\n    U32[offset + 23] = color[1];\r\n    shader.count++;\r\n}\n\nexport { BatchTexturedQuad };\n","function DrawTexturedQuad(sprite, renderer) {\r\n    const frame = sprite.frame;\r\n    if (!frame) {\r\n        return;\r\n    }\r\n    const ctx = renderer.ctx;\r\n    const transform = sprite.transform;\r\n    const { a, b, c, d, tx, ty } = transform.world;\r\n    const { x, y } = transform.extent;\r\n    ctx.save();\r\n    ctx.setTransform(a, b, c, d, tx, ty);\r\n    ctx.globalAlpha = sprite.alpha;\r\n    ctx.drawImage(frame.texture.image, frame.x, frame.y, frame.width, frame.height, x, y, frame.width, frame.height);\r\n    ctx.restore();\r\n}\n\nexport { DrawTexturedQuad };\n","import '../../renderer/BindingQueue.js';\nimport '../Frame.js';\nimport { Texture } from '../Texture.js';\nimport { CreateCanvas } from '../CreateCanvas.js';\n\nfunction CanvasTexture(width = 32, height = 32) {\r\n    const ctx = CreateCanvas(width, height);\r\n    return new Texture(ctx.canvas);\r\n}\n\nexport { CanvasTexture };\n","import { GameInstance } from '../../GameInstance.js';\nimport '../../math/matrix2d/Matrix2D.js';\nimport '../../geom/rectangle/Contains.js';\nimport '../../geom/rectangle/Rectangle.js';\nimport '../../utils/NOOP.js';\nimport '../../math/vec2/Vec2Callback.js';\nimport '../../renderer/BindingQueue.js';\nimport '../../config/DefaultOrigin.js';\nimport '../../textures/Frame.js';\nimport '../../textures/Texture.js';\nimport '../../display/DepthFirstSearch.js';\nimport '../../display/GetChildIndex.js';\nimport '../../display/RemoveChildAt.js';\nimport '../../display/RemoveChild.js';\nimport '../events/AddedToWorldEvent.js';\nimport '../events/DestroyEvent.js';\nimport '../events/RemovedFromWorldEvent.js';\nimport '../../events/Emit.js';\nimport '../../display/SetWorld.js';\nimport '../../display/SetParent.js';\nimport { DIRTY_CONST } from '../DIRTY_CONST.js';\nimport '../../display/RemoveChildrenBetween.js';\nimport '../../display/DestroyChildren.js';\nimport '../../display/ReparentChildren.js';\nimport '../../textures/CreateCanvas.js';\nimport '../../textures/TextureManagerInstance.js';\nimport '../../renderer/webgl1/draw/BatchTexturedQuad.js';\nimport '../components/transform/GetVertices.js';\nimport '../components/bounds/BoundsComponent.js';\nimport '../components/input/InputComponent.js';\nimport '../../math/vec2/Vec2.js';\nimport '../components/transform/UpdateLocalTransform.js';\nimport '../../math/matrix2d/Copy.js';\nimport '../components/transform/UpdateWorldTransform.js';\nimport '../components/transform/TransformComponent.js';\nimport '../GameObject.js';\nimport '../container/Container.js';\nimport '../../renderer/canvas/draw/DrawTexturedQuad.js';\nimport '../../renderer/webgl1/colors/PackColor.js';\nimport '../../renderer/webgl1/colors/PackColors.js';\nimport '../sprite/SetFrame.js';\nimport '../sprite/SetTexture.js';\nimport '../sprite/UpdateVertices.js';\nimport { Sprite } from '../sprite/Sprite.js';\nimport { CanvasTexture } from '../../textures/types/CanvasTexture.js';\n\nclass Text extends Sprite {\r\n    constructor(x, y, text = '', font, fillStyle) {\r\n        super(x, y, CanvasTexture());\r\n        this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\r\n        this.padding = { left: 0, right: 0, top: 0, bottom: 0 };\r\n        this.verticalAlign = 'ascent';\r\n        this.lineSpacing = 0;\r\n        this.font = '16px monospace';\r\n        this.fillStyle = '#fff';\r\n        this.strokeStyle = '';\r\n        this.backgroundStyle = '';\r\n        this.cornerRadius = 0;\r\n        this.textAlign = 'left';\r\n        this.textBaseline = 'alphabetic';\r\n        this.lineWidth = 0;\r\n        this.lineDash = [];\r\n        this.antialias = false;\r\n        this.type = 'Text';\r\n        const game = GameInstance.get();\r\n        this.resolution = game.renderer.resolution;\r\n        this.canvas = this.texture.image;\r\n        this.context = this.canvas.getContext('2d');\r\n        if (font) {\r\n            this.font = font;\r\n        }\r\n        if (fillStyle) {\r\n            this.fillStyle = fillStyle;\r\n        }\r\n        this.setText(text);\r\n    }\r\n    syncContext(canvas, ctx) {\r\n        if (this.preRenderCallback) {\r\n            this.preRenderCallback(canvas, ctx);\r\n        }\r\n        ctx.font = this.font;\r\n        ctx.textBaseline = this.textBaseline;\r\n        ctx.textAlign = this.textAlign;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.lineCap = 'round';\r\n        ctx.lineJoin = 'round';\r\n        ctx.setLineDash(this.lineDash);\r\n        ctx.imageSmoothingEnabled = this.antialias;\r\n    }\r\n    updateText() {\r\n        const canvas = this.canvas;\r\n        const ctx = this.context;\r\n        const resolution = this.resolution;\r\n        const lines = this._text.split(this.splitRegExp);\r\n        const padding = this.padding;\r\n        const fillStyle = this.fillStyle;\r\n        const strokeStyle = this.strokeStyle;\r\n        const strokeWidth = this.lineWidth;\r\n        const lineSpacing = this.lineSpacing;\r\n        const strokeWidthHalf = (strokeWidth > 0) ? strokeWidth / 2 : 0;\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        this.syncContext(canvas, ctx);\r\n        ctx.textAlign = 'start';\r\n        let maxWidth = 0;\r\n        let maxHeight = 0;\r\n        let y = 0;\r\n        const lineMetrics = [];\r\n        const vAlignAscent = (this.verticalAlign === 'ascent');\r\n        const metrics = ctx.measureText('|Mq');\r\n        const averageLineHeight = Math.ceil(Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent)) + strokeWidth;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const metrics = ctx.measureText(lines[i]);\r\n            const left = metrics.actualBoundingBoxLeft;\r\n            const right = metrics.actualBoundingBoxRight;\r\n            let ascent = metrics.actualBoundingBoxAscent;\r\n            let descent = metrics.actualBoundingBoxDescent;\r\n            if ((!ascent && !descent) || lines[i] === '') {\r\n                ascent = averageLineHeight;\r\n                descent = 0;\r\n            }\r\n            const lineWidth = Math.ceil(Math.abs(left) + Math.abs(right)) + strokeWidth;\r\n            const lineHeight = Math.ceil(Math.abs(ascent) + Math.abs(descent)) + strokeWidth;\r\n            if (vAlignAscent) {\r\n                y += ascent + strokeWidthHalf;\r\n                if (i > 0) {\r\n                    y += lineSpacing + strokeWidthHalf;\r\n                }\r\n                maxHeight = y + descent + strokeWidthHalf;\r\n            }\r\n            else {\r\n                y = maxHeight + ((lineHeight - descent) - strokeWidthHalf);\r\n                maxHeight += lineHeight;\r\n                if (i < lines.length - 1) {\r\n                    maxHeight += lineSpacing;\r\n                }\r\n            }\r\n            maxWidth = Math.max(maxWidth, lineWidth);\r\n            lineMetrics.push({ lineWidth, lineHeight, ascent, descent, left, right, y });\r\n        }\r\n        maxWidth += padding.left + padding.right;\r\n        maxHeight += padding.top + padding.bottom;\r\n        const displayWidth = (this.fixedWidth) ? this.fixedWidth : maxWidth;\r\n        const displayHeight = (this.fixedHeight) ? this.fixedHeight : maxHeight;\r\n        const canvasWidth = Math.ceil(displayWidth * resolution);\r\n        const canvasHeight = Math.ceil(displayHeight * resolution);\r\n        if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\r\n            canvas.width = canvasWidth;\r\n            canvas.height = canvasHeight;\r\n            this.texture.setSize(displayWidth, displayHeight);\r\n            this.setSize(displayWidth, displayHeight);\r\n        }\r\n        ctx.save();\r\n        ctx.scale(resolution, resolution);\r\n        this.syncContext(canvas, ctx);\r\n        const backgroundStyle = this.backgroundStyle;\r\n        if (backgroundStyle) {\r\n            ctx.save();\r\n            ctx.fillStyle = backgroundStyle;\r\n            ctx.strokeStyle = backgroundStyle;\r\n            const cornerRadius = this.cornerRadius;\r\n            const halfRadius = (cornerRadius > 0) ? cornerRadius / 2 : 0;\r\n            if (cornerRadius) {\r\n                ctx.lineWidth = cornerRadius;\r\n                ctx.strokeRect(halfRadius, halfRadius, displayWidth - cornerRadius, displayHeight - cornerRadius);\r\n            }\r\n            ctx.fillRect(halfRadius, halfRadius, displayWidth - cornerRadius, displayHeight - cornerRadius);\r\n            ctx.restore();\r\n        }\r\n        const textAlign = this.textAlign;\r\n        const isCenter = (textAlign === 'center');\r\n        const isRight = (textAlign === 'right' || textAlign === 'end');\r\n        const yOffset = ((displayHeight - maxHeight) / 2) + padding.top;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            const metrics = lineMetrics[i];\r\n            let tx = padding.left + metrics.left + strokeWidthHalf;\r\n            const ty = yOffset + metrics.y;\r\n            if (isCenter) {\r\n                tx = displayWidth / 2;\r\n            }\r\n            else if (isRight) {\r\n                tx = displayWidth - strokeWidthHalf;\r\n            }\r\n            if (strokeStyle) {\r\n                ctx.strokeText(line, tx, ty);\r\n            }\r\n            if (fillStyle) {\r\n                ctx.fillText(line, tx, ty);\r\n            }\r\n        }\r\n        ctx.restore();\r\n        if (this.texture.binding) {\r\n            this.texture.binding.update();\r\n        }\r\n        this.setDirty(DIRTY_CONST.TEXTURE);\r\n        return this;\r\n    }\r\n    get text() {\r\n        return this._text;\r\n    }\r\n    set text(value) {\r\n        this.setText(value);\r\n    }\r\n    setText(value = '') {\r\n        if (Array.isArray(value)) {\r\n            value = value.join('\\n');\r\n        }\r\n        if (value !== this._text) {\r\n            this._text = value.toString();\r\n            this.updateText();\r\n        }\r\n        return this;\r\n    }\r\n    destroy(reparentChildren) {\r\n        this.texture.destroy();\r\n        this.fillStyle = null;\r\n        this.strokeStyle = null;\r\n        this.backgroundStyle = null;\r\n        this.canvas = null;\r\n        this.context = null;\r\n        super.destroy(reparentChildren);\r\n    }\r\n}\n\nexport { Text };\n","import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\nimport { HasDirtyChildren } from './HasDirtyChildren.js';\n\nfunction UpdateCachedLayers(cachedLayers, dirtyCamera) {\r\n    cachedLayers.forEach(layer => {\r\n        if (dirtyCamera || HasDirtyChildren(layer)) {\r\n            layer.node.setDirty(DIRTY_CONST.CHILD_CACHE);\r\n        }\r\n        else {\r\n            layer.children.length = 0;\r\n        }\r\n    });\r\n}\n\nexport { UpdateCachedLayers };\n","import { DIRTY_CONST } from '../gameobjects/DIRTY_CONST.js';\n\nfunction HasDirtyChildren(parent) {\r\n    if (parent.node.isDirty(DIRTY_CONST.CHILD_CACHE)) {\r\n        return true;\r\n    }\r\n    const stack = [parent];\r\n    while (stack.length > 0) {\r\n        const entry = stack.pop();\r\n        if (entry.node.isDirty(DIRTY_CONST.TRANSFORM)) {\r\n            return true;\r\n        }\r\n        const numChildren = entry.children.length;\r\n        if (numChildren > 0) {\r\n            for (let i = 0; i < numChildren; i++) {\r\n                stack.push(entry.children[i]);\r\n            }\r\n        }\r\n    }\r\n    stack.length = 0;\r\n    return false;\r\n}\n\nexport { HasDirtyChildren };\n","import '../gameobjects/DIRTY_CONST.js';\nimport { CalculateTotalRenderable } from './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport { UpdateCachedLayers } from './UpdateCachedLayers.js';\nimport { WorldDepthFirstSearch } from './WorldDepthFirstSearch.js';\n\nfunction BuildRenderList(world) {\r\n    const cachedLayers = [];\r\n    const stack = [];\r\n    const entries = WorldDepthFirstSearch(cachedLayers, world, stack);\r\n    const renderData = world.renderData;\r\n    if (cachedLayers.length > 0) {\r\n        UpdateCachedLayers(cachedLayers, world.camera.dirtyRender);\r\n    }\r\n    entries.forEach(entry => {\r\n        if (entry.children.length) {\r\n            CalculateTotalRenderable(entry, renderData);\r\n        }\r\n        else {\r\n            renderData.numRendered++;\r\n            renderData.numRenderable++;\r\n            if (entry.node.dirtyFrame >= renderData.gameFrame) {\r\n                renderData.dirtyFrame++;\r\n            }\r\n        }\r\n    });\r\n    renderData.renderList = entries;\r\n    if (world.forceRefresh) {\r\n        renderData.dirtyFrame++;\r\n        world.forceRefresh = false;\r\n    }\r\n}\n\nexport { BuildRenderList };\n","function WorldDepthFirstSearch(cachedLayers, parent, output = []) {\r\n    for (let i = 0; i < parent.numChildren; i++) {\r\n        const node = parent.children[i];\r\n        if (node.isRenderable()) {\r\n            const children = [];\r\n            const entry = { node, children };\r\n            output.push(entry);\r\n            if (node.willRenderChildren && node.numChildren > 0) {\r\n                if (node.willCacheChildren) {\r\n                    cachedLayers.push(entry);\r\n                }\r\n                WorldDepthFirstSearch(cachedLayers, node, children);\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}\n\nexport { WorldDepthFirstSearch };\n","function CalculateTotalRenderable(entry, renderData) {\r\n    renderData.numRendered++;\r\n    renderData.numRenderable++;\r\n    if (entry.node.dirtyFrame >= renderData.gameFrame) {\r\n        renderData.dirtyFrame++;\r\n    }\r\n    entry.children.forEach(child => {\r\n        if (child.children.length > 0) {\r\n            CalculateTotalRenderable(child, renderData);\r\n        }\r\n    });\r\n}\n\nexport { CalculateTotalRenderable };\n","function ResetWorldRenderData(renderData, gameFrame) {\r\n    renderData.gameFrame = gameFrame;\r\n    renderData.dirtyFrame = 0;\r\n    renderData.numRendered = 0;\r\n    renderData.numRenderable = 0;\r\n    renderData.renderList.length = 0;\r\n}\n\nexport { ResetWorldRenderData };\n","import '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport { DestroyEvent } from '../gameobjects/events/DestroyEvent.js';\nimport { PostUpdateEvent } from '../gameobjects/events/PostUpdateEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport { UpdateEvent } from '../gameobjects/events/UpdateEvent.js';\nimport { Emit } from '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport '../gameobjects/DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport '../display/DestroyChildren.js';\nimport { RemoveChildren } from '../display/RemoveChildren.js';\nimport '../display/ReparentChildren.js';\nimport '../events/EventInstance.js';\nimport { Off } from '../events/Off.js';\nimport { On } from '../events/On.js';\nimport { Once } from '../events/Once.js';\nimport '../gameobjects/components/transform/GetVertices.js';\nimport '../gameobjects/components/bounds/BoundsComponent.js';\nimport '../gameobjects/components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport '../gameobjects/components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport '../gameobjects/components/transform/UpdateWorldTransform.js';\nimport '../gameobjects/components/transform/TransformComponent.js';\nimport { GameObject } from '../gameobjects/GameObject.js';\nimport { WorldRenderEvent } from './events/WorldRenderEvent.js';\nimport { WorldShutdownEvent } from './events/WorldShutdownEvent.js';\nimport './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport './UpdateCachedLayers.js';\nimport './WorldDepthFirstSearch.js';\nimport { BuildRenderList } from './BuildRenderList.js';\nimport { MergeRenderData } from './MergeRenderData.js';\nimport { ResetWorldRenderData } from './ResetWorldRenderData.js';\n\nclass BaseWorld extends GameObject {\r\n    constructor(scene) {\r\n        super();\r\n        this.forceRefresh = false;\r\n        this.type = 'BaseWorld';\r\n        this.scene = scene;\r\n        this.world = this;\r\n        this.events = new Map();\r\n        this._updateListener = On(scene, 'update', (delta, time) => this.update(delta, time));\r\n        this._renderListener = On(scene, 'render', (renderData) => this.render(renderData));\r\n        this._shutdownListener = On(scene, 'shutdown', () => this.shutdown());\r\n        Once(scene, 'destroy', () => this.destroy());\r\n    }\r\n    update(delta, time) {\r\n        if (!this.willUpdate) {\r\n            return;\r\n        }\r\n        Emit(this, UpdateEvent, delta, time, this);\r\n        super.update(delta, time);\r\n    }\r\n    postUpdate(delta, time) {\r\n        Emit(this, PostUpdateEvent, delta, time, this);\r\n    }\r\n    render(sceneRenderData) {\r\n        const renderData = this.renderData;\r\n        ResetWorldRenderData(renderData, sceneRenderData.gameFrame);\r\n        if (!this.willRender || !this.visible) {\r\n            return;\r\n        }\r\n        BuildRenderList(this);\r\n        Emit(this, WorldRenderEvent, renderData, this);\r\n        MergeRenderData(sceneRenderData, renderData);\r\n        if (this.camera) {\r\n            this.camera.dirtyRender = false;\r\n        }\r\n    }\r\n    shutdown() {\r\n        const scene = this.scene;\r\n        Off(scene, 'update', this._updateListener);\r\n        Off(scene, 'render', this._renderListener);\r\n        Off(scene, 'shutdown', this._shutdownListener);\r\n        RemoveChildren(this);\r\n        Emit(this, WorldShutdownEvent, this);\r\n        ResetWorldRenderData(this.renderData, 0);\r\n        if (this.camera) {\r\n            this.camera.reset();\r\n        }\r\n    }\r\n    destroy(reparentChildren) {\r\n        super.destroy(reparentChildren);\r\n        Emit(this, DestroyEvent, this);\r\n        ResetWorldRenderData(this.renderData, 0);\r\n        if (this.camera) {\r\n            this.camera.destroy();\r\n        }\r\n        this.events.clear();\r\n        this.camera = null;\r\n        this.renderData = null;\r\n        this.events = null;\r\n    }\r\n}\n\nexport { BaseWorld };\n","const UpdateEvent = 'update';\n\nexport { UpdateEvent };\n","const PostUpdateEvent = 'postupdate';\n\nexport { PostUpdateEvent };\n","const WorldRenderEvent = 'worldrender';\n\nexport { WorldRenderEvent };\n","function MergeRenderData(sceneRenderData, worldRenderData) {\r\n    sceneRenderData.numDirtyFrames += worldRenderData.dirtyFrame;\r\n    sceneRenderData.numTotalFrames += worldRenderData.numRendered;\r\n    if (worldRenderData.camera.dirtyRender) {\r\n        sceneRenderData.numDirtyCameras++;\r\n    }\r\n    sceneRenderData.worldData.push(worldRenderData);\r\n}\n\nexport { MergeRenderData };\n","import './GetChildIndex.js';\nimport './RemoveChildAt.js';\nimport { RemoveChild } from './RemoveChild.js';\n\nfunction RemoveChildren(parent, ...children) {\r\n    children.forEach(child => {\r\n        RemoveChild(parent, child);\r\n    });\r\n    return children;\r\n}\n\nexport { RemoveChildren };\n","const WorldShutdownEvent = 'worldshutdown';\n\nexport { WorldShutdownEvent };\n","import '../GameInstance.js';\nimport '../math/matrix2d/Matrix2D.js';\nimport '../geom/rectangle/Contains.js';\nimport '../geom/rectangle/Rectangle.js';\nimport '../utils/NOOP.js';\nimport '../math/vec2/Vec2Callback.js';\nimport { StaticCamera } from '../camera/StaticCamera.js';\nimport '../config/DefaultOrigin.js';\nimport '../display/DepthFirstSearch.js';\nimport '../display/GetChildIndex.js';\nimport '../display/RemoveChildAt.js';\nimport '../display/RemoveChild.js';\nimport '../gameobjects/events/AddedToWorldEvent.js';\nimport '../gameobjects/events/DestroyEvent.js';\nimport '../gameobjects/events/PostUpdateEvent.js';\nimport '../gameobjects/events/RemovedFromWorldEvent.js';\nimport '../gameobjects/events/UpdateEvent.js';\nimport '../events/Emit.js';\nimport '../display/SetWorld.js';\nimport '../display/SetParent.js';\nimport '../gameobjects/DIRTY_CONST.js';\nimport '../display/RemoveChildrenBetween.js';\nimport '../display/DestroyChildren.js';\nimport '../display/RemoveChildren.js';\nimport '../display/ReparentChildren.js';\nimport '../events/EventInstance.js';\nimport '../events/Off.js';\nimport '../events/On.js';\nimport '../events/Once.js';\nimport '../gameobjects/components/transform/GetVertices.js';\nimport '../gameobjects/components/bounds/BoundsComponent.js';\nimport '../gameobjects/components/input/InputComponent.js';\nimport '../math/vec2/Vec2.js';\nimport '../gameobjects/components/transform/UpdateLocalTransform.js';\nimport '../math/matrix2d/Copy.js';\nimport '../gameobjects/components/transform/UpdateWorldTransform.js';\nimport '../gameobjects/components/transform/TransformComponent.js';\nimport '../gameobjects/GameObject.js';\nimport './events/WorldRenderEvent.js';\nimport './events/WorldShutdownEvent.js';\nimport './CalculateTotalRenderable.js';\nimport './HasDirtyChildren.js';\nimport './UpdateCachedLayers.js';\nimport './WorldDepthFirstSearch.js';\nimport './BuildRenderList.js';\nimport './MergeRenderData.js';\nimport './ResetWorldRenderData.js';\nimport { BaseWorld } from './BaseWorld.js';\nimport { CreateWorldRenderData } from './CreateWorldRenderData.js';\n\nclass StaticWorld extends BaseWorld {\r\n    constructor(scene) {\r\n        super(scene);\r\n        this.type = 'StaticWorld';\r\n        this.camera = new StaticCamera();\r\n        this.renderData = CreateWorldRenderData(this.camera);\r\n    }\r\n}\n\nexport { StaticWorld };\n","function CreateWorldRenderData(camera) {\r\n    return {\r\n        camera,\r\n        gameFrame: 0,\r\n        dirtyFrame: 0,\r\n        numRendered: 0,\r\n        numRenderable: 0,\r\n        renderList: []\r\n    };\r\n}\n\nexport { CreateWorldRenderData };\n","import { SceneManagerInstance } from './SceneManagerInstance.js';\nimport { GetConfigValue } from './GetConfigValue.js';\n\nfunction Install(scene, config = {}) {\r\n    const sceneManager = SceneManagerInstance.get();\r\n    const size = sceneManager.scenes.size;\r\n    const sceneIndex = sceneManager.sceneIndex;\r\n    const firstScene = (size === 0);\r\n    if (typeof config === 'string') {\r\n        scene.key = config;\r\n    }\r\n    else if (config || (!config && firstScene)) {\r\n        scene.key = GetConfigValue(config, 'key', 'scene' + sceneIndex.toString());\r\n    }\r\n    if (sceneManager.scenes.has(scene.key)) {\r\n        console.warn('Scene key already in use: ' + scene.key);\r\n    }\r\n    else {\r\n        sceneManager.scenes.set(scene.key, scene);\r\n        sceneManager.flush = true;\r\n        sceneManager.sceneIndex++;\r\n    }\r\n}\n\nexport { Install };\n","function GetConfigValue(config, property, defaultValue) {\r\n    if (Object.prototype.hasOwnProperty.call(config, property)) {\r\n        return config[property];\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\n\nexport { GetConfigValue };\n","import { XType, YType } from '../IBoardData';\r\n\r\nexport let GetXYKey = function (\r\n    x: XType | undefined,\r\n    y: YType | undefined\r\n): string | undefined {\r\n\r\n    return ((x === undefined) || (y === undefined)) ? undefined : `${x}|${y}`;\r\n}","export class Stack {\r\n    items: any[];\r\n\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n\r\n    destroy(): void {\r\n        this.clear();\r\n        this.items = undefined;\r\n    }\r\n\r\n    pop(): any {\r\n        return (this.items.length > 0) ? this.items.pop() : null;\r\n    }\r\n\r\n    push(l: any): this {\r\n        this.items.push(l);\r\n        return this;\r\n    }\r\n\r\n    pushMultiple(arr: any[]): this {\r\n        this.items.push.apply(this.items, arr);\r\n        arr.length = 0;\r\n        return this;\r\n    }\r\n\r\n    clear(): this {\r\n        this.items.length = 0;\r\n        return this;\r\n    }\r\n}","import { Stack } from '../struct/Stack';\r\n\r\nlet globEmptyMapPool = new Stack();\r\n\r\nexport let GetEmptyMap = function (): Map<any, any> {\r\n    let newMap = globEmptyMapPool.pop();\r\n    if (newMap === null) {\r\n        newMap = new Map();\r\n    }\r\n    return newMap;\r\n}\r\n\r\nexport let FreeEmptyMap = function (map: Map<any, any>): void {\r\n    globEmptyMapPool.push(map);\r\n}\r\n\r\nexport let FreeEmptyMaps = function (maps: Map<any, any>[]): void {\r\n    globEmptyMapPool.pushMultiple(maps);\r\n}","import {\r\n    IChess,\r\n    XType, YType, ZType,\r\n    ZMapType\r\n} from '../IBoardData';\r\nimport { GetXYKey } from './Key';\r\nimport { FreeEmptyMap, GetEmptyMap } from '../../../../utils/pool/EmptyMap';\r\n\r\nexport let AddChessToZMap = function (\r\n    chess: IChess,\r\n    chessMap: Map<string, ZMapType>,\r\n    prevX: XType | undefined,\r\n    prevY: YType | undefined,\r\n    prevZ: ZType | undefined,\r\n    currX: XType | undefined,\r\n    currY: YType | undefined,\r\n    currZ: ZType | undefined\r\n) {\r\n    if ((prevX === currX) && (prevY === currY) && (prevZ === currZ)) {\r\n        return;\r\n    }\r\n    let prevKey = GetXYKey(prevX, prevY);\r\n    let currKey = GetXYKey(currX, currY);\r\n    if (prevKey) {\r\n        let zMap = chessMap.get(prevKey);\r\n        zMap.delete(prevZ);\r\n        if (prevKey === currKey) {\r\n            zMap.set(currZ, chess);\r\n            return;\r\n        } else if (zMap.size === 0) {\r\n            FreeEmptyMap(zMap); // Add to EmptyMap pool\r\n            chessMap.delete(prevKey);\r\n        }\r\n    }\r\n    if (currKey) {\r\n        let zMap = chessMap.get(currKey);\r\n        if (zMap) {\r\n            zMap.set(currZ, chess);\r\n        } else {\r\n            zMap = GetEmptyMap(); // Request an empty map\r\n            zMap.set(currZ, chess);\r\n            chessMap.set(currKey, zMap);\r\n        }\r\n    }\r\n}\r\n\r\nexport let RemoveChessFromZMap = function (\r\n    chessMap: Map<string, ZMapType>,\r\n    x: XType,\r\n    y: YType,\r\n    z?: ZType\r\n) {\r\n    let key = GetXYKey(x, y);\r\n    let zMap = chessMap.get(key);\r\n    if (zMap) {\r\n        if (z !== undefined) {\r\n            zMap.delete(z);\r\n            if (zMap.size === 0) {\r\n                FreeEmptyMap(zMap); // Add to EmptyMap pool\r\n                chessMap.delete(key);\r\n            }\r\n        } else {\r\n            zMap.clear();\r\n            FreeEmptyMap(zMap); // Add to EmptyMap pool\r\n            chessMap.delete(key);\r\n        }\r\n    }\r\n}","import { Stack } from '../struct/Stack';\r\n\r\nlet globEmptySetPool = new Stack();\r\n\r\nexport let GetEmptySet = function (): Set<any> {\r\n    let newMap = globEmptySetPool.pop();\r\n    if (newMap === null) {\r\n        newMap = new Set();\r\n    }\r\n    return newMap;\r\n}\r\n\r\nexport let FreeEmptySet = function (map: Set<any>): void {\r\n    globEmptySetPool.push(map);\r\n}\r\n\r\nexport let FreeEmptySets = function (maps: Set<any>[]): void {\r\n    globEmptySetPool.pushMultiple(maps);\r\n}","import {\r\n    ChessSetType,\r\n    IChess,\r\n    AnyKeyType\r\n} from '../IBoardData';\r\nimport { FreeEmptySet, GetEmptySet } from '../../../../utils/pool/EmptySet';\r\n\r\nexport let AddChessToSet = function (\r\n    chess: IChess,\r\n    chessMap: Map<AnyKeyType, ChessSetType>,\r\n    prevKey: AnyKeyType | undefined,\r\n    currKey: AnyKeyType | undefined\r\n): void {\r\n    if (prevKey === currKey) {\r\n        return;\r\n    }\r\n\r\n    if (prevKey !== undefined) {\r\n        let chessSet = chessMap.get(prevKey);\r\n        if (chessSet) {\r\n            chessSet.delete(chess);\r\n            if (chessSet.size === 0) {\r\n                FreeEmptySet(chessSet); // Add to EmptySet pool\r\n                chessMap.delete(prevKey);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currKey !== undefined) {\r\n        let chessSet = chessMap.get(currKey);\r\n        if (chessSet) {\r\n            chessSet.add(chess);\r\n        } else {\r\n            chessSet = GetEmptySet(); // Request an empty set\r\n            chessSet.add(chess);\r\n            chessMap.set(currKey, chessSet);\r\n        }\r\n    }\r\n}\r\n\r\nexport let RemoveChessFromSet = function (\r\n    chessMap: Map<AnyKeyType, ChessSetType>,\r\n    key: AnyKeyType,\r\n    chess: IChess\r\n): void {\r\n\r\n    let chessSet = chessMap.get(key);\r\n    if (chessSet) {\r\n        chessSet.delete(chess);\r\n        if (chessSet.size === 0) {\r\n            FreeEmptySet(chessSet); // Add to EmptySet pool\r\n            chessMap.delete(key);\r\n        }\r\n    }\r\n}","import {\r\n    IBoardData,\r\n    XType, YType, ZType,\r\n    IChess, ZMapType\r\n} from '../IBoardData';\r\nimport { GetXYKey } from './Key';\r\n\r\nexport let GetChess = function (\r\n    boardData: IBoardData,\r\n    x: XType,\r\n    y: YType,\r\n    z?: ZType\r\n): IChess | ZMapType | null {\r\n    let zMap = boardData.XYToZMap.get(GetXYKey(x, y));\r\n    if (zMap === undefined) {\r\n        return null;\r\n    }\r\n\r\n    if (z !== undefined) {\r\n        return (zMap.has(z)) ? zMap.get(z) : null;\r\n    } else {\r\n        return zMap;\r\n    }\r\n}","export let GetMaxMapKey = function (map: Map<number, any>) {\r\n    let result = -Infinity;\r\n    for (const [key, item] of map) {\r\n        if (result < key) {\r\n            result = key;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport let GetMinMapKey = function (map: Map<number, any>) {\r\n    let result = Infinity;\r\n    for (const [key, item] of map) {\r\n        if (result > key) {\r\n            result = key;\r\n        }\r\n    }\r\n    return result;\r\n}","import {\r\n    IBoardData,\r\n    ChessSetType, IChess, ZMapType,\r\n    XYZType, XType, YType, ZType\r\n} from './IBoardData';\r\nimport { AddChess } from './methods/AddChess';\r\nimport { GetChess } from './methods/GetChess';\r\nimport { RemoveChess } from './methods/RemoveChess';\r\nimport { HasChess } from './methods/HasChess';\r\nimport { Contains } from './methods/Contains';\r\nimport { GetXYZ } from './methods/GetXYZ';\r\nimport { GetMaxMapKey, GetMinMapKey } from './methods/GetMaxMinMapKey';\r\n\r\nexport class BoardData implements IBoardData {\r\n    chessToXYZ: Map<IChess, XYZType>; // {chess: {x,y,z}}\r\n    XYToZMap: Map<string, Map<ZType, IChess>>; // {'x|y': {z:chess}}\r\n    XToChessSet: Map<XType, ChessSetType>; // {x, [chess]}\r\n    YToChessSet: Map<YType, ChessSetType>; // {y, [chess]}\r\n    ZToChessSet: Map<ZType, ChessSetType>; // {z, [chess]}\r\n\r\n    _xMax: number | undefined;\r\n    _xMin: number | undefined;\r\n    _yMax: number | undefined;\r\n    _yMin: number | undefined;\r\n\r\n    constructor() {\r\n        this.chessToXYZ = new Map();\r\n        this.XYToZMap = new Map();\r\n        this.XToChessSet = new Map();\r\n        this.YToChessSet = new Map();\r\n        this.ZToChessSet = new Map();\r\n\r\n        this._xMax = undefined;\r\n        this._xMin = undefined;\r\n        this._yMax = undefined;\r\n        this._yMin = undefined;\r\n    }\r\n\r\n    destroy(): void {\r\n        this.clear();\r\n    }\r\n\r\n    clear(): this {\r\n        this.chessToXYZ.clear();\r\n        this.XYToZMap.clear();\r\n        this.XToChessSet.clear();\r\n        this.YToChessSet.clear();\r\n        this.ZToChessSet.clear();\r\n        this.clearBounds();\r\n        return this;\r\n    }\r\n\r\n    clearBounds(): this {\r\n        this._xMax = undefined;\r\n        this._xMin = undefined;\r\n        this._yMax = undefined;\r\n        this._yMin = undefined;\r\n        return this;\r\n    }\r\n\r\n    addChess(\r\n        chess: IChess,\r\n        x: XType,\r\n        y: YType,\r\n        z: ZType\r\n    ): this {\r\n\r\n        AddChess(this, chess, x, y, z);\r\n        this.clearBounds();\r\n        return this;\r\n    }\r\n\r\n    getChess(\r\n        x: XType,\r\n        y: YType,\r\n        z?: ZType\r\n    ): IChess | ZMapType | null {\r\n\r\n        return GetChess(this, x, y, z);\r\n    }\r\n\r\n    removeChess(\r\n        x: XType,\r\n        y: YType,\r\n        z?: ZType\r\n    ): this {\r\n\r\n        RemoveChess(this, x, y, z);\r\n        this.clearBounds();\r\n        return this;\r\n    }\r\n\r\n    hasChess(\r\n        chess: IChess\r\n    ): boolean {\r\n\r\n        return HasChess(this, chess);\r\n    }\r\n\r\n    contains(\r\n        x: XType,\r\n        y: YType,\r\n        z?: ZType\r\n    ): boolean {\r\n\r\n        return Contains(this, x, y, z);\r\n    }\r\n\r\n    getXYZ(\r\n        chess: IChess\r\n    ): XYZType | null {\r\n\r\n        return GetXYZ(this, chess);\r\n    }\r\n\r\n    get xMax() {\r\n        if (this._xMax === undefined) {\r\n            this._xMax = GetMaxMapKey(this.XToChessSet);\r\n        }\r\n        return this._xMax;\r\n    }\r\n\r\n    get xMin() {\r\n        if (this._xMin === undefined) {\r\n            this._xMin = GetMinMapKey(this.XToChessSet);\r\n        }\r\n        return this._xMin;\r\n    }\r\n\r\n    get yMax() {\r\n        if (this._yMax === undefined) {\r\n            this._yMax = GetMaxMapKey(this.YToChessSet);\r\n        }\r\n        return this._yMax;\r\n    }\r\n\r\n    get yMin() {\r\n        if (this._yMin === undefined) {\r\n            this._yMin = GetMinMapKey(this.YToChessSet);\r\n        }\r\n        return this._yMin;\r\n    }\r\n}\r\n\r\n\r\n","import {\r\n    IBoardData,\r\n    IChess,\r\n    XType, YType, ZType\r\n} from '../IBoardData';\r\nimport { AddChessToZMap } from './ZMap';\r\nimport { AddChessToSet } from './ChessSet';\r\n\r\nexport let AddChess = function (\r\n    boardData: IBoardData,\r\n    chess: IChess,\r\n    x: XType,\r\n    y: YType,\r\n    z: ZType\r\n): void {\r\n\r\n    let prevXYZ = boardData.chessToXYZ.get(chess);\r\n    let prevX = (prevXYZ) ? prevXYZ.x : undefined;\r\n    let prevY = (prevXYZ) ? prevXYZ.y : undefined;\r\n    let prevZ = (prevXYZ) ? prevXYZ.y : undefined;\r\n\r\n    if (prevXYZ) {\r\n        prevXYZ.x = x;\r\n        prevXYZ.y = y;\r\n        prevXYZ.z = z;\r\n    } else {\r\n        boardData.chessToXYZ.set(chess, { x: x, y: y, z: z });\r\n    }\r\n    AddChessToZMap(chess, boardData.XYToZMap, prevX, prevY, prevZ, x, y, z);\r\n    AddChessToSet(chess, boardData.XToChessSet, prevX, x);\r\n    AddChessToSet(chess, boardData.YToChessSet, prevY, y);\r\n    AddChessToSet(chess, boardData.ZToChessSet, prevZ, z);\r\n}","import {\r\n    IBoardData,\r\n    XType, YType, ZType,\r\n    IChess, ZMapType\r\n} from '../IBoardData';\r\nimport { GetChess } from './GetChess';\r\nimport { RemoveChessFromZMap } from './ZMap';\r\nimport { RemoveChessFromSet } from './ChessSet';\r\n\r\nexport let RemoveChess = function (\r\n    boardData: IBoardData,\r\n    x: XType,\r\n    y: YType,\r\n    z?: ZType\r\n): void {\r\n\r\n    if (z !== undefined) {\r\n        let chess = GetChess(boardData, x, y, z) as IChess;\r\n        if (chess === undefined) {\r\n            return;\r\n        }\r\n\r\n        boardData.chessToXYZ.delete(chess);\r\n        RemoveChessFromZMap(boardData.XYToZMap, x, y, z);\r\n        RemoveChessFromSet(boardData.XToChessSet, x, chess);\r\n        RemoveChessFromSet(boardData.YToChessSet, y, chess);\r\n        RemoveChessFromSet(boardData.ZToChessSet, z, chess);\r\n\r\n    } else {\r\n\r\n        let zMap = GetChess(boardData, x, y) as ZMapType;\r\n        if (zMap) {\r\n            for (const [z, chess] of zMap) {\r\n                boardData.chessToXYZ.delete(chess);\r\n                // RemoveChessFromZMap(boardData.XYToZMap, x, y, z);\r\n                RemoveChessFromSet(boardData.XToChessSet, x, chess);\r\n                RemoveChessFromSet(boardData.YToChessSet, y, chess);\r\n                RemoveChessFromSet(boardData.ZToChessSet, z, chess);\r\n\r\n            }\r\n\r\n            RemoveChessFromZMap(boardData.XYToZMap, x, y);\r\n\r\n        }\r\n    }\r\n}","import { IBoardData, IChess } from '../IBoardData';\r\n\r\nexport let HasChess = function (\r\n    boardData: IBoardData,\r\n    chess: IChess\r\n): boolean {\r\n\r\n    return boardData.chessToXYZ.has(chess);\r\n}","import {\r\n    IBoardData,\r\n    XType, YType, ZType\r\n} from '../IBoardData';\r\nimport { GetChess } from './GetChess';\r\n\r\nexport let Contains = function (\r\n    boardData: IBoardData,\r\n    x: XType,\r\n    y: YType,\r\n    z: ZType\r\n): boolean {\r\n\r\n    return (GetChess(boardData, x, y, z) !== null);\r\n}","import {\r\n    IBoardData,\r\n    IChess, XYZType\r\n} from '../IBoardData';\r\n\r\nexport let GetXYZ = function (\r\n    boardData: IBoardData,\r\n    chess: IChess\r\n): XYZType | null {\r\n    \r\n    return boardData.chessToXYZ.get(chess) || null;\r\n}","import { ILogicBoard } from '../ILogicBoard';\r\n\r\nexport let SetBoardWidth = function (\r\n    board: ILogicBoard,\r\n    width: number\r\n): void {\r\n\r\n    if (board.infinityMode) {\r\n        return;\r\n    }\r\n    if ((board.width === undefined) || (board.width <= width)) {\r\n        board.width = width;\r\n        return;\r\n    }\r\n\r\n    // this.width > width : collapse\r\n    for (let x = width; x < board.width; x++) {\r\n        for (let y = 0; y < board.height; y++) {\r\n            // TODO: RemoveChess\r\n        }\r\n    }\r\n\r\n    board.width = width;\r\n}","import { ILogicBoard } from '../ILogicBoard';\r\n\r\nexport let SetBoardHeight = function (\r\n    board: ILogicBoard,\r\n    height: number\r\n): void {\r\n\r\n    if (board.infinityMode) {\r\n        return;\r\n    }\r\n    if ((board.height === undefined) || (board.height <= height)) {\r\n        board.height = height;\r\n        return;\r\n    }\r\n\r\n    // board.height > height : collapse\r\n    for (let x = 0; x < board.width; x++) {\r\n        for (let y = height; y < board.height; y++) {\r\n\r\n            // TODO: RemoveChess\r\n        }\r\n    }\r\n\r\n    board.height = height;\r\n}","import {\r\n    ILogicBoard,\r\n    XType, YType, ZType,\r\n    IChess\r\n} from '../ILogicBoard';\r\n\r\nexport let TileXYZToChess = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ: ZType\r\n): IChess | null {\r\n\r\n    return board.boardData.getChess(tileX, tileY, tileZ) as IChess;\r\n}","import {\r\n    IChessData,\r\n    BlockerType, EdgeBlockerType\r\n} from './IChessData';\r\nimport { ILogicBoard, ZType, XYZType } from '../board/ILogicBoard';\r\n\r\nexport class ChessData implements IChessData {\r\n    parent: any;\r\n    board: ILogicBoard | null;\r\n    blocker: BlockerType | EdgeBlockerType;\r\n\r\n    constructor(parent: any) {\r\n        this.parent = parent;\r\n        this.board = null;\r\n        this.blocker = false;\r\n        this.boot();\r\n    }\r\n\r\n    boot() {\r\n        if ((typeof (this.parent) === 'object') && this.parent.on) {\r\n            this.parent.on('destroy', this.destroy, this);\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        if (this.board) {\r\n            this.board.removeChess(this.parent);\r\n        }\r\n\r\n        this.parent = undefined;\r\n        this.board = null;\r\n    }\r\n\r\n    setBoard(board: ILogicBoard | null): this {\r\n\r\n        this.board = board;\r\n        return this;\r\n    }\r\n\r\n    get tileXYZ(): XYZType | null {\r\n        if (this.board == null) {\r\n            return null;\r\n        }\r\n        return this.board.chessToTileXYZ(this.parent) as XYZType | null;\r\n    }\r\n\r\n    setTileZ(tileZ: ZType): this {\r\n\r\n        if (this.board == null) {\r\n            return this;\r\n        }\r\n\r\n        let tileXYZ = this.tileXYZ;\r\n        this.board.addChess(this.parent, tileXYZ.x, tileXYZ.y, tileZ, false);\r\n        return this;\r\n    }\r\n\r\n    setBlocker(value: boolean = true): this {\r\n\r\n        this.blocker = value;\r\n        return this;\r\n    }\r\n\r\n    setBlockEdge(\r\n        direction: number | object,\r\n        value: boolean = true\r\n    ): this {\r\n\r\n        if (typeof (this.blocker) === 'boolean') {\r\n            this.blocker = {};\r\n        }\r\n\r\n        let blocker = this.blocker;\r\n        if (typeof (direction) === 'object') {\r\n            let blockEdges = direction;\r\n            for (let dir in blockEdges) {\r\n                blocker[dir] = blockEdges[dir];\r\n            }\r\n        } else {\r\n            blocker[direction] = value;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    getBlockEdge(direction: number): boolean {\r\n\r\n        if (typeof (this.blocker) === 'boolean') {\r\n            return false;\r\n        }\r\n\r\n        if (!this.blocker.hasOwnProperty(direction)) {\r\n            return false;\r\n        } else {\r\n            return this.blocker[direction];\r\n        }\r\n    }\r\n}","import { IChessData } from './IChessData';\r\nimport { ChessData } from './ChessData';\r\nimport { IChess } from '../board/ILogicBoard';\r\n\r\nexport let GetChessData = function (\r\n    chess: IChess\r\n): IChessData {\r\n\r\n    if (!chess.hasOwnProperty('rexChess')) {\r\n        chess.rexChess = new ChessData(chess);\r\n    }\r\n    return chess.rexChess;\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XType, YType, XYZType\r\n} from '../ILogicBoard';\r\n\r\nexport let GridAlign = function (\r\n    board: ILogicBoard,\r\n    chess?: IChess,\r\n    tileX?: XType,\r\n    tileY?: YType\r\n): void {\r\n\r\n    if (chess === undefined) {\r\n        let chessArray = board.getAllChess();\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            let chess = chessArray[i];\r\n            let tileXYZ = board.chessToTileXYZ(chess) as XYZType;\r\n\r\n            board.tileXYToWorldXY(tileXYZ.x, tileXYZ.y, chess);\r\n        }\r\n    } else {\r\n        if (tileX === undefined) {\r\n            let tileXYZ = board.chessToTileXYZ(chess) as XYZType;\r\n            tileX = tileXYZ.x;\r\n            tileY = tileXYZ.y;\r\n        }\r\n\r\n        board.tileXYToWorldXY(tileX, tileY, chess);\r\n    }\r\n};","export let Between = function (\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number\r\n): number {\r\n\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n};\r\n","const RAD_TO_DEG = 180 / Math.PI;\r\n\r\nexport let RadToDeg = function (radians: number): number {\r\n\r\n    return radians * RAD_TO_DEG;\r\n};\r\n","export let ShortestBetween = function (\r\n    angle1: number,\r\n    angle2: number\r\n): number {\r\n\r\n    let difference = angle2 - angle1;\r\n    if (difference === 0) {\r\n        return 0;\r\n    }\r\n\r\n    let times = Math.floor((difference - (-180)) / 360);\r\n    return difference - (times * 360);\r\n};\r\n","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard'\r\n\r\nexport let AngleToward = function (\r\n    board: ILogicBoard,\r\n    tileXY: XYType,\r\n    direction: number\r\n): number {\r\n\r\n    if (tileXY === undefined) {\r\n        tileXY = zeroTileXY;\r\n    }\r\n    // Save wrapMode, infinityMode and clear them\r\n    let wrapModeSave = board.wrapMode;\r\n    let infinityModeSave = board.infinityMode;\r\n    board.wrapMode = false;\r\n    board.infinityMode = true;\r\n\r\n    // Get neighborTileXY\r\n    let neighborTileXY = board.getNeighborTileXY(tileXY, direction, true) as XYType;\r\n\r\n    // Restore wrapMode, infinityMode and clear them\r\n    board.wrapMode = wrapModeSave;\r\n    board.infinityMode = infinityModeSave;\r\n    return board.angleBetween(tileXY, neighborTileXY); // -PI~PI\r\n}\r\n\r\nlet zeroTileXY: XYType = { x: 0, y: 0 };","import { Vec2Type } from '../../utils/types/VectorType';\r\nexport { Vec2Type };\r\n\r\nexport interface IGrid {\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number\r\n\r\n    mode: number;\r\n    directions: number;\r\n    readonly sides: number;\r\n    readonly allDirections: number[];\r\n    readonly halfDirections: number[];\r\n\r\n    _savedOriginX: number;\r\n    _savedOriginY: number;\r\n\r\n    directionBetween(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        round?: boolean\r\n    ): number;\r\n\r\n    directionNormalize(\r\n        direction: number\r\n    ): number;\r\n\r\n    getDistance(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        roughMode?: boolean\r\n    ): number;\r\n\r\n    getGridPoints(\r\n        tileX?: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type[] | true\r\n    ): Vec2Type[];\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: Vec2Type,\r\n        neighborTileXY: Vec2Type\r\n    ): number | null;\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    getOppositeDirection(\r\n        tileX: number | Vec2Type,\r\n        tileY: number | undefined | null,\r\n        direction: number\r\n    ): number;\r\n\r\n    getTileXY(\r\n        worldX: number | Vec2Type,\r\n        worldY?: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    getTileXYAtDirection(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        distance: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    getWorldXY(\r\n        tileX: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    mirror(\r\n        srcTileXY: Vec2Type,\r\n        mode: MirrorMode | MirrorModeString,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    offset(\r\n        srcTileXY: Vec2Type,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    restoreOrigin(): this;\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: Vec2Type,\r\n        radius: number,\r\n        out?: Vec2Type[]\r\n    ): Vec2Type[];\r\n\r\n    rotate(\r\n        srcTileXY: Vec2Type,\r\n        dir: number,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type\r\n\r\n    saveOrigin(): this;\r\n\r\n    setDirectionMode(\r\n        mode: number\r\n    ): this;\r\n}\r\n\r\nexport enum MirrorMode {\r\n    x = 1,\r\n    horizontal = 1,\r\n    h = 1,\r\n    y = 2,\r\n    vertical = 2,\r\n    v = 2,\r\n    xy = 3,\r\n}\r\n\r\nexport type MirrorModeString = 'x' | 'y' | 'xy' | 'vertical' | 'horizontal' | 'v' | 'h';","import {\r\n    IGrid,\r\n    Vec2Type,\r\n    MirrorMode, MirrorModeString\r\n} from '../grid/IGrid';\r\nimport { IBoardData } from './boarddata/IBoardData';\r\nimport { IChessData, EdgeBlockerType } from '../chess/IChessData';\r\n\r\nexport type XType = number;\r\nexport type YType = number;\r\nexport type ZType = number | string;\r\nexport type XYType = {\r\n    x: XType,\r\n    y: YType\r\n}\r\nexport type XYZType = {\r\n    x: XType,\r\n    y: YType,\r\n    z: ZType\r\n}\r\nexport { Vec2Type };\r\nexport interface IChess {\r\n    rexChess?: IChessData;\r\n    x: number,\r\n    y: number,\r\n    destroy?: () => any;\r\n};\r\nexport { IChessData, EdgeBlockerType };\r\n\r\nexport interface IConfig {\r\n    grid?: IGrid;\r\n    wrap?: boolean;\r\n    inifinity?: boolean;\r\n    width?: number;\r\n    height?: number;\r\n}\r\n\r\n// ForEachTileXY\r\nexport type ForEachTileXYCallback = (tileXY: XYType, board: ILogicBoard) => void;\r\nexport enum ForEachTileXYOrder {\r\n    'x+,y+' = 0,\r\n    'x-,y+' = 1,\r\n    'y+,x+' = 2,\r\n    'y-,x+' = 3\r\n}\r\n\r\n// GetTileXYAtDirection\r\nexport type DistanceConfig = {\r\n    end?: number,\r\n    start?: number,\r\n    step?: number\r\n};\r\n\r\n// Mirror\r\nexport { MirrorMode, MirrorModeString };\r\n\r\nexport interface ILogicBoard {\r\n    boardData: IBoardData;\r\n    grid: IGrid;\r\n    wrapMode: boolean;\r\n    infinityMode: boolean;\r\n    width: number | undefined;\r\n    height: number | undefined;\r\n    _isBoard: boolean; // Set to false for miniboard\r\n\r\n    destroy(): void;\r\n    setWrapMode(\r\n        mode?: boolean\r\n    ): this;\r\n\r\n    setInfinityMode(\r\n        mode?: boolean\r\n    ): this;\r\n\r\n    setBoardSize(\r\n        width?: number,\r\n        height?: number\r\n    ): this;\r\n\r\n\r\n    addChess(\r\n        chess: IChess,\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType,\r\n        align?: boolean\r\n    ): this;\r\n\r\n    angleBetween(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType\r\n    ): number;\r\n\r\n    angleSnapToDirection(\r\n        tileXY: XYType,\r\n        angle: number\r\n    ): number;\r\n\r\n    angleToward(\r\n        tileXY: XYType,\r\n        direction: number\r\n    ): number;\r\n\r\n    areNeighbors(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType\r\n    ): boolean;\r\n\r\n    chessToTileXYZ(\r\n        chess: IChess | XYZType | XYType\r\n    ): XYZType | XYType | null;\r\n\r\n    contains(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType\r\n    ): boolean;\r\n\r\n    directionBetween(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        round?: boolean\r\n    ): number | null;\r\n\r\n    filledRingToTileXYArray(\r\n        centerTileXY: XYType,\r\n        radius: number,\r\n        nearToFar?: boolean,\r\n        out?: XYType[]\r\n    ): XYType[];\r\n\r\n    fit(\r\n        tileXYArray: XYType[]\r\n    ): XYType[];\r\n\r\n    forEachTileXY(\r\n        callback: ForEachTileXYCallback,\r\n        scope: any,\r\n        order?: number\r\n    ): this;\r\n\r\n    getAllChess(\r\n        out?: IChess[]\r\n    ): IChess[];\r\n\r\n    getChessData(\r\n        chess: IChess\r\n    ): IChessData;\r\n\r\n    getDistance(\r\n        tileA: XYType,\r\n        tileB: XYType,\r\n        roughMode?: boolean\r\n    ): number;\r\n\r\n    getEmptyTileXYArray(\r\n        tileZ?: ZType | ZType[],\r\n        out?: XYType[]\r\n    ): XYType[];\r\n\r\n    getGridPoints(\r\n        tileX?: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type[] | true\r\n    ): Vec2Type[];\r\n\r\n    getNeighborChess(\r\n        chess: IChess | XYType,\r\n        directions: number | number[] | string | null,\r\n        neighborTileZ?: ZType | null,\r\n        out?: IChess[]\r\n    ): IChess | IChess[] | null;\r\n\r\n    getNeighborChessDirection(\r\n        chess: IChess | XYType,\r\n        neighborChess: IChess | XYType\r\n    ): number;\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: XYType | null,\r\n        neighborTileXY: XYType | null\r\n    ): number | null;\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: XYType,\r\n        directions?: number | number[] | string | null,\r\n        out?: XYType | true\r\n    ): XYType | XYType[] | null;\r\n\r\n    getNeighborTileXYAtAngle(\r\n        srcTileXY: XYType,\r\n        angle: number,\r\n        out?: XYType | true\r\n    ): XYType | null;\r\n\r\n    getOppositeDirection(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        direction: number\r\n    ): number;\r\n\r\n    getRandomEmptyTileXY(\r\n        tileZ?: ZType,\r\n        out?: XYType | true\r\n    ): XYType | null;\r\n\r\n    getTileXYAtDirection(\r\n        chess: IChess | XYType,\r\n        directions: number | number[] | string | null,\r\n        distance: number | number[] | DistanceConfig,\r\n        out?: XYType | XYType[] | true\r\n    ): XYType | XYType[] | null;\r\n\r\n    getWrapTileXY(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out?: XYType | true\r\n    ): XYType;\r\n\r\n    gridAlign(\r\n        chess?: IChess,\r\n        tileX?: XType,\r\n        tileY?: YType\r\n    ): this;\r\n\r\n    hasBlocker(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType\r\n    ): boolean;\r\n\r\n    hasChess(\r\n        chess: IChess\r\n    ): boolean;\r\n\r\n    hasEdgeBlocker(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ: ZType | undefined,\r\n        direction: number\r\n    ): boolean;\r\n\r\n    isAngleInCone(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        face: number,\r\n        cone: number\r\n    ): boolean;\r\n\r\n    isDirectionInCone(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        face: number,\r\n        cone: number\r\n    ): boolean;\r\n\r\n    isOverlappingPoint(\r\n        worldX: number,\r\n        worldY: number,\r\n        tileZ?: ZType\r\n    ): boolean;\r\n\r\n    mirror(\r\n        tileXY: XYType,\r\n        mode: MirrorMode | MirrorModeString,\r\n        originTileXY?: XYType | null,\r\n        out?: XYType | true\r\n    ): XYType;\r\n\r\n    offset(\r\n        tileXY: XYType,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out?: XYType | true\r\n    ): XYType;\r\n\r\n    removeAllChess(\r\n        destroy?: boolean,\r\n        fromBoardRemove?: boolean\r\n    ): this;\r\n\r\n    removeChess(\r\n        chess: IChess | null,\r\n        tileX?: XType,\r\n        tileY?: YType,\r\n        tileZ?: ZType,\r\n        destroy?: boolean,\r\n        fromBoardRemove?: boolean\r\n    ): this;\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: XYType,\r\n        radius?: number,\r\n        out?: XYType[]\r\n    ): XYType[];\r\n\r\n    rotate(\r\n        tileXY: XYType,\r\n        direction: number,\r\n        originTileXY?: XYType | null,\r\n        out?: XYType | true\r\n    ): XYType;\r\n\r\n    setBoardWidth(\r\n        width?: number\r\n    ): this;\r\n\r\n    setBoardHeight(\r\n        height?: number\r\n    ): this;\r\n\r\n    swapChess(\r\n        chessA: IChess,\r\n        chessB: IChess,\r\n        align?: boolean\r\n    ): this;\r\n\r\n    tileXYArrayToChessArray(\r\n        tileXYArray: XYType[],\r\n        tileZ?: ZType,\r\n        out?: IChess[]\r\n    ): IChess[];\r\n\r\n    tileXYArrayToWorldXYArray(\r\n        tileXYArray: XYType[],\r\n        out?: Vec2Type[]\r\n    ): Vec2Type[];\r\n\r\n    tileXYToChessArray(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out?: IChess[]\r\n    ): IChess[];\r\n\r\n    tileXYZToChess(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ: ZType\r\n    ): IChess | null;\r\n\r\n    tileZToChessArray(\r\n        tileZ: ZType,\r\n        out?: IChess[]\r\n    ): IChess[];\r\n\r\n    tileXYToWorldXY(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out?: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    worldXYSnapToGrid(\r\n        worldX: number,\r\n        worldY: number,\r\n        out: Vec2Type | true\r\n    ): Vec2Type;\r\n\r\n    worldXYToChess(\r\n        worldX: number,\r\n        worldY: number,\r\n        tileZ?: ZType,\r\n        out?: IChess[]\r\n    ): IChess | IChess[];\r\n\r\n    worldXYToTileXY(\r\n        worldX: number,\r\n        worldY: number,\r\n        out?: XYType | true\r\n    ): XYType;\r\n}","import {\r\n    ILogicBoard,\r\n    XYType,\r\n    ForEachTileXYCallback, ForEachTileXYOrder\r\n} from '../ILogicBoard';\r\n\r\nexport let ForEachTileXY = function (\r\n    board: ILogicBoard,\r\n    callback: ForEachTileXYCallback,\r\n    scope: any,\r\n    order: ForEachTileXYOrder = ForEachTileXYOrder['x+,y+']\r\n): void {\r\n\r\n    let tileXY: XYType = { x: 0, y: 0 };\r\n    switch (order) {\r\n        case ForEachTileXYOrder['x+,y+']:\r\n            for (let tileY = 0; tileY < board.height; tileY++) {\r\n                for (let tileX = 0; tileX < board.width; tileX++) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case ForEachTileXYOrder['x-,y+']:\r\n            for (let tileY = 0; tileY < board.height; tileY++) {\r\n                for (let tileX = board.width - 1; tileX >= 0; tileX--) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case ForEachTileXYOrder['y+,x+']:\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                for (let tileY = 0; tileY < board.height; tileY++) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case ForEachTileXYOrder['y-,x+']:\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                for (let tileY = board.height - 1; tileY >= 0; tileY--) {\r\n                    tileXY.x = tileX;\r\n                    tileXY.y = tileY;\r\n                    if (scope) {\r\n                        callback.call(scope, tileXY, board);\r\n                    } else {\r\n                        callback(tileXY, board);\r\n                    }\r\n                }\r\n            }\r\n    }\r\n\r\n};","export let RandomInt = function (min: number, max: number): number {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n};","export let GetRandomItem = function (\r\n    array: any[] | string,\r\n    startIndex: number = 0,\r\n    length: number = array.length\r\n) {\r\n\r\n    let randomIndex = startIndex + Math.floor(Math.random() * length);\r\n    return (array[randomIndex] === undefined) ? null : array[randomIndex];\r\n};\r\n","import {\r\n    ILogicBoard,\r\n    XType, YType, ZType, XYType\r\n} from '../ILogicBoard';\r\nimport { RandomInt } from '../../../utils/math/RandomInt';\r\nimport { GetRandomItem } from '../../../utils/array/GetRandom';\r\n\r\nexport let GetRandomEmptyTileXY = function (\r\n    board: ILogicBoard,\r\n    tileZ: ZType = 0,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType | null {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    // Random picking a tileXY\r\n    let retryCount = Math.floor(board.width * board.height * 0.1);\r\n    for(let i =0; i< retryCount; i++) {\r\n        let tileX = RandomInt(0, board.width - 1) as XType;\r\n        let tileY = RandomInt(0, board.height - 1) as YType;\r\n        if (board.tileXYZToChess(tileX, tileY, tileZ) === null) {\r\n            out.x = tileX;\r\n            out.y = tileY;\r\n            return out;\r\n        }\r\n    }\r\n\r\n    // Not found any empty tileXY\r\n    // Get all empty tileXY\r\n    let tileXYArray = board.getEmptyTileXYArray(tileZ);\r\n    if (tileXYArray.length === 0) {\r\n        return null;\r\n    } else {\r\n        let tileXY: XYType = GetRandomItem(tileXYArray);\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n        return out;\r\n    }\r\n}\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };","import {\r\n    ILogicBoard,\r\n    IChess, XYType,\r\n    DistanceConfig\r\n} from '../ILogicBoard';\r\n\r\nexport let GetTileXYAtDirection = function (\r\n    board: ILogicBoard,\r\n    chess: IChess | XYType,\r\n    directions: number | number[] | string | null,\r\n    distance: number | number[] | DistanceConfig,\r\n    out?: XYType | XYType[] | true\r\n): XYType | XYType[] | null {\r\n\r\n    let srcTileXY = board.chessToTileXYZ(chess);\r\n    if (srcTileXY === null) {\r\n        return null;\r\n    }\r\n\r\n    if (typeof (directions) === 'string') {\r\n        if (directions.indexOf(',') === -1) {\r\n            directions = parseInt(directions);\r\n        } else {\r\n            directions = directions.split('.').map((dir) => parseInt(dir, 10))\r\n        }\r\n    }\r\n\r\n    let isNumberDirection = (typeof (directions) === 'number');\r\n    let isNumberDistance = (typeof (distance) === 'number');\r\n    if (isNumberDirection && isNumberDistance) {\r\n        // Directions is a number, distance is a number, return a singl tileXY\r\n        let result = board.grid.getTileXYAtDirection(\r\n            srcTileXY,\r\n            directions as number,\r\n            distance as number,\r\n            out as XYType | true\r\n        ) as XYType;\r\n        board.getWrapTileXY(result.x, result.y, result);\r\n        if ((result.x === null) || (result.y === null)) {\r\n            result = null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    if (!Array.isArray(out)) {\r\n        out = [];\r\n    }\r\n    if (directions === null) {\r\n        directions = board.grid.allDirections;\r\n    }\r\n\r\n    let resultTileXY: XYType;\r\n    if (isNumberDirection) {\r\n        // Directions is a number, distance is an object or array\r\n        if (Array.isArray(distance)) { // Distance is an array\r\n            for (let i = 0, cnt = distance.length; i < cnt; i++) {\r\n                resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, distance[i]) as XYType;\r\n                if (resultTileXY !== null) {\r\n                    out.push(resultTileXY);\r\n                }\r\n            }\r\n        } else {\r\n            let end: number,\r\n                start: number,\r\n                step: number;\r\n            ({\r\n                end = 1,\r\n                start = ((end > 0) ? 1 : -1),\r\n                step = ((end >= start) ? 1 : -1)\r\n            } = distance as DistanceConfig);\r\n\r\n            if (start === end) {\r\n                resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, end) as XYType; // Return a single tileXY\r\n                if (resultTileXY !== null) {\r\n                    out.push(resultTileXY);\r\n                }\r\n            } else if (start < end) {\r\n                for (let i = start; i <= end; i += step) {\r\n                    resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, i) as XYType; // return a single tileXY\r\n                    if (resultTileXY !== null) {\r\n                        out.push(resultTileXY);\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = start; i >= end; i += step) {\r\n                    resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions, i) as XYType; // Return a single tileXY\r\n                    if (resultTileXY !== null) {\r\n                        out.push(resultTileXY);\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    } else { // Directions is a list\r\n        for (let i = 0, cnt = (directions as number[]).length; i < cnt; i++) {\r\n            if (isNumberDistance) { // Return a single tileXY\r\n                resultTileXY = GetTileXYAtDirection(board, srcTileXY, directions[i], distance) as XYType;\r\n                if (resultTileXY !== null) {\r\n                    out.push(resultTileXY);\r\n                }\r\n            } else { // Append an array of tileXY\r\n                GetTileXYAtDirection(board, srcTileXY, directions[i], distance, out);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    return out;\r\n}","export let Wrap = function (\r\n    value: number,\r\n    min: number,\r\n    max: number\r\n): number {\r\n\r\n    let range = max - min;\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n","import {\r\n    ILogicBoard,\r\n    XType, YType, XYType\r\n} from '../ILogicBoard';\r\nimport { Wrap } from '../../../utils/math/Wrap';\r\n\r\nexport let GetWrapTileXY = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if (board.wrapMode) {\r\n        tileX = Wrap(tileX, 0, board.width);\r\n    } else if ((!board.infinityMode) &&\r\n        ((tileX < 0) || (tileX >= board.width))) {\r\n        tileX = null;\r\n    }\r\n    if (board.wrapMode) {\r\n        tileY = Wrap(tileY, 0, board.height);\r\n    } else if ((!board.infinityMode) &&\r\n        ((tileY < 0) || (tileY >= board.height))) {\r\n        tileY = null;\r\n    }\r\n    out.x = tileX;\r\n    out.y = tileY;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };","import {\r\n    ILogicBoard,\r\n    XType, YType, ZType,\r\n    EdgeBlockerType\r\n} from '../ILogicBoard'\r\n\r\nexport let HasEdgeBlocker = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ: ZType | undefined,\r\n    direction: number\r\n): boolean {\r\n\r\n    if (tileZ === undefined) {\r\n        // any chess at (tileX, tileY) has blocker\r\n        let chessArray = board.tileXYToChessArray(tileX, tileY);\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            if (IsEdgeBlocker(board.getChessData(chessArray[i]).blocker, direction)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n\r\n    } else {\r\n        // chess at (tileX, tileY, tileZ) has blocker\r\n        let chess = board.tileXYZToChess(tileX, tileY, tileZ);\r\n        if (chess === null) {\r\n            return false;\r\n        }\r\n        return IsEdgeBlocker(board.getChessData(chess).blocker, direction);\r\n    }\r\n}\r\n\r\nlet IsEdgeBlocker = function (\r\n    blocker: EdgeBlockerType | boolean,\r\n    direction: number\r\n): boolean {\r\n\r\n    if ((blocker === false) || (blocker === true)) {\r\n        return blocker;\r\n    } else {\r\n        return (blocker[direction] === true);\r\n    }\r\n}","export let Normalize = function (angle: number): number {\r\n    angle = angle % PI2;\r\n\r\n    if (angle >= 0) {\r\n        return angle;\r\n    }\r\n    else {\r\n        return angle + PI2;\r\n    }\r\n};\r\n\r\nconst PI2 = Math.PI * 2;\r\n","export let Equal = function (\r\n    a: number,\r\n    b: number,\r\n    epsilon: number = 0.0001\r\n): boolean {\r\n\r\n    return Math.abs(a - b) < epsilon;\r\n};\r\n","import {\r\n    ILogicBoard,\r\n    IChess, XYType\r\n} from '../ILogicBoard';\r\nimport { Normalize as AngleNormalize } from '../../../utils/math/angle/Normalize';\r\nimport { Equal } from '../../../utils/math/fuzzy/Equal';\r\n\r\nexport let IsAngleInCone = function (\r\n    board: ILogicBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType,\r\n    face: number,\r\n    cone: number\r\n): boolean {\r\n\r\n    let tileXYA = board.chessToTileXYZ(chessA);\r\n    let tileXYB = board.chessToTileXYZ(chessB);\r\n    let targetAngle = board.angleBetween(tileXYA, tileXYB); // -PI~PI\r\n    targetAngle = AngleNormalize(targetAngle); // 0~2PI\r\n    let deltaAngle = Math.abs(targetAngle - face);\r\n    deltaAngle = Math.min(deltaAngle, PI2 - deltaAngle);\r\n    let halfCone = cone / 2;\r\n    return Equal(deltaAngle, halfCone) || (deltaAngle < halfCone);\r\n}\r\n\r\nconst PI2 = Math.PI * 2;","import {\r\n    ILogicBoard,\r\n    IChess, XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let IsDirectionInCone = function (\r\n    board: ILogicBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType,\r\n    face: number,\r\n    cone: number\r\n): boolean {\r\n\r\n    let tileXYA = board.chessToTileXYZ(chessA);\r\n    let tileXYB = board.chessToTileXYZ(chessB);\r\n\r\n    let savedDirections = board.grid.directions; // Save directions\r\n    board.grid.directions = board.grid.sides;\r\n    let direction = board.grid.directionBetween(tileXYA, tileXYB, false);\r\n    board.grid.directions = savedDirections; // Restore directions\r\n\r\n    let deltaDirection = Math.abs(direction - face);\r\n    deltaDirection = Math.min(deltaDirection, board.grid.directions - deltaDirection);\r\n    return (deltaDirection <= (cone / 2));\r\n}","import {\r\n    ILogicBoard,\r\n    XYType,\r\n    MirrorMode, MirrorModeString\r\n} from '../ILogicBoard';\r\n\r\nexport let Mirror = function (\r\n    board: ILogicBoard,\r\n    tileXY: XYType,\r\n    mode: MirrorMode | MirrorModeString,\r\n    originTileXY: XYType | null = null,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if (originTileXY !== null) {\r\n        board.offset(tileXY, -originTileXY.x, -originTileXY.y, out);\r\n    } else {\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n    }\r\n    board.grid.mirror(out, mode, out);\r\n    if (originTileXY !== null) {\r\n        board.offset(out, originTileXY.x, originTileXY.y, out);\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let Offset = function (\r\n    board: ILogicBoard,\r\n    tileXY: XYType,\r\n    offsetTileX: number,\r\n    offsetTileY: number,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if ((offsetTileX === 0) && (offsetTileY === 0)) {\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n    } else {\r\n        board.grid.offset(tileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let Rotate = function (\r\n    board: ILogicBoard,\r\n    tileXY: XYType,\r\n    direction: number,\r\n    originTileXY: XYType | null = null,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    if (originTileXY !== null) {\r\n        board.offset(tileXY, -originTileXY.x, -originTileXY.y, out);\r\n    } else {\r\n        out.x = tileXY.x;\r\n        out.y = tileXY.y;\r\n    }\r\n    board.grid.rotate(out, direction, out);\r\n    if (originTileXY !== null) {\r\n        board.offset(out, originTileXY.x, originTileXY.y, out);\r\n    }\r\n    return out;\r\n};\r\n\r\nlet globTileXY: XYType = { x: 0, y: 0 };","import {\r\n    ILogicBoard,\r\n    XType, YType,\r\n    IChess\r\n} from '../ILogicBoard';\r\nimport { ZMapType } from '../boarddata/IBoardData';\r\n\r\nexport let TileXYToChessArray = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let zMap = board.boardData.getChess(tileX, tileY) as ZMapType;\r\n    for (const [tileZ, chess] of zMap) {\r\n        out.push(chess);\r\n    }\r\n    return out;\r\n}","import { ILogicBoard, Vec2Type } from '../ILogicBoard';\r\n\r\nexport let WorldXYSnapToGrid = function (\r\n    board: ILogicBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globWorldXY;\r\n    }\r\n\r\n    board.worldXYToTileXY(worldX, worldY, out);\r\n    board.tileXYToWorldXY(out.x, out.y, out);\r\n    return out;\r\n};\r\n\r\nlet globWorldXY: Vec2Type = { x: 0, y: 0 };","export enum LayoutMode {\r\n    'orthogonal' = 0,\r\n    'isometric' = 1\r\n}\r\n\r\nexport type LayoutModeString = 'orthogonal' | 'isometric';\r\n\r\nexport enum DirMode {\r\n    '4dir' = 4,\r\n    '8dir' = 8\r\n};\r\n\r\nexport type DirModeString = '4dir' | '8dir';\r\n\r\nexport interface IConfig {\r\n    x?: number,\r\n    y?: number,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n    type?: LayoutMode | LayoutModeString,\r\n    dir?: DirMode | DirModeString\r\n}\r\n\r\nexport interface IState {\r\n    x?: number,\r\n    y?: number,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n    type?: LayoutMode | LayoutModeString,\r\n    dir?: DirMode | DirModeString\r\n}\r\n\r\nexport interface IQuadBase {\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number\r\n\r\n    _halfWidth: number,\r\n    _halfHeight: number,\r\n    mode: LayoutMode,\r\n    directions: DirMode,\r\n};","// orthogonal or isometric\r\nexport type DirectionToDeltaXYType = [number, number][];\r\n\r\nconst OrthogonalMap: DirectionToDeltaXYType = [\r\n    [1, 0],\r\n    [0, 1],\r\n    [-1, 0],\r\n    [0, -1],\r\n    [1, 1],\r\n    [-1, 1],\r\n    [-1, -1],\r\n    [1, -1]\r\n];\r\nconst IsometricMap: DirectionToDeltaXYType = OrthogonalMap;\r\n\r\nexport {\r\n    OrthogonalMap,\r\n    IsometricMap\r\n};","import {\r\n    OrthogonalMap as OrthogonalMapIn,\r\n    IsometricMap as IsometricMapIn,\r\n    DirectionToDeltaXYType\r\n} from './DirectionToDeltaXY';\r\n\r\nexport type DeltaXYToDirectionType = {\r\n    [x: number]: {\r\n        [y: number]: number\r\n    }\r\n}\r\n\r\nlet ReverseDirMap = function (\r\n    dirMap: DirectionToDeltaXYType\r\n): DeltaXYToDirectionType {\r\n\r\n    let out: DeltaXYToDirectionType = {},\r\n        entry: [number, number],\r\n        x: number,\r\n        y: number;\r\n    for (let dir in dirMap) {\r\n        entry = dirMap[dir]; // [x, y]\r\n        x = entry[0];\r\n        y = entry[1];\r\n        if (!out.hasOwnProperty(x)) {\r\n            out[x] = {}\r\n        }\r\n        out[x][y] = parseInt(dir);\r\n    }\r\n    return out;\r\n}\r\n\r\nconst OrthogonalMapOut = ReverseDirMap(OrthogonalMapIn);\r\nconst IsometricMapOut = ReverseDirMap(IsometricMapIn);\r\n\r\nexport {\r\n    OrthogonalMapOut as OrthogonalMap,\r\n    IsometricMapOut as IsometricMap\r\n};","export enum LayoutMode {\r\n    ODD_R = 0,\r\n    EVEN_R = 1,\r\n    ODD_Q = 2,\r\n    EVEN_Q = 3\r\n}\r\n\r\nexport type LayoutModeString = 'ODD_R' | 'EVEN_R' | 'ODD_Q' | 'EVEN_Q'\r\n\r\nexport enum StaggerAxis {\r\n    y = 0,\r\n    flat = 0,\r\n    x = 1,\r\n    pointy = 1\r\n}\r\n\r\nexport type StaggerAxisString = 'y' | 'x' | 'flat' | 'pointy';\r\n\r\nexport enum StaggerIndex {\r\n    even = 0,\r\n    odd = 1\r\n}\r\n\r\nexport type StaggerIndexString = 'even' | 'odd';\r\n\r\nexport interface IState {\r\n    x?: number,\r\n    y?: number,\r\n\r\n    radius?: number,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n\r\n    staggerAxis?: StaggerAxis | StaggerAxisString,\r\n    staggerIndex?: StaggerIndex | StaggerIndexString\r\n}\r\n\r\nexport interface IConfig {\r\n    x?: number,\r\n    y?: number,\r\n\r\n    radius?: number | undefined,\r\n    cellWidth?: number,\r\n    cellHeight?: number,\r\n\r\n    staggerAxis?: StaggerAxis | StaggerAxisString,\r\n    staggerIndex?: StaggerIndex | StaggerIndexString\r\n}\r\n\r\nexport interface IHexagonBase {\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number\r\n\r\n    _halfWidth: number,\r\n    _halfHeight: number,\r\n    radius: number,\r\n    mode: LayoutMode,\r\n    directions: number,\r\n    staggerAxis: StaggerAxis\r\n};","import {\r\n    IHexagonBase, IConfig, IState,\r\n    StaggerAxis, StaggerAxisString, StaggerIndex, StaggerIndexString, LayoutMode\r\n} from './IHexagonBase';\r\n\r\nexport class HexagonBase implements IHexagonBase {\r\n    x: number;\r\n    y: number;\r\n\r\n    _width: number;\r\n    _height: number;\r\n    _halfWidth: number;\r\n    _halfHeight: number;\r\n    radius: number;\r\n\r\n    mode: LayoutMode;\r\n    staggerAxis: StaggerAxis;\r\n    staggerIndex: StaggerIndex;\r\n    directions: number;\r\n\r\n    constructor({\r\n        x = 0,\r\n        y = 0,\r\n        radius = undefined,\r\n        cellWidth = 0,\r\n        cellHeight = 0,\r\n        staggerAxis = StaggerAxis.x,\r\n        staggerIndex = StaggerIndex.odd\r\n    }: IConfig = {}) {\r\n\r\n        this.setType(staggerAxis, staggerIndex);\r\n        this.setDirectionMode();\r\n\r\n        this.setOriginPosition(x, y);\r\n\r\n        if (radius !== undefined) {\r\n            this.setRadius(radius);\r\n        } else {\r\n            this.setCellSize(cellWidth, cellHeight);\r\n        }\r\n    }\r\n\r\n    fromJSON({\r\n        x = 0,\r\n        y = 0,\r\n        radius = undefined,\r\n        cellWidth = 0,\r\n        cellHeight = 0,\r\n        staggerAxis = StaggerAxis.x,\r\n        staggerIndex = StaggerIndex.odd\r\n    }: IState = {}): this {\r\n\r\n        this.setType(staggerAxis, staggerIndex);\r\n        this.setDirectionMode();\r\n\r\n        this.setOriginPosition(x, y);\r\n        if (radius !== undefined) {\r\n            this.setRadius(radius);\r\n        } else {\r\n            this.setCellSize(cellWidth, cellHeight);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    toJSON(): IState {\r\n        return {\r\n            x: this.x,\r\n            y: this.y,\r\n\r\n            radius: this.radius,\r\n            cellWidth: this.cellWidth,\r\n            cellHeight: this.cellHeight,\r\n            staggerAxis: this.staggerAxis,\r\n            staggerIndex: this.staggerIndex\r\n        }\r\n    }\r\n\r\n    setOriginPosition(x: number, y: number): this {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    set width(value: number) {\r\n        this._width = value;\r\n        this._halfWidth = value / 2;\r\n    }\r\n\r\n    get height() {\r\n        return this._height;\r\n    }\r\n\r\n    set height(value: number) {\r\n        this._height = value;\r\n        this._halfHeight = value / 2;\r\n    }\r\n\r\n    setCellSize(width: number = 0, height: number = 0): this {\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.radius = undefined;\r\n        return this;\r\n    }\r\n\r\n    get cellWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    set cellWidth(value: number) {\r\n        this.width = value;\r\n    }\r\n\r\n    get cellHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    set cellHeight(value: number) {\r\n        this.height = value;\r\n    }\r\n\r\n    setRadius(radius: number = 0): this {\r\n\r\n        let cellWidth: number,\r\n            cellHeight: number;\r\n        if (this.staggerAxis === StaggerAxis.y) {\r\n            cellWidth = 2 * radius;\r\n            cellHeight = SQRT3 * radius;\r\n        } else {\r\n            cellWidth = SQRT3 * radius;\r\n            cellHeight = 2 * radius;\r\n        }\r\n        this.setCellSize(cellWidth, cellHeight);\r\n        this.radius = radius;\r\n        return this;\r\n    }\r\n\r\n    setDirectionMode(): this {\r\n        this.directions = 6;\r\n        return this;\r\n    }\r\n\r\n    setType(\r\n        staggerAxis: StaggerAxis | StaggerAxisString = 1,\r\n        staggerIndex: StaggerIndex | StaggerIndexString = 1\r\n    ): this {\r\n\r\n        if (typeof (staggerAxis) === 'string') {\r\n            staggerAxis = StaggerAxis[staggerAxis]\r\n        }\r\n        if (typeof (staggerIndex) === 'string') {\r\n            staggerIndex = StaggerIndex[staggerIndex]\r\n        }\r\n\r\n        this.staggerAxis = staggerAxis;\r\n        this.staggerIndex = staggerIndex;\r\n        if (staggerAxis === StaggerAxis.y) { // flat\r\n            this.mode = (staggerIndex === StaggerIndex.even) ? LayoutMode.EVEN_Q : LayoutMode.ODD_Q;\r\n        } else { // pointy\r\n            this.mode = (staggerIndex === StaggerIndex.even) ? LayoutMode.EVEN_R : LayoutMode.ODD_R;\r\n        }\r\n        return this;\r\n    }\r\n}\r\n\r\nconst SQRT3 = Math.sqrt(3);","import { LayoutMode } from './IHexagonBase';\r\n\r\nexport type CubeType = {\r\n    x: number,\r\n    y: number,\r\n    z: number\r\n}\r\n\r\nexport type ColRowType = {\r\n    x: number,\r\n    y: number\r\n}\r\n\r\nexport type QRType = {\r\n    q: number,\r\n    r: number\r\n}\r\n\r\nexport function cr2cube(\r\n    mode: LayoutMode,\r\n    col: number,\r\n    row: number,\r\n    out: CubeType | true = { x: 0, y: 0, z: 0 }\r\n): CubeType {\r\n\r\n    if (out === true) {\r\n        out = globCube;\r\n    }\r\n\r\n    switch (mode) {\r\n        case LayoutMode.ODD_R:\r\n            out.x = col - (row - (row & 1)) / 2;\r\n            out.z = row;\r\n            break;\r\n\r\n        case LayoutMode.EVEN_R:\r\n            out.x = col - (row + (row & 1)) / 2;\r\n            out.z = row;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            out.x = col;\r\n            out.z = row - (col - (col & 1)) / 2;\r\n            break;\r\n        case LayoutMode.EVEN_Q:\r\n            out.x = col;\r\n            out.z = row - (col + (col & 1)) / 2;\r\n            break;\r\n    }\r\n    out.y = -out.x - out.z;\r\n    return out;\r\n}\r\n\r\nexport function roundcube(\r\n    x: number | CubeType,\r\n    y?: number,\r\n    z?: number,\r\n    out: CubeType | true = { x: 0, y: 0, z: 0 }\r\n): CubeType {\r\n\r\n    if (typeof (x) !== 'number') {\r\n        out = x;\r\n        x = out.x;\r\n        y = out.y;\r\n        z = out.z;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globCube;\r\n    }\r\n\r\n    let rx = Math.round(x);\r\n    let ry = Math.round(y);\r\n    let rz = Math.round(z);\r\n\r\n    let dx = Math.abs(rx - x);\r\n    let dy = Math.abs(ry - y);\r\n    let dz = Math.abs(rz - z);\r\n\r\n    if ((dx > dy) && (dx > dz)) {\r\n        rx = -ry - rz;\r\n    } else if (dy > dz) {\r\n        ry = -rx - rz;\r\n    } else {\r\n        rz = -rx - ry;\r\n    }\r\n    out.x = rx;\r\n    out.y = ry;\r\n    out.z = rz;\r\n    return out;\r\n}\r\n\r\nexport function cube2cr(\r\n    mode: LayoutMode,\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    out: ColRowType | true = { x: 0, y: 0 }\r\n): ColRowType {\r\n\r\n    if (out === true) {\r\n        out = globCR;\r\n    }\r\n\r\n    switch (mode) {\r\n        case LayoutMode.ODD_R:\r\n            out.x = x + (z - (z & 1)) / 2;\r\n            out.y = z;\r\n            break;\r\n        case LayoutMode.EVEN_R:\r\n            out.x = x + (z + (z & 1)) / 2;\r\n            out.y = z;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            out.x = x;\r\n            out.y = z + (x - (x & 1)) / 2;\r\n            break;\r\n        case LayoutMode.EVEN_Q:\r\n            out.x = x;\r\n            out.y = z + (x + (x & 1)) / 2;\r\n            break;\r\n    }\r\n    return out;\r\n}\r\n\r\nexport function qr2cube(\r\n    q: number,\r\n    r: number,\r\n    out: CubeType | true = { x: 0, y: 0, z: 0 }\r\n): CubeType {\r\n\r\n    if (out === true) {\r\n        out = globCube;\r\n    }\r\n    out.x = q;\r\n    out.y = -q - r;\r\n    out.z = r;\r\n    return out;\r\n}\r\n\r\nexport function cube2qr(\r\n    x: number,\r\n    y: number,\r\n    z: number,\r\n    out: QRType | true = { q: 0, r: 0 }\r\n): QRType {\r\n\r\n    if (out === true) {\r\n        out = globQR;\r\n    }\r\n\r\n    out.q = x;\r\n    out.r = z;\r\n    return out;\r\n}\r\n\r\nlet globCube: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globCR: ColRowType = { x: 0, y: 0 };\r\nlet globQR: QRType = { q: 0, r: 0 };","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, CubeType } from './CubeTransfer';\r\n\r\nexport let DirectionBetween = function (\r\n    hexagon: IHexagonBase,\r\n    tileA: Vec2Type,\r\n    tileB: Vec2Type,\r\n    round: boolean = true\r\n): number {\r\n\r\n    let direction: number;\r\n    cr2cube(hexagon.mode, tileA.x, tileA.y, globCubeA);\r\n    cr2cube(hexagon.mode, tileB.x, tileB.y, globCubeB);\r\n    let dx = globCubeB.x - globCubeA.x;\r\n    let dy = globCubeB.y - globCubeA.y;\r\n    let dz = globCubeB.z - globCubeA.z;\r\n    if (dz === 0) {\r\n        direction = (dx > 0) ? 0 : 3;\r\n    } else if (dx === 0) {\r\n        direction = (dz > 0) ? 1 : 4;\r\n    } else if (dy === 0) {\r\n        direction = (dz > 0) ? 2 : 5;\r\n    } else if ((dx > 0) && (dy < 0) && (dz > 0)) { // 0~1\r\n        direction = 0 + (dz / (-dy));\r\n    } else if ((dx < 0) && (dy < 0) && (dz > 0)) { // 1~2\r\n        direction = 1 + ((-dy) / dz);\r\n    } else if ((dx < 0) && (dy > 0) && (dz > 0)) { // 2~3\r\n        direction = 2 + (dy / (-dx));\r\n    } else if ((dx < 0) && (dy > 0) && (dz < 0)) { // 3~4\r\n        direction = 3 + ((-dz) / dy);\r\n    } else if ((dx > 0) && (dy > 0) && (dz < 0)) { // 4~5\r\n        direction = 4 + (dx / (-dz));\r\n    } else { // ((dx > 0) && (dy < 0) && (dz < 0)) // 5~0\r\n        direction = 5 + ((-dy) / dx);\r\n    }\r\n\r\n    if (round) {\r\n        direction = Math.round(direction);\r\n    }\r\n    return direction;\r\n}\r\n\r\nlet globCubeA: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globCubeB: CubeType = { x: 0, y: 0, z: 0 };","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, CubeType } from './CubeTransfer';\r\n\r\nexport let GetDistance = function (\r\n    hexagon: IHexagonBase,\r\n    tileA: Vec2Type,\r\n    tileB: Vec2Type,\r\n    roughMode: boolean = false\r\n): number {\r\n\r\n    cr2cube(hexagon.mode, tileA.x, tileA.y, globCubeA);\r\n    cr2cube(hexagon.mode, tileB.x, tileB.y, globCubeB);\r\n    let dx = globCubeB.x - globCubeA.x;\r\n    let dy = globCubeB.y - globCubeA.y;\r\n    let dz = globCubeB.z - globCubeA.z;\r\n    return (Math.abs(dx) + Math.abs(dy) + Math.abs(dz)) / 2;\r\n}\r\n\r\nlet globCubeA: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globCubeB: CubeType = { x: 0, y: 0, z: 0 };\r\n\r\nexport default GetDistance;","import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetWorldXY = function (\r\n    hexagon: IHexagonBase,\r\n    tileX: number | Vec2Type,\r\n    tileY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (tileX) === 'object') {\r\n        tileY = tileX.y;\r\n        tileX = tileX.x;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globWorldXY;\r\n    }\r\n\r\n    let worldX = (tileX * hexagon.width);\r\n    let worldY = (tileY * hexagon.height);\r\n    switch (hexagon.mode) {\r\n        case LayoutMode.ODD_R:\r\n            if (tileY & 1) {\r\n                worldX += hexagon._halfWidth;\r\n            }\r\n            worldY *= 0.75;\r\n            break;\r\n\r\n        case LayoutMode.EVEN_R:\r\n            if (tileY & 1) {\r\n                worldX -= hexagon._halfWidth;\r\n            }\r\n            worldY *= 0.75;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            worldX *= 0.75;\r\n            if (tileX & 1) {\r\n                worldY += hexagon._halfHeight;\r\n            }\r\n            break;\r\n\r\n        case LayoutMode.EVEN_Q:\r\n            worldX *= 0.75;\r\n            if (tileX & 1) {\r\n                worldY -= hexagon._halfHeight;\r\n            }\r\n            break;\r\n    }\r\n    worldX += hexagon.x;\r\n    worldY += hexagon.y;\r\n    out.x = worldX;\r\n    out.y = worldY;\r\n    return out;\r\n}\r\n\r\nlet globWorldXY: Vec2Type = { x: 0, y: 0 };","const DEG_TO_RAD = Math.PI / 180;\r\n\r\nexport let DegToRad = function (degrees: number): number {\r\n\r\n    return degrees * DEG_TO_RAD;\r\n};\r\n","import { IHexagonBase, StaggerAxis } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { FillPositionArray } from '../utils/FillPositionArray';\r\nimport { GetWorldXY } from './GetWorldXY';\r\nimport { DegToRad } from '../../../utils/math/angle/DegToRad';\r\n\r\nexport let GetGridPoints = function (\r\n    hexagon: IHexagonBase,\r\n    tileX: number | Vec2Type = 0,\r\n    tileY: number = 0,\r\n    out: Vec2Type[] | true = []\r\n): Vec2Type[] {\r\n\r\n    if (typeof (tileX) === 'object') {\r\n        let tileXY = tileX;\r\n        tileY = tileXY.y;\r\n        tileX = tileXY.x;\r\n    }\r\n    if (out === true) {\r\n        out = globPoints;\r\n    }\r\n\r\n    FillPositionArray(6, out);\r\n\r\n    let x: number,\r\n        y: number;\r\n    ({ x, y } = GetWorldXY(hexagon, tileX, tileY))\r\n\r\n    if (hexagon.radius !== undefined) {\r\n        let radius = hexagon.radius;\r\n        let angleOffset = (hexagon.staggerAxis === StaggerAxis.flat) ? 0 : -30;\r\n        for (let i = 0; i < 6; i++) {\r\n            let angleDeg = (60 * i) + angleOffset;\r\n            let angleRad = DegToRad(angleDeg);\r\n            out[i].x = x + radius * Math.cos(angleRad);\r\n            out[i].y = y + radius * Math.sin(angleRad);\r\n        }\r\n\r\n    } else {\r\n        let halfW = hexagon._halfWidth;\r\n        let quarterW = halfW / 2;\r\n        let halfH = hexagon._halfHeight;\r\n        let quarterH = halfH / 2;\r\n        if (hexagon.staggerAxis === StaggerAxis.flat) {\r\n            out[0].x = x + halfW;\r\n            out[0].y = y;\r\n\r\n            out[1].x = x + quarterW;\r\n            out[1].y = y + halfH;\r\n\r\n            out[2].x = x - quarterW;\r\n            out[2].y = y + halfH;\r\n\r\n            out[3].x = x - halfW;\r\n            out[3].y = y;\r\n\r\n            out[4].x = x - quarterW;\r\n            out[4].y = y - halfH;\r\n\r\n            out[5].x = x + quarterW;\r\n            out[5].y = y - halfH;\r\n        } else { // StaggerAxis.pointy\r\n            out[0].x = x + halfW;\r\n            out[0].y = y - quarterH;\r\n\r\n            out[1].x = x + halfW;\r\n            out[1].y = y + quarterH;\r\n\r\n            out[2].x = x;\r\n            out[2].y = y + halfH;\r\n\r\n            out[3].x = x - halfW;\r\n            out[3].y = y + quarterH;\r\n\r\n            out[4].x = x - halfW;\r\n            out[4].y = y - quarterH;\r\n\r\n            out[5].x = x;\r\n            out[5].y = y - halfH;\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nlet globPoints: Vec2Type[] = []","type DeltaXYType = [number, number];\r\nexport type DirectionToDeltaXYEntryType = DeltaXYType[];\r\ntype ParityToDeltaXYType = DirectionToDeltaXYEntryType[];\r\ntype DirectionToDeltaTileXYType = ParityToDeltaXYType[];\r\n\r\nconst ODD_R: ParityToDeltaXYType = [\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1]\r\n    ],\r\n    [\r\n        [+1, 0],\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ]\r\n];\r\nconst EVEN_R: ParityToDeltaXYType = [\r\n    [\r\n        [+1, 0],\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ],\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1]\r\n    ]\r\n];\r\nconst ODD_Q: ParityToDeltaXYType = [\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ],\r\n    [\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, 0]\r\n    ]\r\n];\r\nconst EVEN_Q: ParityToDeltaXYType = [\r\n    [\r\n        [+1, +1],\r\n        [0, +1],\r\n        [-1, +1],\r\n        [-1, 0],\r\n        [0, -1],\r\n        [+1, 0]\r\n    ],\r\n    [\r\n        [+1, 0],\r\n        [0, +1],\r\n        [-1, 0],\r\n        [-1, -1],\r\n        [0, -1],\r\n        [+1, -1]\r\n    ]\r\n];\r\n\r\nexport let DirectionToDeltaTileXY: DirectionToDeltaTileXYType = [\r\n    ODD_R,\r\n    EVEN_R,\r\n    ODD_Q,\r\n    EVEN_Q\r\n];\r\n// DirectionToDeltaTileXYType[mode][parity][dir]: [x/y]","import {\r\n    DirectionToDeltaTileXY,\r\n    DirectionToDeltaXYEntryType\r\n} from './DirectionToDeltaTileXY';\r\n\r\ntype DeltaXYToDirectionEntryType = {\r\n    [x: number]: {\r\n        [y: number]: number\r\n    }\r\n}\r\n\r\nlet ReverseDirMap = function (\r\n    dirMap: DirectionToDeltaXYEntryType\r\n): DeltaXYToDirectionEntryType {\r\n\r\n    let out: DeltaXYToDirectionEntryType = {},\r\n        x: number, y: number;\r\n    for (let dir in dirMap) {\r\n        ([x, y] = dirMap[dir]);\r\n        if (!out.hasOwnProperty(x)) {\r\n            out[x] = {}\r\n        }\r\n        out[x][y] = parseInt(dir);\r\n    }\r\n    return out;\r\n}\r\n\r\ntype ParityToDirectionType = DeltaXYToDirectionEntryType[];\r\nexport type DeltaTileXYToDirectionType = ParityToDirectionType[];\r\nexport let DeltaTileXYToDirection: DeltaTileXYToDirectionType = [\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[0][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[0][1])\r\n    ],\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[1][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[1][1])\r\n    ],\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[2][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[2][1])\r\n    ],\r\n    [\r\n        ReverseDirMap(DirectionToDeltaTileXY[3][0]),\r\n        ReverseDirMap(DirectionToDeltaTileXY[3][1])\r\n    ]\r\n];\r\n// DeltaTileXYToDirection[mode][parity][x][y]: dir","import { LayoutMode } from './IHexagonBase'\r\n\r\nexport function GetParity(\r\n    mode: LayoutMode,\r\n    tileX: number,\r\n    tileY: number\r\n): number {\r\n\r\n    let parity;\r\n    switch (mode) {\r\n        case LayoutMode.ODD_R:\r\n        case LayoutMode.EVEN_R:\r\n            parity = tileY & 1;\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n        case LayoutMode.EVEN_Q:\r\n            parity = tileX & 1;\r\n            break;\r\n    }\r\n    return parity;\r\n}","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { DeltaTileXYToDirection } from './DeltaTileXYToDirection';\r\nimport { GetParity } from './GetParity';\r\n\r\nexport let GetNeighborTileDirection = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    neighborTileXY: Vec2Type\r\n): number | null {\r\n\r\n    let mode = hexagon.mode;\r\n    let parity = GetParity(mode, srcTileXY.x, srcTileXY.y);\r\n    let deltaTileXYToDirMap = DeltaTileXYToDirection[mode][parity];\r\n\r\n    let deltaTileX = neighborTileXY.x - srcTileXY.x;\r\n    let deltaTileY = neighborTileXY.y - srcTileXY.y;\r\n    if (deltaTileXYToDirMap.hasOwnProperty(deltaTileX)) {\r\n        let xEntry = deltaTileXYToDirMap[deltaTileX]\r\n        if (xEntry.hasOwnProperty(deltaTileY)) {\r\n            return xEntry[deltaTileY];\r\n        }\r\n    }\r\n    return null;\r\n}","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { DirectionToDeltaTileXY } from './DirectionToDeltaTileXY';\r\nimport { GetParity } from './GetParity';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nexport let GetTileXYAtDirection = function (\r\n    hexragon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    direction: number,\r\n    distance: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let mode = hexragon.mode;\r\n    let srcTileX = srcTileXY.x,\r\n        srcTileY = srcTileXY.y;\r\n\r\n    if (distance === 1) { // Neighbor\r\n        let parity = GetParity(mode, srcTileX, srcTileY);\r\n        out.x = srcTileX + DirectionToDeltaTileXY[mode][parity][direction][0];\r\n        out.y = srcTileY + DirectionToDeltaTileXY[mode][parity][direction][1];\r\n    } else if (distance === 0) {\r\n        out.x = srcTileX;\r\n        out.y = srcTileY;\r\n    } else {\r\n        let cubeXYZ = cr2cube(mode, srcTileX, srcTileY, true);\r\n        let newCubeX: number,\r\n            newCubeY: number,\r\n            newCubeZ: number;\r\n\r\n        switch (direction) {\r\n            case 1:\r\n                newCubeX = cubeXYZ.x;\r\n                newCubeY = cubeXYZ.y - distance;\r\n                newCubeZ = cubeXYZ.z + distance;\r\n                break;\r\n            case 2:\r\n                newCubeX = cubeXYZ.x - distance;\r\n                newCubeY = cubeXYZ.y;\r\n                newCubeZ = cubeXYZ.z + distance;\r\n                break;\r\n            case 3:\r\n                newCubeX = cubeXYZ.x - distance;\r\n                newCubeY = cubeXYZ.y + distance;\r\n                newCubeZ = cubeXYZ.z;\r\n                break;\r\n            case 4:\r\n                newCubeX = cubeXYZ.x;\r\n                newCubeY = cubeXYZ.y + distance;\r\n                newCubeZ = cubeXYZ.z - distance;\r\n                break;\r\n            case 5:\r\n                newCubeX = cubeXYZ.x + distance;\r\n                newCubeY = cubeXYZ.y;\r\n                newCubeZ = cubeXYZ.z - distance;\r\n                break;\r\n            default:\r\n                newCubeX = cubeXYZ.x + distance;\r\n                newCubeY = cubeXYZ.y - distance;\r\n                newCubeZ = cubeXYZ.z;\r\n                break;\r\n        }\r\n        cube2cr(mode, newCubeX, newCubeY, newCubeZ, out);\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };","import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { qr2cube, roundcube, cube2cr, CubeType } from './CubeTransfer';\r\n\r\nconst C_4div3 = (4 / 3);\r\nconst C_2div3 = (2 / 3);\r\n\r\nexport let GetTileXY = function (\r\n    hexagon: IHexagonBase,\r\n    worldX: number | Vec2Type,\r\n    worldY?: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (worldX) === 'object') {\r\n        worldY = worldX.y;\r\n        worldX = worldX.x;\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    worldX -= hexagon.x;\r\n    worldY -= hexagon.y;\r\n    let q: number,\r\n        r: number;\r\n\r\n    switch (hexagon.mode) {\r\n        case LayoutMode.ODD_R:\r\n        case LayoutMode.EVEN_R:\r\n            r = (worldY * C_4div3) / hexagon.height;\r\n            q = (worldX / hexagon.width) - C_2div3 * (worldY / hexagon.height);\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n        case LayoutMode.EVEN_Q:\r\n            r = (worldY / hexagon.height) - C_2div3 * (worldX / hexagon.width);\r\n            q = (worldX * C_4div3) / hexagon.width;\r\n            break;\r\n    }\r\n\r\n    let cube = qr2cube(q, r, globCube);\r\n    roundcube(cube);\r\n    cube2cr(hexagon.mode, cube.x, cube.y, cube.z, out);\r\n    return out;\r\n}\r\n\r\nlet globCube: CubeType = { x: 0, y: 0, z: 0 };\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };\r\n","import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport {\r\n    Vec2Type,\r\n    MirrorMode, MirrorModeString\r\n} from '../IGrid';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nexport let Mirror = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    mode: MirrorMode | MirrorModeString,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (typeof (mode) === 'string') {\r\n        mode = MirrorMode[mode];\r\n    }\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let cubeXYZ = cr2cube(hexagon.mode, srcTileXY.x, srcTileXY.y, true);\r\n    let isRMode = (hexagon.mode === LayoutMode.ODD_R) || (hexagon.mode === LayoutMode.EVEN_R);\r\n    let newCubeX: number,\r\n        newCubeY: number,\r\n        newCubeZ: number;\r\n\r\n    if (mode & 1) { // Mirror x\r\n        if (isRMode) {\r\n            newCubeX = cubeXYZ.y;\r\n            newCubeY = cubeXYZ.x;\r\n            newCubeZ = cubeXYZ.z;\r\n        } else {\r\n            newCubeX = -cubeXYZ.x;\r\n            newCubeY = -cubeXYZ.z;\r\n            newCubeZ = -cubeXYZ.y;\r\n        }\r\n        cubeXYZ.x = newCubeX;\r\n        cubeXYZ.y = newCubeY;\r\n        cubeXYZ.z = newCubeZ;\r\n    }\r\n    if (mode & 2) { // Mirror y\r\n        if (isRMode) {\r\n            newCubeX = -cubeXYZ.y;\r\n            newCubeY = -cubeXYZ.x;\r\n            newCubeZ = -cubeXYZ.z;\r\n        } else {\r\n            newCubeX = cubeXYZ.x;\r\n            newCubeY = cubeXYZ.z;\r\n            newCubeZ = cubeXYZ.y;\r\n        }\r\n    }\r\n    cube2cr(hexagon.mode, newCubeX, newCubeY, newCubeZ, out);\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };\r\n\r\nexport default Mirror;","import { IHexagonBase, LayoutMode } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let Offset = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    let newX = srcTileXY.x + offsetX;\r\n    let newY = srcTileXY.y + offsetY;\r\n    switch (hexagon.mode) {\r\n        case LayoutMode.ODD_R:\r\n            if ((offsetY & 1) !== 0) {\r\n                if ((newY & 1) === 0) {\r\n                    newX += 1;\r\n                }\r\n            }\r\n            break;\r\n\r\n        case LayoutMode.EVEN_R:\r\n            if ((offsetY & 1) !== 0) {\r\n                if ((newY & 1) === 0) {\r\n                    newX -= 1;\r\n                }\r\n            }\r\n            break;\r\n\r\n        case LayoutMode.ODD_Q:\r\n            if ((offsetX & 1) !== 0) {\r\n                if ((newX & 1) == 0) {\r\n                    newY += 1;\r\n                }\r\n            }\r\n            break;\r\n        case LayoutMode.EVEN_Q:\r\n            if ((offsetX & 1) !== 0) {\r\n                if ((newX & 1) == 0) {\r\n                    newY -= 1;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    out.x = newX;\r\n    out.y = newY;\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nimport { Wrap } from '../../../utils/math/Wrap';\r\n\r\nexport let Rotate = function (\r\n    hexagon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    dir: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    if (out === true) {\r\n        out = globTileXY;\r\n    }\r\n\r\n    dir = Wrap(dir, 0, 5);\r\n    let cubeXYZ = cr2cube(hexagon.mode, srcTileXY.x, srcTileXY.y, true);\r\n    let newCubeX: number,\r\n        newCubeY: number,\r\n        newCubeZ: number;\r\n\r\n    switch (dir) {\r\n        case 1:\r\n            newCubeX = -cubeXYZ.z;\r\n            newCubeY = -cubeXYZ.x;\r\n            newCubeZ = -cubeXYZ.y;\r\n            break;\r\n        case 2:\r\n            newCubeX = cubeXYZ.y;\r\n            newCubeY = cubeXYZ.z;\r\n            newCubeZ = cubeXYZ.x;\r\n            break;\r\n        case 3:\r\n            newCubeX = -cubeXYZ.x;\r\n            newCubeY = -cubeXYZ.y;\r\n            newCubeZ = -cubeXYZ.z;\r\n            break;\r\n        case 4:\r\n            newCubeX = cubeXYZ.z;\r\n            newCubeY = cubeXYZ.x;\r\n            newCubeZ = cubeXYZ.y;\r\n            break;\r\n        case 5:\r\n            newCubeX = -cubeXYZ.y;\r\n            newCubeY = -cubeXYZ.z;\r\n            newCubeZ = -cubeXYZ.x;\r\n            break;\r\n        default:\r\n            newCubeX = cubeXYZ.x;\r\n            newCubeY = cubeXYZ.y;\r\n            newCubeZ = cubeXYZ.z;\r\n            break;\r\n    }\r\n\r\n    cube2cr(hexagon.mode, newCubeX, newCubeY, newCubeZ, out);\r\n    return out;\r\n}\r\n\r\nlet globTileXY: Vec2Type = { x: 0, y: 0 };","import { IGrid, Vec2Type } from '../IGrid';\r\nimport { HexagonBase } from './HexagonBase';\r\n\r\nimport { DirectionBetween } from './DirectionBetween';\r\nimport { DirectionNormalize } from '../utils/DirectionNormalize';\r\nimport { GetDistance } from './GetDistance';\r\nimport { GetGridPoints } from './GetGridPoints';\r\nimport { GetNeighborTileDirection } from './GetNeighborTileDirection';\r\nimport { GetNeighborTileXY } from './GetNeighborTileXY';\r\nimport { GetOppositeDirection } from './GetOppositeDirection';\r\nimport { GetTileXY } from './GetTileXY';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\nimport { GetWorldXY } from './GetWorldXY';\r\nimport { MirrorMode, MirrorModeString } from '../IGrid';\r\nimport { Mirror } from './Mirror';\r\nimport { Offset } from './Offset';\r\nimport { RingToTileXYArray } from './RingToTileXYArray';\r\nimport { Rotate } from './Rotate';\r\nimport { SaveOrigin, RestoreOrigin } from '../utils/SaveOrigin';\r\n\r\nexport class Hexagon extends HexagonBase implements IGrid {\r\n\r\n    _savedOriginX: number;\r\n    _savedOriginY: number;\r\n\r\n    get sides() {\r\n        return 6;\r\n    }\r\n\r\n    // Direction of neighbors\r\n    get allDirections() {\r\n        return ALLDIR;\r\n    }\r\n\r\n    // Board-match\r\n    get halfDirections() {\r\n        return HALFDIR;\r\n    }\r\n\r\n    directionBetween(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        round: boolean = true\r\n    ): number {\r\n\r\n        return DirectionBetween(this, tileA, tileB, round);\r\n    }\r\n\r\n    directionNormalize(\r\n        direction: number\r\n    ): number {\r\n\r\n        return DirectionNormalize(this, direction);\r\n    }\r\n\r\n    getDistance(\r\n        tileA: Vec2Type,\r\n        tileB: Vec2Type,\r\n        roughMode: boolean = false\r\n    ): number {\r\n\r\n        return GetDistance(this, tileA, tileB, roughMode);\r\n    }\r\n\r\n    getGridPoints(\r\n        tileX: number | Vec2Type = 0,\r\n        tileY: number = 0,\r\n        out: Vec2Type[] | true = []\r\n    ): Vec2Type[] {\r\n\r\n        return GetGridPoints(this, tileX, tileY, out);\r\n    }\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: Vec2Type,\r\n        neighborTileXY: Vec2Type\r\n    ): number | null {\r\n\r\n        return GetNeighborTileDirection(this, srcTileXY, neighborTileXY);\r\n    }\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetNeighborTileXY(this, srcTileXY, direction, out);\r\n    }\r\n\r\n    getOppositeDirection(\r\n        tileX: number | Vec2Type,\r\n        tileY: number | undefined | null,\r\n        direction: number\r\n    ): number {\r\n\r\n        return GetOppositeDirection(this, tileX, tileY, direction);\r\n    }\r\n\r\n    getTileXY(\r\n        worldX: number | Vec2Type,\r\n        worldY?: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetTileXY(this, worldX, worldY, out);\r\n    }\r\n\r\n    getTileXYAtDirection(\r\n        srcTileXY: Vec2Type,\r\n        direction: number,\r\n        distance: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetTileXYAtDirection(this, srcTileXY, direction, distance, out);\r\n    }\r\n\r\n    getWorldXY(\r\n        tileX: number | Vec2Type,\r\n        tileY?: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return GetWorldXY(this, tileX, tileY, out);\r\n    }\r\n\r\n    mirror(\r\n        srcTileXY: Vec2Type,\r\n        mode: MirrorMode | MirrorModeString,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Mirror(this, srcTileXY, mode, out);\r\n    }\r\n\r\n    offset(\r\n        srcTileXY: Vec2Type,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Offset(this, srcTileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: Vec2Type,\r\n        radius: number,\r\n        out: Vec2Type[] = []\r\n    ): Vec2Type[] {\r\n\r\n        return RingToTileXYArray(this, centerTileXY, radius, out);\r\n    }\r\n\r\n    rotate(srcTileXY: Vec2Type,\r\n        dir: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return Rotate(this, srcTileXY, dir, out);\r\n    }\r\n\r\n    restoreOrigin(): this {\r\n\r\n        RestoreOrigin(this);\r\n        return this\r\n    }\r\n\r\n    saveOrigin(): this {\r\n\r\n        SaveOrigin(this);\r\n        return this;\r\n    }\r\n}\r\n\r\nconst ALLDIR = [0, 1, 2, 3, 4, 5];\r\nconst HALFDIR = [0, 1, 2];","import { IGrid } from '../IGrid';\r\nimport { Wrap } from '../../../utils/math/Wrap.js';\r\n\r\nexport let DirectionNormalize = function (\r\n    grid: IGrid,\r\n    direction: number\r\n): number {\r\n\r\n    return Wrap(direction, 0, grid.directions);\r\n}","import { Vec2Type } from '../IGrid';\r\n\r\nexport let FillPositionArray = function (\r\n    length: number,\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    if (out.length === length) {\r\n        // Do nothing\r\n    } else if (out.length < length) {\r\n        for (let i = out.length; i < length; i++) {\r\n            out.push({ x: 0, y: 0 });\r\n        }\r\n    } else { // out.length < length\r\n        out.length = length;\r\n    }\r\n\r\n    return out;\r\n}","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { GetTileXYAtDirection } from './GetTileXYAtDirection';\r\n\r\nexport let GetNeighborTileXY = function (\r\n    hexragon: IHexagonBase,\r\n    srcTileXY: Vec2Type,\r\n    direction: number,\r\n    out: Vec2Type | true = { x: 0, y: 0 }\r\n): Vec2Type {\r\n\r\n    return GetTileXYAtDirection(hexragon, srcTileXY, direction, 1, out);\r\n};","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\n\r\nexport let GetOppositeDirection = function (\r\n    hexagon: IHexagonBase,\r\n    tileX: number | Vec2Type,\r\n    tileY: number | undefined | null,\r\n    direction\r\n): number {\r\n\r\n    return (direction + 3) % 6;\r\n};","import { IHexagonBase } from './IHexagonBase';\r\nimport { Vec2Type } from '../IGrid';\r\nimport { cr2cube, cube2cr } from './CubeTransfer';\r\n\r\nexport let RingToTileXYArray = function (\r\n    hexagon: IHexagonBase,\r\n    centerTileXY: Vec2Type,\r\n    radius: number,\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    let centerCube = cr2cube(hexagon.mode, centerTileXY.x, centerTileXY.y, true);\r\n    let cx = centerCube.x,\r\n        cy = centerCube.y,\r\n        cz = centerCube.z;\r\n    let i: number,\r\n        j: number,\r\n        k: number;\r\n\r\n    k = radius;\r\n    for (i = 0; i >= -radius; i--) {\r\n        j = -i - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    i = -radius;\r\n    for (j = 1; j <= radius; j++) {\r\n        k = -i - j;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    j = radius;\r\n    for (k = -1; k >= -radius; k--) {\r\n        i = -j - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    k = -radius;\r\n    for (i = 1; i <= radius; i++) {\r\n        j = -i - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    i = radius;\r\n    for (j = -1; j >= -radius; j--) {\r\n        k = -i - j;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n\r\n    j = -radius;\r\n    for (k = 1; k <= radius - 1; k++) {\r\n        i = -j - k;\r\n        out.push(cube2cr(hexagon.mode, cx + i, cy + j, cz + k));\r\n    }\r\n    return out;\r\n}","import { IGrid } from '../IGrid';\r\n\r\nexport let SaveOrigin = function (\r\n    grid: IGrid\r\n): void {\r\n    grid._savedOriginX = grid.x;\r\n    grid._savedOriginY = grid.y;\r\n}\r\n\r\nexport let RestoreOrigin = function (\r\n    grid: IGrid\r\n): void {\r\n    grid.x = grid._savedOriginX;\r\n    grid.y = grid._savedOriginY;\r\n}","export enum PathMode {\r\n    'random' = 0,\r\n    'diagonal' = 1,\r\n    'straight' = 2,\r\n    'line' = 3,\r\n    'astar' = 10,\r\n    'astar-random' = 11,\r\n    'astar-line' = 12\r\n}\r\n\r\nexport type PathModeString = 'random' | 'diagonal' | 'straight' | 'line' |\r\n    'astar' | 'astar-line' | 'astar-random';\r\n\r\nexport let IsAStarMode = function (pathMode: PathMode) {\r\n    return (pathMode === PathMode.astar) ||\r\n        (pathMode === PathMode['astar-line']) ||\r\n        (pathMode === PathMode['astar-random']);\r\n}","import { CreateNodeCallbackType } from './types/CreateNodeCallbackType';\r\nimport { INodeBase } from './INodeBase';\r\nimport { Stack } from '../../utils/struct/Stack';\r\n\r\nexport class NodeManager {\r\n    createNodeCallback: CreateNodeCallbackType;\r\n    weight: number;\r\n    nodePool: Stack;\r\n    nodes: Map<any, INodeBase>;\r\n    sn: number;\r\n    closestNode: INodeBase | null;\r\n\r\n    constructor(\r\n        createNodeCallback: CreateNodeCallbackType\r\n    ) {\r\n        this.createNodeCallback = createNodeCallback;\r\n        this.nodePool = new Stack();\r\n        this.nodes = new Map();\r\n        this.sn = 0;\r\n    }\r\n\r\n    getNode(\r\n        key: any,\r\n        createNode: boolean = false\r\n    ): INodeBase | null {\r\n\r\n        if (!this.nodes.has(key)) {\r\n            if (!createNode) {\r\n                return null;\r\n            }\r\n\r\n            let node: INodeBase = this.nodePool.pop();\r\n            if (node === null) {\r\n                node = this.createNodeCallback();\r\n                node.manager = this;\r\n            }\r\n            node.sn = this.sn;\r\n            node.reset(key);\r\n            this.nodes.set(key, node);\r\n        }\r\n        this.sn++;\r\n        let node = this.nodes.get(key);\r\n        node.sn = this.sn;\r\n        return node;\r\n    }\r\n\r\n    freeAllNodes(): this {\r\n\r\n        let pool = this.nodePool;\r\n        for (const [key, node] of this.nodes) {\r\n            node.shutdown();\r\n            pool.push(node);\r\n        }\r\n        this.nodes.clear();\r\n        this.sn = 0;\r\n        return this;\r\n    }\r\n\r\n    getAllNodes(): Map<any, INodeBase> {\r\n\r\n        return this.nodes;\r\n    }\r\n}","/* \r\n\r\njavascript-astar 0.3.0\r\nhttp://github.com/bgrins/javascript-astar\r\nFreely distributable under the MIT License.\r\nImplements the astar search algorithm in javascript using a Binary Heap.\r\nIncludes Binary Heap (with modifications) from Marijn Haverbeke.\r\nhttp://eloquentjavascript.net/appendix2.html\r\n\r\n*/\r\n\r\nimport { IAStar } from './IAstar';\r\nimport { PathMode, IsAStarMode } from './types/PathMode';\r\nimport { CostValueType } from './types/CostValueType';\r\nimport { BLOCKER, INFINITY } from './Const';\r\nimport { INodeBase } from './INodeBase';\r\nimport { BinaryHeap } from '../struct/BinaryHeap';\r\n\r\nlet gOpenHeap = new BinaryHeap((node: INodeBase) => node.f);\r\n\r\nexport let Search = function (\r\n    astar: IAStar,\r\n    startNodeKey: any,\r\n    endNodeKey: any,\r\n    movingPoints?: number\r\n): void {\r\n\r\n    const isPathSearch = (endNodeKey !== null);\r\n    const isAStartMode = IsAStarMode(astar.pathMode);\r\n    const isShortestPathMode = isPathSearch && (!isAStartMode);\r\n    const astarMode = (isPathSearch && isAStartMode) ? astar.pathMode : null;\r\n\r\n    let nodeManager = astar.nodeManager;\r\n    nodeManager.freeAllNodes();\r\n\r\n    let startNode = nodeManager.getNode(startNodeKey, true);\r\n    let endNode = (isPathSearch) ? nodeManager.getNode(endNodeKey, true) : null;\r\n    startNode.h = startNode.heuristic(endNode, astarMode);\r\n\r\n    let closestNode: INodeBase = null;\r\n    if (isPathSearch) {\r\n        closestNode = startNode;\r\n        closestNode.closerH = closestNode.h || closestNode.heuristic(endNode, PathMode.astar);\r\n    }\r\n\r\n    gOpenHeap.push(startNode);\r\n    while (gOpenHeap.size > 0) {\r\n        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\r\n        let currNode = gOpenHeap.pop() as INodeBase;\r\n        // console.log(currNode.key);\r\n\r\n        // End case -- result has been found, return the traced path.\r\n        if (isPathSearch && (currNode === endNode)) {\r\n            closestNode = endNode;\r\n            break;\r\n        }\r\n\r\n        // Normal case -- move currNode from open to closed, process each of its next-nodes.\r\n        currNode.closed = true;\r\n\r\n        // Find all next-nodes for the current node.\r\n        let nextNodes: INodeBase[] = currNode.getNextNodes();\r\n        let nextNode: INodeBase,\r\n            nextNodeCost: CostValueType;\r\n        for (let i = 0, cnt = nextNodes.length; i < cnt; ++i) {\r\n            nextNode = nextNodes[i];\r\n            nextNodeCost = nextNode.getCost(currNode);\r\n            if (nextNode.closed || (nextNodeCost === BLOCKER)) {\r\n                // Not a valid node to process, skip to next-node.\r\n                continue;\r\n            }\r\n\r\n            // The g score is the shortest distance from start to current node.\r\n            // We need to check if the path we have arrived at this next-node is the shortest one we have seen yet.\r\n            let gScore = currNode.g + nextNodeCost,\r\n                beenVisited = nextNode.visited;\r\n\r\n            if ((movingPoints !== INFINITY) && (gScore > movingPoints)) {\r\n                continue;\r\n            }\r\n\r\n            if ((!beenVisited) || (gScore < nextNode.g)) {\r\n\r\n                // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\r\n                nextNode.visited = true;\r\n                nextNode.prevNodes.length = 0;\r\n                nextNode.prevNodes.push(currNode);\r\n                if (nextNode.h === undefined) {\r\n                    nextNode.h = nextNode.heuristic(endNode, astarMode, startNode);\r\n                }\r\n                nextNode.g = gScore;\r\n                nextNode.f = nextNode.g + nextNode.h;\r\n\r\n                // Nearest node\r\n                if (isPathSearch) {\r\n                    // If the next node is closer than the current closestNode or if it's equally close but has\r\n                    // a cheaper path than the current closest node then it becomes the closest node\r\n                    if (nextNode.closerH === undefined) {\r\n                        nextNode.closerH = nextNode.h || nextNode.heuristic(endNode, PathMode.astar);\r\n                    }\r\n                    if ((nextNode.closerH < closestNode.closerH) ||\r\n                        ((nextNode.closerH === closestNode.closerH) && (nextNode.g < closestNode.g))) {\r\n                        closestNode = nextNode;\r\n                    }\r\n                }\r\n                // Nearest node\r\n\r\n                if (!beenVisited) {\r\n                    // Pushing to heap will put it in proper place based on the 'f' value.\r\n                    gOpenHeap.push(nextNode);\r\n                } else {\r\n                    // Already seen the node, but since it has been rescored we need to reorder it in the heap\r\n                    gOpenHeap.rescoreElement(nextNode);\r\n                }\r\n            } else if (isShortestPathMode && (gScore == nextNode.g)) {\r\n\r\n                nextNode.prevNodes.push(currNode);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    nodeManager.closestNode = closestNode;\r\n    gOpenHeap.clear();\r\n}","export class BinaryHeap {\r\n    content: object[];\r\n    scoreFunction: (node: object) => number;\r\n\r\n    constructor(scoreFunction) {\r\n        this.content = [];\r\n        this.scoreFunction = scoreFunction;\r\n    }\r\n\r\n    clear(): void {\r\n        this.content.length = 0;\r\n    }\r\n\r\n    push(element: object): void {\r\n        // Add the new element to the end of the array.\r\n        this.content.push(element);\r\n\r\n        // Allow it to sink down.\r\n        this.sinkDown(this.content.length - 1);\r\n    }\r\n\r\n    pop(): object {\r\n        // Store the first element so we can return it later.\r\n        let result = this.content[0];\r\n        // Get the element at the end of the array.\r\n        let end = this.content.pop();\r\n        // If there are any elements left, put the end element at the\r\n        // start, and let it bubble up.\r\n        if (this.content.length > 0) {\r\n            this.content[0] = end;\r\n            this.bubbleUp(0);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    remove(node: object) {\r\n\r\n        let i = this.content.indexOf(node);\r\n\r\n        // When it is found, the process seen in 'pop' is repeated\r\n        // to fill up the hole.\r\n        let end = this.content.pop();\r\n\r\n        if (i !== this.content.length - 1) {\r\n            this.content[i] = end;\r\n\r\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n                this.sinkDown(i);\r\n            } else {\r\n                this.bubbleUp(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    get size(): number {\r\n        return this.content.length;\r\n    }\r\n\r\n    rescoreElement(node: object) {\r\n\r\n        this.sinkDown(this.content.indexOf(node));\r\n    }\r\n\r\n    sinkDown(n: number): void {\r\n\r\n        // Fetch the element that has to be sunk.\r\n        let element = this.content[n];\r\n\r\n        // When at 0, an element can not sink any further.\r\n        while (n > 0) {\r\n\r\n            // Compute the parent element's index, and fetch it.\r\n            let parentN = ((n + 1) >> 1) - 1,\r\n                parent = this.content[parentN];\r\n            // Swap the elements if the parent is greater.\r\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n                this.content[parentN] = element;\r\n                this.content[n] = parent;\r\n                // Update 'n' to continue at the new position.\r\n                n = parentN;\r\n            }\r\n            // Found a parent that is less, no need to sink any further.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    bubbleUp(n: number): void {\r\n\r\n        // Look up the target element and its score.\r\n        let length = this.content.length,\r\n            element: object = this.content[n],\r\n            elemScore: number = this.scoreFunction(element);\r\n\r\n        while (true) {\r\n            // Compute the indices of the child elements.\r\n            let child2N = (n + 1) << 1,\r\n                child1N = child2N - 1;\r\n            // This is used to store the new position of the element, if any.\r\n            let swap: number = null,\r\n                child1Score: number;\r\n            // If the first child exists (is inside the array)...\r\n            if (child1N < length) {\r\n                // Look it up and compute its score.\r\n                let child1 = this.content[child1N];\r\n                child1Score = this.scoreFunction(child1);\r\n\r\n                // If the score is less than our element's, we need to swap.\r\n                if (child1Score < elemScore) {\r\n                    swap = child1N;\r\n                }\r\n            }\r\n\r\n            // Do the same checks for the other child.\r\n            if (child2N < length) {\r\n                let child2 = this.content[child2N],\r\n                    child2Score = this.scoreFunction(child2);\r\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\r\n                    swap = child2N;\r\n                }\r\n            }\r\n\r\n            // If the element needs to be moved, swap it, and continue.\r\n            if (swap !== null) {\r\n                this.content[n] = this.content[swap];\r\n                this.content[swap] = element;\r\n                n = swap;\r\n            }\r\n            // Otherwise, we are done.\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}","export const BLOCKER = null;\r\nexport const INFINITY = undefined;","import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\n\r\nexport let GetAStarNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        currNode = currNode.prevNodes[0];\r\n    }\r\n\r\n    return out.reverse();\r\n}","import { IAStar } from '../IAStar';\r\nimport { INodeBase } from '../INodeBase';\r\nimport { PathMode } from '../types/PathMode';\r\nimport { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { GetAStarNodePath } from './GetAStarNodePath';\r\nimport { GetRandomNodePath } from './GetRandomNodePath';\r\nimport { GetLineNodePath } from './GetLineNodePath';\r\nimport { GetDiagonalPath } from './GetDiagonalPath';\r\nimport { GetStraightNodePath } from './GetStraightNodePath';\r\n\r\nexport let GetNodePath = function (\r\n    astar: IAStar,\r\n    startNodeKey: any,\r\n    endNodeKey: any\r\n): INodeBase[] {\r\n\r\n    let nodeManager = astar.nodeManager;\r\n    let endNode = nodeManager.getNode(endNodeKey);\r\n    let path: INodeBase[] = [];\r\n    if (endNode === null) {\r\n        return path;\r\n    }\r\n\r\n    let startNode = nodeManager.getNode(startNodeKey);\r\n    return GetNodePathCallbacks[astar.pathMode](startNode, endNode, path);\r\n}\r\n\r\nlet GetNodePathCallbacks: { [mode: number]: GetNodePathCallbackType } = {};\r\nGetNodePathCallbacks[PathMode.astar] = GetAStarNodePath;\r\nGetNodePathCallbacks[PathMode['astar-line']] = GetAStarNodePath;\r\nGetNodePathCallbacks[PathMode['astar-random']] = GetAStarNodePath;\r\nGetNodePathCallbacks[PathMode.random] = GetRandomNodePath;\r\nGetNodePathCallbacks[PathMode.line] = GetLineNodePath;\r\nGetNodePathCallbacks[PathMode.diagonal] = GetDiagonalPath;\r\nGetNodePathCallbacks[PathMode.straight] = GetStraightNodePath;","import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { GetRandomItem } from '../../array/GetRandom';\r\n\r\nexport let GetRandomNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if (currNode.prevNodes.length === 1) {\r\n            currNode = currNode.prevNodes[0];\r\n        } else {\r\n            currNode = GetRandomItem(currNode.prevNodes);\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}","import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\n\r\nexport let GetLineNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    let targetAngle = endNode.angleTo(startNode);\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if (currNode.prevNodes.length === 1) {\r\n            currNode = currNode.prevNodes[0];\r\n        } else {\r\n            let minDeltaAngle = Infinity;\r\n            for (let i = 1, cnt = currNode.prevNodes.length; i < cnt; i++) {\r\n                let prevNode = currNode.prevNodes[i];\r\n                let deltaAngle = Math.abs(endNode.angleTo(prevNode) - targetAngle);\r\n                if (deltaAngle < minDeltaAngle) {\r\n                    minDeltaAngle = deltaAngle;\r\n                    currNode = prevNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}","import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { INodeBase } from '../INodeBase';\r\n\r\nexport let GetDiagonalPath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    let currLogicDir: number;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if ((currNode.prevNodes.length === 1) || (currLogicDir === undefined)) {\r\n            let prevNode = currNode.prevNodes[0];\r\n            currLogicDir = prevNode.logicDirTo(currNode);\r\n            currNode = prevNode;\r\n        } else {\r\n            let prevNode: INodeBase;\r\n            let prevLogicDir: number;\r\n            for (let i = 0, cnt = currNode.prevNodes.length; i < cnt; i++) {\r\n                prevNode = currNode.prevNodes[i];\r\n                prevLogicDir = prevNode.logicDirTo(currNode);\r\n                if (prevLogicDir !== currLogicDir) {\r\n                    break;\r\n                }\r\n            }\r\n            currLogicDir = prevLogicDir;\r\n            currNode = prevNode;\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}","import { GetNodePathCallbackType } from './GetNodePathCallbackType';\r\nimport { INodeBase } from '../INodeBase';\r\n\r\nexport let GetStraightNodePath: GetNodePathCallbackType = function (\r\n    startNode,\r\n    endNode,\r\n    out = []\r\n) {\r\n\r\n    let currNode = endNode;\r\n    let currLogicDir: number;\r\n    while (currNode.prevNodes.length > 0) {\r\n        out.push(currNode);\r\n        if ((currNode.prevNodes.length === 1) || (currLogicDir === undefined)) {\r\n            let prevNode = currNode.prevNodes[0];\r\n            currLogicDir = prevNode.logicDirTo(currNode);\r\n            currNode = prevNode;\r\n        } else {\r\n            let prevNode: INodeBase;\r\n            let prevLogicDir: number;\r\n            for (let i = 0, cnt = currNode.prevNodes.length; i < cnt; i++) {\r\n                prevNode = currNode.prevNodes[i];\r\n                prevLogicDir = prevNode.logicDirTo(currNode);\r\n                if (prevLogicDir === currLogicDir) {\r\n                    break;\r\n                }\r\n            }\r\n            currLogicDir = prevLogicDir;\r\n            currNode = prevNode;\r\n        }\r\n    }\r\n\r\n    return out.reverse();\r\n}","import {\r\n    PathMode, PathModeString,\r\n    CreateNodeCallbackType\r\n} from './IAStar';\r\n\r\nimport { INodeBase } from './INodeBase';\r\nimport { INodeManager } from './INodeManager';\r\nimport { NodeManager } from './NodeManager';\r\nimport { Search } from './Search';\r\nimport { GetNodePath } from './getnodepath/GetNodePath';\r\n\r\nexport class AStar {\r\n    pathMode: PathMode;\r\n    nodeManager: INodeManager;\r\n\r\n    constructor(\r\n        createNodeCallback: CreateNodeCallbackType\r\n    ) {\r\n\r\n        this.nodeManager = new NodeManager(createNodeCallback);\r\n    }\r\n\r\n    setPathMode(\r\n        mode: PathMode | PathModeString\r\n    ): this {\r\n\r\n        if (typeof (mode) === 'string') {\r\n            mode = PathMode[mode];\r\n        }\r\n        this.pathMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setWeight(\r\n        weight: number\r\n    ): this {\r\n\r\n        this.nodeManager.weight = weight;\r\n        return this;\r\n    }\r\n\r\n    search(\r\n        startNodeKey: any,\r\n        endNodeKey: any,\r\n        movingPoints?: number\r\n    ): this {\r\n\r\n        Search(this, startNodeKey, endNodeKey, movingPoints);\r\n        return this;\r\n    }\r\n\r\n    getAllNodes(): Map<any, INodeBase> {\r\n\r\n        return this.nodeManager.getAllNodes();\r\n    }\r\n\r\n    getNode(key: any): INodeBase {\r\n\r\n        return this.nodeManager.getNode(key);\r\n    }\r\n\r\n    getClosestNode(): INodeBase | null {\r\n\r\n        return this.nodeManager.closestNode;\r\n    }\r\n\r\n    getNodePath(\r\n        startNodeKey: any,\r\n        endNodeKey: any\r\n    ): INodeBase[] {\r\n\r\n        return GetNodePath(this, startNodeKey, endNodeKey);\r\n    }\r\n}","export let Shuffle = function (array: any[]) {\r\n\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        let j = Math.floor(Math.random() * (i + 1));\r\n        let temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n\r\n    return array;\r\n};\r\n","import { Vec2Type } from '../../../utils/types/VectorType';\r\n\r\nexport let XYToKey = function (x: number, y: number) {\r\n    return `${x}|${y}`;\r\n}\r\n\r\nexport let KeyToXY = function (key: string,\r\n    out?: Vec2Type\r\n): Vec2Type {\r\n\r\n    let xy = key.split('|');\r\n    if (out === undefined) {\r\n        out = globXY;\r\n    }\r\n    out.x = parseInt(xy[0]);\r\n    out.y = parseInt(xy[1]);\r\n    return out;\r\n}\r\n\r\nlet globXY: Vec2Type = { x: 0, y: 0 }","import { IAStarNode } from './IAStarNode';\r\nimport { PathMode, CostValueType } from '../../../utils/astar/IAstar';\r\nimport { NodeBase } from '../../../utils/astar/NodeBase';\r\nimport { IPathFinder } from '../IPathFinder';\r\nimport { Shuffle } from '../../../utils/array/Shuffle';\r\nimport { XYZType } from '../../board/ILogicBoard';\r\nimport { XYToKey, KeyToXY } from './Key';\r\nimport { Between as AngleBetween } from '../../../utils/math/angle/Between';\r\n\r\nexport class AStarNode extends NodeBase {\r\n    pathFinder: IPathFinder;\r\n    isTileXYZ = true;\r\n\r\n    x: number;\r\n    y: number;\r\n    cost: number;\r\n    _px: number; // For worldX\r\n    _py: number; // For worldY\r\n\r\n    constructor(pathFinder: IPathFinder) {\r\n\r\n        super();\r\n        this.pathFinder = pathFinder;\r\n    }\r\n\r\n    reset(\r\n        key: string\r\n    ) {\r\n\r\n        super.reset(key);\r\n\r\n        this.key = key;\r\n        KeyToXY(key, this);\r\n        this._px = undefined;\r\n        this._py = undefined;\r\n        this.cost = undefined; // cost cache\r\n    }\r\n\r\n    getNextNodes(\r\n\r\n    ): IAStarNode[] {\r\n\r\n        let neighborsTileXY = this.board.getNeighborTileXY(this) as XYZType[];\r\n        if (this.pathFinder.shuffleNeighbors) {\r\n            Shuffle(neighborsTileXY);\r\n        }\r\n\r\n        let neighborNodes = [];\r\n        neighborsTileXY.forEach((tileXY) => {\r\n            let node = this.getNode(XYToKey(tileXY.x, tileXY.y), true);\r\n            neighborNodes.push(node);\r\n        })\r\n        return neighborNodes;\r\n    }\r\n\r\n    getCost(\r\n        preNode: IAStarNode\r\n    ): CostValueType {\r\n\r\n        if (this.pathFinder.cacheCost) {\r\n            if (this.cost === undefined) {\r\n                this.cost = this.pathFinder.getCost(this, preNode);\r\n            }\r\n        } else {\r\n            this.cost = this.pathFinder.getCost(this, preNode);\r\n        }\r\n        return this.cost;\r\n    }\r\n\r\n    distanceTo(\r\n        node: IAStarNode\r\n    ): number {\r\n\r\n        return this.board.getDistance(this, node, true);\r\n    }\r\n\r\n    angleTo(\r\n        node: IAStarNode\r\n    ): number {\r\n\r\n        return AngleBetween(this.worldX, this.wroldY, node.worldX, node.worldX);\r\n    }\r\n\r\n    logicDirTo(\r\n        node: IAStarNode\r\n    ): number {\r\n\r\n        return this.board.getNeighborTileDirection(this, node);\r\n    }\r\n\r\n    get board() {\r\n\r\n        return this.pathFinder.board;\r\n    }\r\n\r\n    get worldX() {\r\n        if (this._px === undefined) {\r\n            let worldXY = this.board.tileXYToWorldXY(this.x, this.y, true);\r\n            this._px = worldXY.x;\r\n            this._py = worldXY.y;\r\n        }\r\n        return this._px;\r\n    }\r\n\r\n    get wroldY() {\r\n        if (this._py === undefined) {\r\n            let worldXY = this.board.tileXYToWorldXY(this.x, this.y, true);\r\n            this._px = worldXY.x;\r\n            this._py = worldXY.y;\r\n        }\r\n        return this._py;\r\n    }\r\n}","import { PathMode } from './types/PathMode';\r\nimport { CostValueType } from './types/CostValueType';\r\nimport { BLOCKER } from './Const';\r\nimport { INodeBase } from './INodeBase';\r\nimport { INodeManager } from './INodeManager';\r\n\r\nexport abstract class NodeBase {\r\n    manager: INodeManager;\r\n\r\n    f: number;\r\n    g: number;\r\n    h: number;\r\n    closerH: number;\r\n\r\n    visited: boolean;\r\n    closed: boolean;\r\n\r\n    prevNodes: INodeBase[];\r\n    key: any; // string, number or an object\r\n    sn: number; // For sorting by created order\r\n\r\n    constructor() {\r\n\r\n        this.prevNodes = [];\r\n    }\r\n\r\n    shutdown(): void {\r\n        this.key = undefined;\r\n        this.prevNodes.length = 0;\r\n    }\r\n\r\n    destroy(): void {\r\n        this.shutdown();\r\n    }\r\n\r\n    // Override\r\n    reset(key: any): void {\r\n        this.key = key;\r\n        this.f = 0;\r\n        this.g = 0; // path cost\r\n        this.h = undefined;\r\n        this.closerH = undefined;\r\n        this.visited = false;\r\n        this.closed = false;\r\n    }\r\n\r\n    heuristic(\r\n        endNode: INodeBase,\r\n        astarMode: PathMode | null,\r\n        baseNode?: INodeBase,\r\n    ): number {\r\n\r\n        if (astarMode === null) {\r\n            return 0;\r\n        }\r\n\r\n        let h: number;\r\n        let dist = this.distanceTo(endNode) * this.manager.weight;\r\n\r\n        switch (astarMode) {\r\n            case PathMode.astar:\r\n                h = dist;\r\n                break;\r\n            case PathMode['astar-line']:\r\n                if (baseNode !== undefined) {\r\n                    let deltaAngle = endNode.angleTo(baseNode) - this.angleTo(baseNode);\r\n                    h = dist + Math.abs(deltaAngle);\r\n                } else {\r\n                    h = dist;\r\n                }\r\n            case PathMode['astar-random']:\r\n                h = dist + Math.random();\r\n                break;\r\n            default:\r\n                h = dist;\r\n                break;\r\n        }\r\n        return h;\r\n    }\r\n\r\n    // Override\r\n    getNextNodes(): INodeBase[] {\r\n\r\n        return [];\r\n    }\r\n\r\n    // Override\r\n    getCost(\r\n        preNode: INodeBase\r\n    ): CostValueType {\r\n\r\n        return BLOCKER;\r\n    }\r\n\r\n    // Override\r\n    distanceTo(\r\n        node: INodeBase\r\n    ): number {\r\n\r\n        return 0;\r\n    }\r\n\r\n    // Override\r\n    angleTo(\r\n        node: INodeBase\r\n    ): number {\r\n\r\n        return 0;\r\n    }\r\n\r\n    // Override\r\n    logicDirTo(\r\n        node: INodeBase\r\n    ): number {\r\n\r\n        return 0;\r\n    }\r\n\r\n    getNode(\r\n        key: any,\r\n        createNode: boolean = false\r\n    ): INodeBase {\r\n\r\n        return this.manager.getNode(key, createNode);\r\n    }\r\n}","import { IPathFinder } from '../IPathFinder';\r\nimport { IAStar } from '../../../utils/astar/IAStar';\r\nimport { AStar } from '../../../utils/astar/AStar';\r\nimport { AStarNode } from './AStarNode';\r\n\r\nexport let CreateAStar = function (\r\n    pathFinder: IPathFinder\r\n): IAStar {\r\n\r\n    let CreateNodeCallback = function () {\r\n        return new AStarNode(pathFinder);\r\n    }\r\n    return new AStar(CreateNodeCallback);\r\n}","import {\r\n    IPathFinder,\r\n    SearchResultType\r\n} from './IPathFinder';\r\nimport { XYType, IChess } from '../board/ILogicBoard';\r\nimport { XYToKey } from './astar/Key';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\n\r\nexport let GetPath = function (\r\n    pathFinder: IPathFinder,\r\n    endChess: IChess | XYType,\r\n    out: SearchResultType = []\r\n): SearchResultType {\r\n\r\n    let board = pathFinder.board;\r\n    let endTileXY: XYType = board.chessToTileXYZ(endChess);\r\n    let startTileXYZ = pathFinder.startTileXYZ;\r\n    let nodesList = pathFinder.astar\r\n        .setPathMode(pathFinder.pathMode)\r\n        .getNodePath(\r\n            XYToKey(startTileXYZ.x, startTileXYZ.y),\r\n            XYToKey(endTileXY.x, endTileXY.y)\r\n        ) as IAStarNode[];\r\n    nodesList.forEach(function (node) {\r\n        out.push({\r\n            x: node.x,\r\n            y: node.y,\r\n            cost: node.g\r\n        });\r\n    })\r\n    return out;\r\n}","import {\r\n    IPathFinder, IConfig,\r\n    PathMode, PathModeString,\r\n    GetCostCallbackType, CostNodeType, CostValueType, BLOCKER,\r\n    SearchResultType\r\n} from './IPathFinder';\r\nimport {\r\n    ILogicBoard,\r\n    IChess, XYZType, XYType, XType, YType\r\n} from '../board/ILogicBoard'\r\nimport { IAStar } from '../../utils/astar/IAStar';\r\nimport { CreateAStar } from './astar/CreateAStar';\r\nimport { GetCost } from './GetCost';\r\nimport { FindArea } from './FindArea';\r\nimport { FindPath } from './FindPath';\r\nimport { GetPath } from './GetPath';\r\nimport { TileXYToCost } from './TileXYToCost';\r\n\r\nexport class PathFinder implements IPathFinder {\r\n    board: ILogicBoard;\r\n    astar: IAStar;\r\n\r\n    constCost: number;\r\n    costCallback: GetCostCallbackType | null;\r\n    costCallbackScope: any;\r\n    pathMode: PathMode;\r\n    occupiedTest: boolean;\r\n    blockerTest: boolean;\r\n    edgeBlockerTest: boolean;\r\n\r\n    startTileXYZ: XYZType;\r\n    cacheCost: boolean;\r\n    weight: number;\r\n    shuffleNeighbors: boolean;\r\n\r\n    constructor({\r\n        board = undefined,\r\n\r\n        cost = 1,\r\n        costCallback = undefined,\r\n        costCallbackScope = undefined,\r\n\r\n        occupiedTest = false,\r\n        blockerTest = false,\r\n        edgeBlockerTest = false,\r\n\r\n        pathMode = PathMode['astar'],\r\n\r\n        cacheCost = true,\r\n\r\n        weight = 10,\r\n\r\n        shuffleNeighbors = false\r\n    }: IConfig = {}) {\r\n\r\n        this.setBoard(board);\r\n\r\n        if (costCallback) {\r\n            this.setCostFunction(costCallback, costCallbackScope);\r\n        } else {\r\n            this.setConstCost(cost);\r\n            this.setCostFunction(null);\r\n        }\r\n\r\n        this.setPathMode(pathMode);\r\n        this.setOccupiedTest(occupiedTest);\r\n        this.setBlockerTest(blockerTest);\r\n        this.setEdgeBlockerTest(edgeBlockerTest);\r\n\r\n        this.setCacheCostMode(cacheCost);\r\n        this.setWeight(weight);\r\n        this.setShuffleNeighborsMode(shuffleNeighbors);\r\n\r\n        this.astar = CreateAStar(this);\r\n    }\r\n\r\n    setBoard(\r\n        board: ILogicBoard\r\n    ): this {\r\n\r\n        this.board = board;\r\n        return this;\r\n    }\r\n\r\n    setConstCost(\r\n        cost: number\r\n    ): this {\r\n\r\n        this.constCost = cost;\r\n        return this;\r\n    }\r\n\r\n    setCostFunction(\r\n        callback: GetCostCallbackType | null,\r\n        scope?: any\r\n    ): this {\r\n\r\n        this.costCallback = callback;\r\n        this.costCallbackScope = scope;\r\n        return this;\r\n    }\r\n\r\n    setPathMode(\r\n        mode: PathMode | PathModeString\r\n    ): this {\r\n\r\n        if (typeof (mode) === 'string') {\r\n            mode = PathMode[mode];\r\n        }\r\n        this.pathMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setOccupiedTest(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.occupiedTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setBlockerTest(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.blockerTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setEdgeBlockerTest(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.edgeBlockerTest = enable;\r\n        return this;\r\n    }\r\n\r\n    setCacheCostMode(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.cacheCost = enable;\r\n        return this;\r\n    }\r\n\r\n    setWeight(\r\n        value: number\r\n    ): this {\r\n\r\n        this.weight = value;\r\n        return this;\r\n    }\r\n\r\n    setShuffleNeighborsMode(\r\n        enable: boolean = true\r\n    ): this {\r\n\r\n        this.shuffleNeighbors = enable;\r\n        return this;\r\n    }\r\n\r\n    getCost(\r\n        currNode: CostNodeType,\r\n        prevNode: CostNodeType\r\n    ): CostValueType {\r\n\r\n        return GetCost(this, currNode, prevNode);\r\n    }\r\n\r\n    findArea(\r\n        startChess: IChess,\r\n        movingPoints?: number,\r\n        out: SearchResultType = []\r\n    ): SearchResultType {\r\n\r\n        return FindArea(this, startChess, movingPoints, out);\r\n    }\r\n\r\n    get BLOCKER(): CostValueType {\r\n        return BLOCKER;\r\n    }\r\n\r\n    findPath(\r\n        startChess: IChess,\r\n        endChess: IChess | XYType,\r\n        movingPoints?: number,\r\n        isClosest: boolean = true,\r\n        out: SearchResultType = []\r\n    ): SearchResultType {\r\n\r\n        return FindPath(this, startChess, endChess, movingPoints, isClosest, out);\r\n    }\r\n\r\n    getPath(\r\n        endChess: IChess | XYZType | XYType,\r\n        out: SearchResultType = []\r\n    ): SearchResultType {\r\n\r\n        return GetPath(this, endChess, out);\r\n    }\r\n\r\n    tileXYToCost(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        pathCost: boolean = true\r\n    ): CostValueType {\r\n\r\n        return TileXYToCost(this, tileX, tileY, pathCost);\r\n    }\r\n}","import {\r\n    IPathFinder,\r\n    CostNodeType, CostValueType, BLOCKER\r\n} from './IPathFinder';\r\n\r\nexport let GetCost = function (\r\n    pathFinder: IPathFinder,\r\n    currNode: CostNodeType,\r\n    prevNode: CostNodeType\r\n): CostValueType {\r\n\r\n    // Occupied test\r\n    if (pathFinder.occupiedTest) {\r\n        if (pathFinder.board.contains(currNode.x, currNode.y, pathFinder.startTileXYZ.z)) {\r\n            return BLOCKER;\r\n        }\r\n    }\r\n    // Blocker test\r\n    if (pathFinder.blockerTest) {\r\n        if (pathFinder.board.hasBlocker(currNode.x, currNode.y)) {\r\n            return BLOCKER;\r\n        }\r\n    }\r\n    // Edge-blocker test\r\n    if (pathFinder.edgeBlockerTest) {\r\n        // TODO\r\n    }\r\n\r\n    let callback = pathFinder.costCallback;\r\n    if (callback) {\r\n        let scope = pathFinder.costCallbackScope;\r\n        let cost: CostValueType;\r\n        if (scope) {\r\n            cost = callback.call(scope, currNode, prevNode, pathFinder);\r\n        } else {\r\n            cost = callback(currNode, prevNode, pathFinder);\r\n        }\r\n        if (cost === undefined) {\r\n            cost = BLOCKER;\r\n        }\r\n        return cost;\r\n    } else {\r\n        return pathFinder.constCost;\r\n    }\r\n}","import { IPathFinder, SearchResultType } from './IPathFinder';\r\nimport { IChess, XYZType } from '../board/ILogicBoard';\r\nimport { XYToKey } from './astar/Key';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\n\r\nexport let FindArea = function (\r\n    pathFinder: IPathFinder,\r\n    startChess: IChess,\r\n    movingPoints?: number | undefined,\r\n    out: SearchResultType = []\r\n): SearchResultType {\r\n\r\n    let board = pathFinder.board;\r\n    // Chess not at board\r\n    if (!board.hasChess(startChess)) {\r\n        return out;\r\n    }\r\n    // Negative moving points\r\n    if ((movingPoints !== undefined) && (movingPoints <= 0)) {\r\n        return out;\r\n    }\r\n\r\n    let astar = pathFinder.astar;\r\n    let startTileXYZ = board.chessToTileXYZ(startChess) as XYZType,\r\n        startTileX = startTileXYZ.x,\r\n        startTileY = startTileXYZ.y;\r\n    pathFinder.startTileXYZ = startTileXYZ;\r\n    let startNodeKey = XYToKey(startTileX, startTileY);\r\n    astar.search(startNodeKey, null, movingPoints);\r\n\r\n    let nodesMap = astar.getAllNodes() as Map<string, IAStarNode>,\r\n        nodesList: IAStarNode[] = [];\r\n    for (const [key, node] of nodesMap) {\r\n        // Not include start node\r\n        if ((node.x === startTileX) && (node.y === startTileY)) {\r\n            continue;\r\n        }\r\n\r\n        if (!node.closed) {\r\n            continue;\r\n        }\r\n        nodesList.push(node);\r\n    }\r\n    // Sort by sn (creating order)\r\n    nodesList.sort(function (nodeA, nodeB) {\r\n        let snA = nodeA.sn;\r\n        let snB = nodeB.sn;\r\n        return (snA > snB) ? 1 :\r\n            (snA < snB) ? -1 :\r\n                0;\r\n    });\r\n    nodesList.forEach(function (node) {\r\n        out.push({\r\n            x: node.x,\r\n            y: node.y,\r\n            cost: node.g\r\n        });\r\n    })\r\n    return out;\r\n}","import {\r\n    IPathFinder,\r\n    SearchResultType\r\n} from './IPathFinder';\r\nimport { IChess, XYZType, XYType } from '../board/ILogicBoard';\r\nimport { XYToKey } from './astar/Key';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\nimport { GetPath } from './GetPath';\r\n\r\nexport let FindPath = function (\r\n    pathFinder: IPathFinder,\r\n    startChess: IChess,\r\n    endChess: IChess | XYType,\r\n    movingPoints?: number,\r\n    isClosest: boolean = true,\r\n    out: SearchResultType = []\r\n): SearchResultType {\r\n\r\n    let board = pathFinder.board;\r\n    // Chess not at board\r\n    if (!board.hasChess(startChess)) {\r\n        return out;\r\n    }\r\n    // Negative moving points\r\n    if ((movingPoints !== undefined) && (movingPoints <= 0)) {\r\n        return out;\r\n    }\r\n\r\n    let astar = pathFinder.astar;\r\n    let startTileXYZ = board.chessToTileXYZ(startChess) as XYZType;\r\n    let endTileXY = board.chessToTileXYZ(endChess) as XYType;\r\n    pathFinder.startTileXYZ = startTileXYZ;\r\n    let startNodeKey = XYToKey(startTileXYZ.x, startTileXYZ.y),\r\n        endNodeKey = XYToKey(endTileXY.x, endTileXY.y);\r\n\r\n    astar\r\n        .setPathMode(pathFinder.pathMode)\r\n        .setWeight(pathFinder.weight)\r\n        .search(startNodeKey, endNodeKey, movingPoints);\r\n\r\n    let endNode = ((isClosest) ? astar.getClosestNode() : astar.getNode(endNodeKey)) as IAStarNode;\r\n    if (endNode === null) {\r\n        return out;\r\n    }\r\n\r\n    return GetPath(pathFinder, (endNode as XYType), out);\r\n}\r\nexport default FindPath;","import { IPathFinder, CostValueType } from './IPathFinder';\r\nimport { XType, YType } from '../board/ILogicBoard';\r\nimport { XYToKey } from './astar/Key';\r\nimport { IAStarNode } from './astar/IAStarNode';\r\n\r\nexport let TileXYToCost = function (\r\n    pathFinder: IPathFinder,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    pathCost: boolean = true\r\n): CostValueType {\r\n\r\n    let node = pathFinder.astar.getNode(XYToKey(tileX, tileY)) as IAStarNode;\r\n    if (node === null) {\r\n        return null;\r\n    }\r\n    return (pathCost) ? node.g : node.cost;\r\n}","import { TextureManagerInstance } from '@phaserjs/phaser/textures/TextureManagerInstance';\r\nimport { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { CanvasTexture } from '@phaserjs/phaser/textures/types/CanvasTexture';\r\n\r\n/**\r\n * Draw on canvas texture.\r\n *\r\n * @param {(string | Texture)} key Texture key, or texture object.\r\n * @param {(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D) => void} callback Drawing callback.\r\n * @param {*} [scope] Context of drawing callback.\r\n * @param {number} [resolution=1] Resolution of canvas.\r\n * @returns {Texture} Texture object.\r\n */\r\nexport let DrawCanvasTexture = function (\r\n    key: string | Texture,\r\n    callback: (canvas: HTMLCanvasElement, context: CanvasRenderingContext2D) => void,\r\n    scope?: any,\r\n    resolution: number = 1\r\n): Texture {\r\n\r\n    let texture: Texture;\r\n    if (typeof (key) === 'string') {\r\n        let textureManager = TextureManagerInstance.get();\r\n        if (!textureManager.has(key)) {\r\n            textureManager.add(key, CanvasTexture());\r\n        }\r\n        texture = textureManager.get(key);\r\n    } else {\r\n        texture = key;\r\n    }\r\n\r\n    let canvas = texture.image as HTMLCanvasElement;\r\n    let context = canvas.getContext('2d');\r\n\r\n    if (scope) {\r\n        callback.call(scope, canvas, context);\r\n    } else {\r\n        callback(canvas, context);\r\n    }\r\n\r\n    texture.setSize(\r\n        canvas.width / resolution,\r\n        canvas.height / resolution\r\n    );\r\n    if (texture.binding) {\r\n        texture.binding.update();\r\n    }\r\n\r\n    return texture;\r\n}","import { GetCanvasGradientCallbackType } from '../types/GetCanvasGradientCallbackType';\r\n\r\nexport let GetStyle = function (\r\n    style: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    canvas: HTMLCanvasElement,\r\n    context: CanvasRenderingContext2D\r\n): string | CanvasGradient | CanvasPattern {\r\n\r\n    switch (typeof (style)) {\r\n        case 'number': return `#${style.toString(16)}`;\r\n        case 'function': return style(canvas, context);\r\n        default: return style;\r\n    }\r\n}","import { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { DrawCanvasTexture } from './DrawCanvasTexture';\r\nimport { Vec2Type } from '../../utils/types/VectorType';\r\nimport { GetCanvasGradientCallbackType } from '../../utils/types/GetCanvasGradientCallbackType';\r\nimport { GetStyle } from '../../utils/canvas/GetStyle';\r\n\r\nexport interface IConfig {\r\n    points: Vec2Type[],\r\n    fillStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    strokeStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    lineWidth?: number,\r\n    lineJoin?: 'bevel' | 'round' | 'miter'\r\n}\r\n\r\nexport let CreatePolygonTexture = function (\r\n    key: string | Texture,\r\n    {\r\n        points,\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth = 2,\r\n        lineJoin = 'round'\r\n    }: IConfig = { points: [] }\r\n): Texture {\r\n\r\n    return DrawCanvasTexture(key, function (canvas, context) {\r\n        if (points.length === 0) {\r\n            canvas.width = 1;\r\n            canvas.height = 1;\r\n            return;\r\n        }\r\n\r\n        if (!strokeStyle) {\r\n            lineWidth = 0;\r\n        }\r\n\r\n        let minX = GetMinProperty(points, 'x');\r\n        let minY = GetMinProperty(points, 'y');\r\n        let maxX = GetMaxProperty(points, 'x');\r\n        let maxY = GetMaxProperty(points, 'y');\r\n\r\n        let width = maxX - minX ;\r\n        let height = maxY - minY ;\r\n\r\n        let halfW = width / 2;\r\n        let halfH = height / 2;\r\n        let halfLW = lineWidth / 2;\r\n\r\n        canvas.width = Math.ceil(width);\r\n        canvas.height = Math.ceil(height);\r\n\r\n        context.beginPath();\r\n        context.lineJoin = lineJoin;\r\n\r\n        let point = points[0];\r\n\r\n        context.moveTo(\r\n            Indent((point.x - minX), halfW, halfLW),\r\n            Indent((point.y - minY), halfH, halfLW)\r\n        );\r\n\r\n        for (let i = 1, cnt = points.length; i < cnt; i++) {\r\n            point = points[i];\r\n            context.lineTo(\r\n                Indent((point.x - minX), halfW, halfLW),\r\n                Indent((point.y - minY), halfH, halfLW)\r\n            )\r\n        }\r\n\r\n        context.closePath();\r\n\r\n        if (fillStyle) {\r\n            context.fillStyle = GetStyle(fillStyle, canvas, context);\r\n            context.fill();\r\n        }\r\n\r\n        if (strokeStyle) {\r\n            context.strokeStyle = GetStyle(strokeStyle, canvas, context);\r\n            context.lineWidth = lineWidth;\r\n            context.stroke();\r\n        }\r\n\r\n    });\r\n}\r\n\r\nlet GetMaxProperty = function (\r\n    items: object[],\r\n    key: string\r\n): number {\r\n\r\n    let result = -Infinity;\r\n    for (let i = 0, cnt = items.length; i < cnt; i++) {\r\n        result = Math.max(result, items[i][key]);\r\n    }\r\n    return result;\r\n}\r\n\r\nlet GetMinProperty = function (\r\n    items: object[],\r\n    key: string\r\n): number {\r\n\r\n    let result = Infinity;\r\n    for (let i = 0, cnt = items.length; i < cnt; i++) {\r\n        result = Math.min(result, items[i][key]);\r\n    }\r\n    return result;\r\n}\r\n\r\nlet Indent = function (\r\n    value: number,\r\n    halfBound: number,\r\n    offset: number\r\n): number {\r\n\r\n    if (value < halfBound) {\r\n        return (value + offset);\r\n    } else if (value > halfBound) {\r\n        return (value - offset);\r\n    } else {\r\n        return value;\r\n    }\r\n}","import { Texture } from '@phaserjs/phaser/textures/Texture';\r\nimport { CreatePolygonTexture } from './CreatePolygonTexture';\r\nimport { GetCanvasGradientCallbackType } from '../../utils/types/GetCanvasGradientCallbackType';\r\n\r\nexport enum Direction {\r\n    right = 0,\r\n    down = 1,\r\n    left = 2,\r\n    up = 3\r\n}\r\n\r\nexport interface IConfig {\r\n    direction?: Direction,\r\n    width?: number,\r\n    height?: number,\r\n    fillStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    strokeStyle?: string | number | CanvasGradient | CanvasPattern | GetCanvasGradientCallbackType,\r\n    lineWidth?: number\r\n}\r\n\r\nexport let CreateTriangleTexture = function (\r\n    key: string | Texture,\r\n    {\r\n        direction = Direction.right,\r\n        width = 32,\r\n        height = width,\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth = 2\r\n    }: IConfig = {}\r\n): Texture {\r\n\r\n    let x1: number, y1: number,\r\n        x2: number, y2: number,\r\n        x3: number, y3: number;\r\n    switch (direction) {\r\n        case Direction.down:\r\n            x1 = 0;\r\n            y1 = 0;\r\n            x2 = width;\r\n            y2 = 0;\r\n            x3 = width / 2;\r\n            y3 = height;\r\n            break;\r\n        case Direction.left:\r\n            x1 = 0;\r\n            y1 = height / 2;\r\n            x2 = width;\r\n            y2 = 0;\r\n            x3 = width;\r\n            y3 = height;\r\n            break;\r\n        case Direction.up:\r\n            x1 = 0;\r\n            y1 = height;\r\n            x2 = width / 2;\r\n            y2 = 0;\r\n            x3 = width;\r\n            y3 = height;\r\n            break;\r\n        default: // Direction.right\r\n            x1 = 0;\r\n            y1 = 0;\r\n            x2 = 0;\r\n            y2 = height;\r\n            x3 = width;\r\n            y3 = height / 2;\r\n            break;\r\n    }\r\n\r\n    return CreatePolygonTexture(key, {\r\n        points: [\r\n            { x: x1, y: y1 },\r\n            { x: x2, y: y2 },\r\n            { x: x3, y: y3 }\r\n        ],\r\n        fillStyle: fillStyle,\r\n        strokeStyle: strokeStyle,\r\n        lineWidth: lineWidth\r\n    })\r\n}","import { BackgroundColor, Parent, Scenes, Size, WebGLRenderer } from '@phaserjs/phaser/config';\r\nimport { Game, Scene } from '@phaserjs/phaser';\r\nimport { StaticWorld } from '@phaserjs/phaser/world';\r\nimport { AddChild } from '@phaserjs/phaser/display/';\r\nimport { Sprite, SetTint, SetAlpha } from '@phaserjs/phaser/gameobjects/sprite';\r\nimport { Text } from '@phaserjs/phaser/gameobjects/text'\r\n\r\nimport { Board, HexagonGrid, PathFinder } from '../../src/board';\r\nimport { CreatePolygonTexture } from '../../src/texture/canvastexture';\r\nimport { Shuffle } from '../../src/utils/array/Shuffle';\r\n\r\nclass MyBoard extends Board {\r\n    pathFinder: PathFinder;\r\n\r\n    constructor(config) {\r\n        super(config);\r\n\r\n        this.pathFinder = new PathFinder({\r\n            board: this,\r\n            pathMode: 'astar',\r\n            occupiedTest: true\r\n        });\r\n\r\n        CreatePolygonTexture('tile', {\r\n            points: this.getGridPoints(),\r\n            strokeStyle: 'white',\r\n            lineWidth: 1,\r\n            lineJoin: 'miter'\r\n        })\r\n\r\n        CreatePolygonTexture('chess', {\r\n            points: this.getGridPoints(),\r\n            fillStyle: 'white'\r\n        })\r\n    }\r\n\r\n    strokeGrid(\r\n        world: StaticWorld\r\n    ): this {\r\n\r\n        this.forEachTileXY((tileXY, board) => {\r\n            let worldXY = board.tileXYToWorldXY(tileXY.x, tileXY.y, true);\r\n            let tile = new Sprite(worldXY.x, worldXY.y, 'tile');\r\n            AddChild(world, tile);\r\n        })\r\n        return this;\r\n    }\r\n\r\n    createChess(\r\n        world: StaticWorld,\r\n        x: number,\r\n        y: number,\r\n        z: number,\r\n        color?: number\r\n    ) {\r\n\r\n        let chess = new Sprite(0, 0, 'chess');\r\n        AddChild(world, chess);\r\n        if (color !== undefined) {\r\n            SetTint(color, chess);\r\n        }\r\n        this.addChess(chess, x, y, z);\r\n        return chess;\r\n    }\r\n\r\n    findPath(\r\n        startChess,\r\n        endChess,\r\n        isClosest = true\r\n    ) {\r\n        return this.pathFinder.findPath(startChess, endChess, undefined, isClosest);\r\n    }\r\n}\r\n\r\nclass Demo extends Scene {\r\n    constructor() {\r\n        super();\r\n\r\n        const world = new StaticWorld(this);\r\n\r\n        const board = new MyBoard({\r\n            grid: (new HexagonGrid({\r\n                x: 40, y: 40,\r\n                cellWidth: 40, cellHeight: 48\r\n            })),\r\n\r\n            width: 10, height: 10\r\n        })\r\n\r\n        board.strokeGrid(world);\r\n        // Add start chess\r\n        let chessA = board.createChess(world, 2, 2, 1, 0xffffff);\r\n        // Add end chess\r\n        let chessB = board.createChess(world, 8, 8, 1, 0xff0000);\r\n        // Add some blockers (z=1, to block chessA)\r\n        let emptyTileXYArray = Shuffle(board.getEmptyTileXYArray(1))\r\n        for (let i = 0; i < 30; i++) {\r\n            let emptyTileXY = emptyTileXYArray[i];\r\n            board.createChess(world, emptyTileXY.x, emptyTileXY.y, 1, 0x808080);\r\n        }\r\n        // Find (closest) path tileXY array\r\n        let tileXYArray = board.findPath(chessA, chessB);\r\n        // Draw markers\r\n        tileXYArray.forEach((tileXY) => {\r\n            let marker = board.createChess(world, tileXY.x, tileXY.y, -1, 0x004000);\r\n            SetAlpha(0.5, marker);\r\n\r\n            let worldXY = board.tileXYToWorldXY(tileXY.x, tileXY.y, true);\r\n            let text = new Text(worldXY.x, worldXY.y, tileXY.cost.toString());\r\n            AddChild(world, text);\r\n        })\r\n    }\r\n}\r\n\r\nnew Game(\r\n    WebGLRenderer(),\r\n    Size(800, 600),\r\n    Parent('game'),\r\n    BackgroundColor(0x2d2d2d),\r\n    Scenes(Demo)\r\n);\r\n","import {\r\n    ILogicBoard,\r\n    IConfig,\r\n    XType, YType, ZType, XYType, Vec2Type,\r\n    IChessData,\r\n    ForEachTileXYCallback,\r\n    DistanceConfig,\r\n    MirrorMode, MirrorModeString\r\n} from './ILogicBoard';\r\nimport { IGrid } from '../grid/IGrid';\r\nimport { IBoardData, IChess, XYZType } from './boarddata/IBoardData';\r\n\r\nimport { BoardData } from './boarddata/BoardData';\r\nimport { SetBoardWidth } from './boarddata/SetBoardWidth';\r\nimport { SetBoardHeight } from './boarddata/SetBoardHeight';\r\n\r\nimport { AddChess } from './chess/AddChess';\r\nimport { AngleBetween } from './worldposition/AngleBetween';\r\nimport { AngleSnapToDirection } from './worldposition/AngleSnapToDirection';\r\nimport { AngleToward } from './worldposition/AngleToward';\r\nimport { AreNeighbors } from './neighbors/AreNeighbors';\r\nimport { ChessToTileXYZ } from './tileposition/ChessToTileXYZ';\r\nimport { Contains } from './tileposition/Contains';\r\nimport { DirectionBetween } from './tileposition/DirectionBetween';\r\nimport { FilledRingToTileXYArray } from './ring/FilledRingToTileXYArray';\r\nimport { Fit } from './transform/Fit';\r\nimport { ForEachTileXY } from './tileposition/ForEachTileXY';\r\nimport { GetAllChess } from './chess/GetAllChess';\r\nimport { GetChessData } from '../chess/GetChessData';\r\nimport { GetDistance } from './tileposition/GetDistance';\r\nimport { GetEmptyTileXYArray } from './empty/GetEmptyTileXYArray';\r\nimport { GetGridPoints } from './worldposition/GetGridPoints';\r\nimport { GetNeighborChess } from './neighbors/GetNeighborChess';\r\nimport { GetNeighborChessDirection } from './neighbors/GetNeighborChessDirection';\r\nimport { GetNeighborTileDirection } from './neighbors/GetNeighborTileDirection';\r\nimport { GetNeighborTileXY } from './neighbors/GetNeighborTileXY';\r\nimport { GetNeighborTileXYAtAngle } from './neighbors/GetNeighborTileXYAtAngle';\r\nimport { GetOppositeDirection } from './tileposition/GetOppositeDirection';\r\nimport { GetRandomEmptyTileXY } from './empty/GetRandomEmptyTileXY';\r\nimport { GetTileXYAtDirection } from './neighbors/GetTileXYAtDirection'\r\nimport { GetWrapTileXY } from './tileposition/GetWrapTileXY';\r\nimport { GridAlign } from './worldposition/GridAlign';\r\nimport { HasBlocker } from './blocker/HasBlocker';\r\nimport { HasChess } from './chess/HasChess';\r\nimport { HasEdgeBlocker } from './blocker/HasEdgeBlocker';\r\nimport { IsAngleInCone } from './worldposition/IsAngleInCone';\r\nimport { IsDirectionInCone } from './tileposition/IsDirectionInCone';\r\nimport { IsOverlappingPoint } from './worldposition/IsOverlappingPoint';\r\nimport { Mirror } from './transform/Mirror';\r\nimport { Offset } from './transform/Offset';\r\nimport { RemoveAllChess } from './chess/RemoveAllChess';\r\nimport { RemoveChess } from './chess/RemoveChess';\r\nimport { RingToTileXYArray } from './ring/RingToTileXYArray';\r\nimport { Rotate } from './transform/Rotate';\r\nimport { SwapChess } from './chess/SwapChess';\r\nimport { TileXYArrayToChessArray } from './tileposition/TileXYArrayToChessArray';\r\nimport { TileXYToChessArray } from './tileposition/TileXYToChessArray';\r\nimport { TileXYZToChess } from './tileposition/TileXYZToChess';\r\nimport { TileZToChessArray } from './tileposition/TileZToChessArray';\r\nimport { TileXYArrayToWorldXYArray } from './worldposition/TileXYArrayToWorldXYArray';\r\nimport { TileXYToWorldXY } from './worldposition/TileXYToWorldXY';\r\nimport { WorldXYSnapToGrid } from './worldposition/WorldXYSnapToGrid';\r\nimport { WorldXYToChess } from './worldposition/WorldXYToChess';\r\nimport { WorldXYToTileXY } from './worldposition/WorldXYToTileXY';\r\n\r\nexport class LogicBoard implements ILogicBoard {\r\n\r\n    grid: IGrid;\r\n    wrapMode: boolean;\r\n    infinityMode: boolean;\r\n    width: number | undefined;\r\n    height: number | undefined;\r\n    boardData: IBoardData;\r\n    _isBoard: boolean;\r\n\r\n    constructor({\r\n        grid = undefined,\r\n        wrap = false,\r\n        inifinity = false,\r\n        width = 0,\r\n        height = 0\r\n    }: IConfig = {}) {\r\n\r\n        this.boardData = new BoardData();\r\n        this._isBoard = true;\r\n        this.setGrid(grid);\r\n        this.setWrapMode(wrap);\r\n        this.setInfinityMode(inifinity);\r\n        this.setBoardSize(width, height);\r\n    }\r\n\r\n    destroy() {\r\n\r\n    }\r\n\r\n    setGrid(grid?: IGrid): this {\r\n\r\n        this.grid = grid;\r\n        return this;\r\n    }\r\n\r\n    setWrapMode(mode: boolean = true): this {\r\n\r\n        this.wrapMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setInfinityMode(mode: boolean = true): this {\r\n\r\n        this.infinityMode = mode;\r\n        return this;\r\n    }\r\n\r\n    setBoardSize(width: number = 0, height: number = 0): this {\r\n\r\n        SetBoardWidth(this, width);\r\n        SetBoardHeight(this, height);\r\n        return this;\r\n    }\r\n\r\n    addChess(\r\n        chess: IChess,\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType,\r\n        align: boolean = true\r\n    ): this {\r\n\r\n        AddChess(this, chess, tileX, tileY, tileZ, align);\r\n        return this;\r\n    }\r\n\r\n    angleBetween(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType\r\n    ): number {\r\n\r\n        return AngleBetween(this, chessA, chessB);\r\n    }\r\n\r\n    angleSnapToDirection(\r\n        tileXY: XYType,\r\n        angle: number\r\n    ): number {\r\n\r\n        return AngleSnapToDirection(this, tileXY, angle);\r\n    }\r\n\r\n    angleToward(\r\n        tileXY: XYType,\r\n        direction: number\r\n    ): number {\r\n\r\n        return AngleToward(this, tileXY, direction);\r\n    }\r\n\r\n    areNeighbors(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType\r\n    ): boolean {\r\n\r\n        return AreNeighbors(this, chessA, chessB);\r\n    }\r\n\r\n    chessToTileXYZ(\r\n        chess: IChess | XYZType | XYType\r\n    ): XYZType | any | null {\r\n\r\n        return ChessToTileXYZ(this, chess);\r\n    }\r\n\r\n    contains(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType\r\n    ): boolean {\r\n\r\n\r\n        return Contains(this, tileX, tileY, tileZ);\r\n    }\r\n\r\n    directionBetween(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        round: boolean = true\r\n    ): number | null {\r\n\r\n        return DirectionBetween(this, chessA, chessB, round);\r\n    }\r\n\r\n    filledRingToTileXYArray(\r\n        centerTileXY: XYType,\r\n        radius: number,\r\n        nearToFar: boolean = true,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return FilledRingToTileXYArray(this, centerTileXY, radius, nearToFar, out);\r\n    }\r\n\r\n    fit(\r\n        tileXYArray: XYType[]\r\n    ): XYType[] {\r\n\r\n        return Fit(this, tileXYArray);\r\n    }\r\n\r\n    forEachTileXY(\r\n        callback: ForEachTileXYCallback,\r\n        scope?: any,\r\n        order: number = 0\r\n    ): this {\r\n\r\n        ForEachTileXY(this, callback, scope, order);\r\n        return this;\r\n    }\r\n\r\n    getAllChess(\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return GetAllChess(this, out);\r\n    }\r\n\r\n    getChessData(\r\n        chess: IChess\r\n    ): IChessData {\r\n\r\n        return GetChessData(chess);\r\n    }\r\n\r\n    getDistance(\r\n        tileA: XYType,\r\n        tileB: XYType,\r\n        roughMode: boolean = false\r\n    ): number {\r\n\r\n        return GetDistance(this, tileA, tileB, roughMode);\r\n    }\r\n\r\n    getEmptyTileXYArray(\r\n        tileZ: ZType | ZType[] = 0,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return GetEmptyTileXYArray(this, tileZ, out);\r\n    }\r\n\r\n    getGridPoints(\r\n        tileX?: number | Vec2Type,\r\n        tileY?: number,\r\n        out?: Vec2Type[] | true\r\n    ): Vec2Type[] {\r\n\r\n        return GetGridPoints(this, tileX, tileY, out);\r\n    }\r\n\r\n    getNeighborChess(\r\n        chess: IChess | XYType,\r\n        directions: number | number[] | string | null,\r\n        neighborTileZ?: ZType | null,\r\n        out?: IChess[]\r\n    ): IChess | IChess[] | null {\r\n\r\n        return GetNeighborChess(this, chess, directions, neighborTileZ, out);\r\n    }\r\n\r\n    getNeighborChessDirection(\r\n        chess: IChess | XYType,\r\n        neighborChess: IChess | XYType\r\n    ): number {\r\n\r\n        return GetNeighborChessDirection(this, chess, neighborChess);\r\n    }\r\n\r\n    getNeighborTileDirection(\r\n        srcTileXY: XYType | null,\r\n        neighborTileXY: XYType | null\r\n    ): number | null {\r\n\r\n        return GetNeighborTileDirection(this, srcTileXY, neighborTileXY);\r\n    }\r\n\r\n    getNeighborTileXY(\r\n        srcTileXY: XYType,\r\n        directions: number | number[] | string | null = null,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType | XYType[] | null {\r\n\r\n        return GetNeighborTileXY(this, srcTileXY, directions, out);\r\n    }\r\n\r\n    getNeighborTileXYAtAngle(\r\n        srcTileXY: XYType,\r\n        angle: number,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType | null {\r\n\r\n        return GetNeighborTileXYAtAngle(this, srcTileXY, angle, out);\r\n    }\r\n\r\n    getOppositeDirection(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        direction: number\r\n    ): number {\r\n\r\n        return GetOppositeDirection(this, tileX, tileY, direction);\r\n    }\r\n\r\n    getRandomEmptyTileXY(\r\n        tileZ: ZType = 0,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType | null {\r\n\r\n        return GetRandomEmptyTileXY(this, tileZ, out);\r\n    }\r\n\r\n    getTileXYAtDirection(\r\n        chess: IChess | XYType,\r\n        directions: number | number[] | string | null,\r\n        distance: number | number[] | DistanceConfig,\r\n        out?: XYType | XYType[] | true\r\n    ): XYType | XYType[] | null {\r\n\r\n        return GetTileXYAtDirection(this, chess, directions, distance, out);\r\n    }\r\n\r\n    getWrapTileXY(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        return GetWrapTileXY(this, tileX, tileY, out)\r\n    }\r\n\r\n    gridAlign(\r\n        chess?: IChess,\r\n        tileX?: XType,\r\n        tileY?: YType\r\n    ): this {\r\n\r\n        GridAlign(this, chess, tileX, tileY);\r\n        return this;\r\n    }\r\n\r\n    hasBlocker(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ?: ZType\r\n    ): boolean {\r\n\r\n        return HasBlocker(this, tileX, tileY, tileZ);\r\n    }\r\n\r\n    hasChess(\r\n        chess: IChess\r\n    ): boolean {\r\n\r\n        return HasChess(this, chess);\r\n    }\r\n\r\n    hasEdgeBlocker(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ: ZType | undefined,\r\n        direction: number\r\n    ): boolean {\r\n\r\n        return HasEdgeBlocker(this, tileX, tileY, tileZ, direction);\r\n    }\r\n\r\n    isAngleInCone(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        face: number,\r\n        cone: number\r\n    ): boolean {\r\n\r\n        return IsAngleInCone(this, chessA, chessB, face, cone);\r\n    }\r\n\r\n    isDirectionInCone(\r\n        chessA: IChess | XYType,\r\n        chessB: IChess | XYType,\r\n        face: number,\r\n        cone: number\r\n    ): boolean {\r\n\r\n        return IsDirectionInCone(this, chessA, chessB, face, cone);\r\n    }\r\n\r\n    isOverlappingPoint(\r\n        worldX: number,\r\n        worldY: number,\r\n        tileZ?: ZType\r\n    ): boolean {\r\n\r\n        return IsOverlappingPoint(this, worldX, worldY, tileZ);\r\n    }\r\n\r\n    mirror(\r\n        tileXY: XYType,\r\n        mode: MirrorMode | MirrorModeString,\r\n        originTileXY: XYType | null = null,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        return Mirror(this, tileXY, mode, originTileXY, out);\r\n    }\r\n\r\n    offset(\r\n        tileXY: XYType,\r\n        offsetTileX: number,\r\n        offsetTileY: number,\r\n        out?: XYType | true\r\n    ): XYType {\r\n\r\n        return Offset(this, tileXY, offsetTileX, offsetTileY, out);\r\n    }\r\n\r\n    removeAllChess(\r\n        destroy: boolean = false,\r\n        fromBoardRemove: boolean = false\r\n    ): this {\r\n\r\n        RemoveAllChess(this, destroy, fromBoardRemove);\r\n        return this;\r\n    }\r\n\r\n    removeChess(\r\n        chess: IChess | null | undefined,\r\n        tileX?: XType,\r\n        tileY?: YType,\r\n        tileZ?: ZType,\r\n        destroy: boolean = false,\r\n        fromBoardRemove: boolean = false\r\n    ): this {\r\n\r\n        RemoveChess(this, chess, tileX, tileY, tileZ, destroy, fromBoardRemove);\r\n        return this;\r\n    }\r\n\r\n    ringToTileXYArray(\r\n        centerTileXY: XYType,\r\n        radius: number = 1,\r\n        out: XYType[] = []\r\n    ): XYType[] {\r\n\r\n        return RingToTileXYArray(this, centerTileXY, radius, out);\r\n    }\r\n\r\n    rotate(\r\n        tileXY: XYType,\r\n        direction: number,\r\n        originTileXY: XYType | null = null,\r\n        out: XYType | true = { x: 0, y: 0 }\r\n    ): XYType {\r\n\r\n        return Rotate(this, tileXY, direction, originTileXY, out);\r\n    }\r\n\r\n    setBoardWidth(width: number = 0): this {\r\n\r\n        SetBoardWidth(this, width);\r\n        return this\r\n    }\r\n\r\n    setBoardHeight(height: number = 0): this {\r\n\r\n        SetBoardHeight(this, height);\r\n        return this;\r\n    }\r\n\r\n    swapChess(\r\n        chessA: IChess,\r\n        chessB: IChess,\r\n        align: boolean = true\r\n    ): this {\r\n\r\n        SwapChess(this, chessA, chessB, align);\r\n        return this;\r\n    }\r\n\r\n    tileXYArrayToChessArray(\r\n        tileXYArray: XYType[],\r\n        tileZ?: ZType,\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return TileXYArrayToChessArray(this, tileXYArray, tileZ, out);\r\n    }\r\n\r\n    tileXYToChessArray(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return TileXYToChessArray(this, tileX, tileY, out);\r\n    }\r\n\r\n    tileXYZToChess(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        tileZ: ZType\r\n    ): IChess | undefined {\r\n\r\n        return TileXYZToChess(this, tileX, tileY, tileZ);\r\n    }\r\n\r\n    tileZToChessArray(\r\n        tileZ: ZType,\r\n        out: IChess[] = []\r\n    ): IChess[] {\r\n\r\n        return TileZToChessArray(this, tileZ, out);\r\n    }\r\n\r\n    tileXYArrayToWorldXYArray(\r\n        tileXYArray: XYType[],\r\n        out: Vec2Type[] = []\r\n    ): Vec2Type[] {\r\n\r\n        return TileXYArrayToWorldXYArray(this, tileXYArray, out);\r\n    }\r\n\r\n    tileXYToWorldXY(\r\n        tileX: XType,\r\n        tileY: YType,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return TileXYToWorldXY(this, tileX, tileY, out);\r\n    }\r\n\r\n    worldXYSnapToGrid(\r\n        worldX: number,\r\n        worldY: number,\r\n        out: Vec2Type | true = { x: 0, y: 0 }\r\n    ): Vec2Type {\r\n\r\n        return WorldXYSnapToGrid(this, worldX, worldY, out);\r\n    }\r\n\r\n    worldXYToChess(\r\n        worldX: number,\r\n        worldY: number,\r\n        tileZ?: ZType,\r\n        out?: IChess[]\r\n    ): IChess | IChess[] {\r\n\r\n        return WorldXYToChess(this, worldX, worldY, tileZ, out);\r\n    }\r\n\r\n    worldXYToTileXY(\r\n        worldX: number,\r\n        worldY: number,\r\n        out?: XYType | true\r\n    ): XYType {\r\n\r\n        return WorldXYToTileXY(this, worldX, worldY, out);\r\n    }\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XType, YType, ZType, XYZType\r\n} from '../ILogicBoard';\r\nimport { TileXYZToChess } from '../tileposition/TileXYZToChess';\r\nimport { GetChessData } from '../../chess/GetChessData';\r\nimport { GridAlign } from '../worldposition/GridAlign';\r\n\r\nexport let AddChess = function (\r\n    board: ILogicBoard,\r\n    chess: IChess,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ?: ZType,\r\n    align: boolean = true\r\n) {\r\n\r\n    if (!board.contains(tileX, tileY)) {\r\n        return;\r\n    }\r\n\r\n    let curTileXYZ = board.chessToTileXYZ(chess) as XYZType;\r\n    if (tileZ === undefined) {\r\n        if (curTileXYZ) {\r\n            tileZ = curTileXYZ.z;\r\n        } else {\r\n            tileZ = 0;\r\n        }\r\n    }\r\n\r\n    if (curTileXYZ &&\r\n        (curTileXYZ.x === tileX) && (curTileXYZ.y === tileY) && (curTileXYZ.z === tileZ)) {\r\n        // Move to current position\r\n        return;\r\n    }\r\n\r\n    let occupiedChess = TileXYZToChess(board, tileX, tileY, tileZ);\r\n    if (occupiedChess) {\r\n        // board.emit('kickout', occupiedChess, chess, curTileXYZ);\r\n        board.removeChess(null, tileX, tileY, tileZ); // Clear up (tileX, tileY, tileZ)\r\n    }\r\n\r\n    board.boardData.addChess(chess, tileX, tileY, tileZ);\r\n\r\n    if (board._isBoard) {\r\n        GetChessData(chess).setBoard(board);\r\n    }\r\n\r\n    if (align) {\r\n        GridAlign(board, chess, tileX, tileY);\r\n    }\r\n};","import {\r\n    ILogicBoard,\r\n    IChess, XYType\r\n} from '../ILogicBoard';\r\nimport { Between as GetAngle } from '../../../utils/math/angle/Between';\r\n\r\nexport let AngleBetween = function (\r\n    board: ILogicBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType\r\n): number {\r\n\r\n    let tileA = board.chessToTileXYZ(chessA);\r\n    let tileB = board.chessToTileXYZ(chessB);\r\n    let out = board.tileXYToWorldXY(tileA.x, tileA.y, true);\r\n    let x0 = out.x;\r\n    let y0 = out.y;\r\n    out = board.tileXYToWorldXY(tileB.x, tileB.y, true);\r\n    let x1 = out.x;\r\n    let y1 = out.y;\r\n    return GetAngle(x0, y0, x1, y1); // -PI~PI\r\n}","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\nimport { RadToDeg } from '../../../utils/math/angle/RadToDeg';\r\nimport { ShortestBetween } from '../../../utils/math/angle/ShortestBetween';\r\n\r\nexport let AngleSnapToDirection = function (\r\n    board: ILogicBoard,\r\n    tileXY: XYType,\r\n    angle: number\r\n): number {\r\n\r\n    angle = RadToDeg(angle); // -180~180\r\n    let directions = board.grid.allDirections;\r\n    let minDeltaAngle = Infinity,\r\n        direction = undefined;\r\n    for (let i = 0, cnt = directions.length; i < cnt; i++) {\r\n        let neighborAngle = RadToDeg(board.angleToward(tileXY, directions[i])); // -PI~PI -> -180~180\r\n        let deltaAngle = Math.abs(ShortestBetween(angle, neighborAngle));\r\n        if (deltaAngle < minDeltaAngle) {\r\n            minDeltaAngle = deltaAngle;\r\n            direction = i;\r\n        }\r\n    }\r\n\r\n    return direction;\r\n};","import {\r\n    ILogicBoard,\r\n    IChess, XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let AreNeighbors = function (\r\n    board: ILogicBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType\r\n): boolean {\r\n\r\n    return (board.getNeighborChessDirection(chessA, chessB) !== null);\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XYZType, XYType\r\n} from '../ILogicBoard';\r\nimport { IsTileXYZ } from '../utils/IsTileXYZ';\r\n\r\nexport let ChessToTileXYZ = function (\r\n    board: ILogicBoard,\r\n    chess: IChess | XYZType | XYType\r\n): XYZType | XYType | null {\r\n\r\n    let xyz: XYZType | undefined = board.boardData.getXYZ(chess);\r\n    if (xyz) {\r\n        return xyz;\r\n    } else if (IsTileXYZ(chess)) { // {x, y}, or {x, y, z}\r\n        return chess as XYType;\r\n    } else {\r\n        return null;\r\n    }\r\n\r\n}","import { IsPlainObject } from '../../../utils/object/IsPlainObject';\r\n\r\nexport let IsTileXYZ = function (obj: any): boolean {\r\n    if (obj && (IsPlainObject(obj) || obj.isTileXYZ)) {\r\n        return obj.hasOwnProperty('x') && obj.hasOwnProperty('y');\r\n    } else {\r\n        return false;\r\n    }\r\n}","export let IsPlainObject = function (obj: any): boolean {\r\n    // Not plain objects:\r\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n    // - DOM nodes\r\n    // - window\r\n    if (typeof (obj) !== 'object' || obj.nodeType || obj === obj.window) {\r\n        return false;\r\n    }\r\n\r\n    // Support: Firefox <20\r\n    // The try/catch suppresses exceptions thrown when attempting to access\r\n    // the \"constructor\" property of certain host objects, ie. |window.location|\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\r\n    try {\r\n        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n\r\n    // If the function hasn't returned already, we're confident that\r\n    // |obj| is a plain object, created by {} or constructed with new Object\r\n    return true;\r\n};\r\n","import {\r\n    ILogicBoard,\r\n    XType, YType, ZType\r\n} from '../ILogicBoard';\r\n\r\nexport let Contains = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ?: ZType\r\n): boolean {\r\n\r\n    let result: boolean;\r\n    if (board.infinityMode) {\r\n        result = true;\r\n    } else {\r\n        result = (tileX >= 0) && (tileX < board.width) &&\r\n            (tileY >= 0) && (tileY < board.height);\r\n    }\r\n    if (result && (tileZ !== undefined)) {\r\n        result = board.boardData.contains(tileX, tileY, tileZ);\r\n    }\r\n    return result;\r\n};","import {\r\n    ILogicBoard,\r\n    IChess, XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let DirectionBetween = function (\r\n    board: ILogicBoard,\r\n    chessA: IChess | XYType,\r\n    chessB: IChess | XYType,\r\n    round: boolean = true\r\n): number | null {\r\n\r\n    let tileA = board.chessToTileXYZ(chessA);\r\n    let tileB = board.chessToTileXYZ(chessB);\r\n    if ((tileA === null) || (tileB === null)) {\r\n        return null;\r\n    }\r\n\r\n    return board.grid.directionBetween(tileA, tileB, round);\r\n}","import {\r\n    ILogicBoard,\r\n    XYType,\r\n} from '../ILogicBoard';\r\n\r\nexport let FilledRingToTileXYArray = function (\r\n    board: ILogicBoard,\r\n    centerTileXY: XYType,\r\n    radius: number,\r\n    nearToFar: boolean = true,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    for (let i = 0; i <= radius; i++) {\r\n        let level = (nearToFar) ? i : (radius - i);\r\n        board.ringToTileXYArray(centerTileXY, level, out);\r\n    }\r\n    return out;\r\n}","// Offset tileXYArray to (0,0), and set board size to fit tileXYArray\r\nimport {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let Fit = function (\r\n    board: ILogicBoard,\r\n    tileXYArray: XYType[]\r\n): XYType[] {\r\n\r\n    // Get minimum tileX, tileY\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let tileXY: XYType;\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        tileXY = tileXYArray[i];\r\n        minX = Math.min(minX, tileXY.x);\r\n        minY = Math.min(minY, tileXY.y);\r\n    }\r\n    // Offset tileXYArray to (0,0)\r\n    if ((minX !== 0) || (minY !== 0)) {\r\n        for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n            tileXY = tileXYArray[i];\r\n            board.offset(tileXY, -minX, -minY, tileXY);\r\n        }\r\n    }\r\n\r\n    // Get maximun tileX, tileY\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        tileXY = tileXYArray[i];\r\n        maxX = Math.max(maxX, tileXY.x);\r\n        maxY = Math.max(maxY, tileXY.y);\r\n    }\r\n    // Set board size\r\n    board.setBoardSize(maxX + 1, maxY + 1);\r\n    return tileXYArray;\r\n}","import {\r\n    ILogicBoard,\r\n    IChess\r\n} from '../ILogicBoard';\r\n\r\nexport let GetAllChess = function (\r\n    board: ILogicBoard,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let chessToXYZ = board.boardData.chessToXYZ;\r\n    for (const [chess, xyz] of chessToXYZ) {\r\n        out.push(chess);\r\n    }\r\n    return out;\r\n};","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetDistance = function (\r\n    board: ILogicBoard,\r\n    tileA: XYType,\r\n    tileB: XYType,\r\n    roughMode?: boolean\r\n): number {\r\n\r\n    return board.grid.getDistance(tileA, tileB, roughMode);\r\n}","import {\r\n    ILogicBoard,\r\n    ZType, XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetEmptyTileXYArray = function (\r\n    board: ILogicBoard,\r\n    tileZ: ZType | ZType[] = 0,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    if (!Array.isArray(tileZ)) {\r\n        for (let tileY = 0; tileY < board.height; tileY++) {\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                if (board.tileXYZToChess(tileX, tileY, tileZ) === null) {\r\n                    out.push({\r\n                        x: tileX,\r\n                        y: tileY\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        let tileZArray = tileZ;\r\n        for (let tileY = 0; tileY < board.height; tileY++) {\r\n            for (let tileX = 0; tileX < board.width; tileX++) {\r\n                let isEmpty = true;\r\n                for (let k = 0, kcnt = tileZArray.length; k < kcnt; k++) {\r\n                    if (board.tileXYZToChess(tileX, tileY, tileZArray[k]) !== null) {\r\n                        isEmpty = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isEmpty) {\r\n                    out.push({\r\n                        x: tileX,\r\n                        y: tileY\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return out;\r\n}","import {\r\n    ILogicBoard,\r\n    Vec2Type\r\n} from '../ILogicBoard';\r\n\r\nexport let GetGridPoints = function (\r\n    board: ILogicBoard,\r\n    tileX?: number | Vec2Type,\r\n    tileY?: number,\r\n    out?: Vec2Type[] | true\r\n): Vec2Type[] {\r\n\r\n    return board.grid.getGridPoints(tileX, tileY, out);\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XYType, XYZType, ZType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetNeighborChess = function (\r\n    board: ILogicBoard,\r\n    chess: IChess | XYType,\r\n    directions: number | number[] | string | null,\r\n    neighborTileZ?: ZType | null,\r\n    out?: IChess[]\r\n): IChess | IChess[] | null {\r\n\r\n    let tileXYZ = board.chessToTileXYZ(chess);\r\n    if (tileXYZ === null) { // chess is not on board\r\n        return null;\r\n    }\r\n\r\n    if (neighborTileZ == null) {\r\n        neighborTileZ = (tileXYZ.hasOwnProperty('z')) ? (tileXYZ as XYZType).z : null;\r\n    }\r\n\r\n    let neighborTileXY = board.getNeighborTileXY(tileXYZ, directions, true);\r\n    if (neighborTileXY === null) {\r\n        return null;\r\n    } else if (Array.isArray(neighborTileXY)) { // NeighborTileXY array -> chess array\r\n        if (out === undefined) {\r\n            out = [];\r\n        }\r\n        return board.tileXYArrayToChessArray(neighborTileXY, neighborTileZ, out);\r\n    } else { // Single neighborTileXY -> single chess if tileZ, chess array if no tileZ\r\n        if (neighborTileZ == null) {\r\n            if (out === undefined) {\r\n                out = [];\r\n            }\r\n            return board.tileXYToChessArray(neighborTileXY.x, neighborTileXY.y, out);\r\n        } else {\r\n            return board.tileXYZToChess(neighborTileXY.x, neighborTileXY.y, neighborTileZ);\r\n        }\r\n    }\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XYType,\r\n} from '../ILogicBoard';\r\n\r\nexport let GetNeighborChessDirection = function (\r\n    board: ILogicBoard,\r\n    chess: IChess | XYType,\r\n    neighborChess: IChess | XYType\r\n): number {\r\n\r\n    let srcTileXYZ = board.chessToTileXYZ(chess);\r\n    let neighborTileXYZ = board.chessToTileXYZ(neighborChess);\r\n    return board.getNeighborTileDirection(srcTileXYZ, neighborTileXYZ);\r\n}","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetNeighborTileDirection = function (\r\n    board: ILogicBoard,\r\n    srcTileXY: XYType | null,\r\n    neighborTileXY: XYType | null\r\n): number | null {\r\n\r\n    if ((srcTileXY === null) || (neighborTileXY === null)) {\r\n        return null;\r\n    }\r\n    if ((srcTileXY.x === neighborTileXY.x) && (srcTileXY.y === neighborTileXY.y)) {\r\n        return null\r\n    }\r\n\r\n    let direction = board.grid.getNeighborTileDirection(srcTileXY, neighborTileXY);\r\n    if (board.wrapMode && (direction === null)) {\r\n        let tileXYArray = board.getNeighborTileXY(srcTileXY, null) as XYType[];\r\n        for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n            let tileXY = tileXYArray[i];\r\n            if ((neighborTileXY.x === tileXY.x) && (neighborTileXY.y === tileXY.y)) {\r\n                direction = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return direction;\r\n}","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetNeighborTileXY = function (\r\n    board: ILogicBoard,\r\n    srcTileXY: XYType,\r\n    directions: number | number[] | string | null = null,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType | XYType[] | null {\r\n\r\n    return board.getTileXYAtDirection(srcTileXY, directions, 1, out);\r\n};","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetNeighborTileXYAtAngle = function (\r\n    borad: ILogicBoard,\r\n    srcTileXY: XYType,\r\n    angle: number,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType | null {\r\n\r\n    let direction = borad.angleSnapToDirection(srcTileXY, angle);\r\n    return borad.getTileXYAtDirection(srcTileXY, direction, 1, out) as XYType;\r\n};","import {\r\n    ILogicBoard,\r\n    XType, YType\r\n} from '../ILogicBoard';\r\n\r\nexport let GetOppositeDirection = function (\r\n    baord: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    direction: number\r\n): number {\r\n\r\n    return baord.grid.getOppositeDirection(tileX, tileY, direction);\r\n}","import {\r\n    ILogicBoard,\r\n    XType, YType, ZType\r\n} from '../ILogicBoard'\r\n\r\nexport let HasBlocker = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    tileZ?: ZType\r\n): boolean {\r\n\r\n    if (tileZ === undefined) {\r\n        // any chess at (tileX, tileY) has blocker\r\n        let chessArray = board.tileXYToChessArray(tileX, tileY);\r\n        for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n            let blocker = board.getChessData(chessArray[i]).blocker;\r\n            if (blocker === true) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n\r\n    } else {\r\n        // chess at (tileX, tileY, tileZ) has blocker\r\n        let chess = board.tileXYZToChess(tileX, tileY, tileZ);\r\n        if (chess === null) {\r\n            return false;\r\n        }\r\n        let blocker = board.getChessData(chess).blocker;\r\n        return (blocker === true);\r\n\r\n    }\r\n}","import {\r\n    ILogicBoard,\r\n    IChess\r\n} from '../ILogicBoard';\r\n\r\nexport let HasChess = function (\r\n    board: ILogicBoard,\r\n    chess: IChess\r\n): boolean {\r\n\r\n    return board.boardData.chessToXYZ.has(chess);\r\n}","import {\r\n    ILogicBoard,\r\n    ZType\r\n} from '../ILogicBoard';\r\n\r\nexport let IsOverlappingPoint = function (\r\n    board: ILogicBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    tileZ?: ZType\r\n): boolean {\r\n\r\n    if (board.infinityMode && (tileZ === undefined)) {\r\n        return true;\r\n    }\r\n\r\n    let out = board.worldXYToTileXY(worldX, worldY, true);\r\n    return board.contains(out.x, out.y, tileZ);\r\n}","import { ILogicBoard } from '../ILogicBoard';\r\n\r\nexport let RemoveAllChess = function (\r\n    board: ILogicBoard,\r\n    destroy: boolean = false,\r\n    fromBoardRemove: boolean = false\r\n): void {\r\n\r\n    let chessArray = board.getAllChess();\r\n    for (let i = 0, cnt = chessArray.length; i < cnt; i++) {\r\n        board.removeChess(chessArray[i], undefined, undefined, undefined, destroy, fromBoardRemove);\r\n    }\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XType, YType, ZType, XYZType\r\n} from '../ILogicBoard';\r\nimport { TileXYZToChess } from '../tileposition/TileXYZToChess';\r\nimport { GetChessData } from '../../chess/GetChessData';\r\n\r\n\r\nexport let RemoveChess = function (\r\n    board: ILogicBoard,\r\n    chess: IChess | null | undefined,\r\n    tileX?: XType,\r\n    tileY?: YType,\r\n    tileZ?: ZType,\r\n    destroy: boolean = false,\r\n    fromBoardRemove: boolean = false\r\n) {\r\n\r\n    if (chess) {\r\n        let tileXYZ = board.chessToTileXYZ(chess) as XYZType;\r\n        if (tileXYZ) {\r\n            tileX = tileXYZ.x;\r\n            tileY = tileXYZ.y;\r\n            tileZ = tileXYZ.z;\r\n        } else {\r\n            // chess is not in this board\r\n            return;\r\n        }\r\n    } else {\r\n        chess = TileXYZToChess(board, tileX, tileY, tileZ);\r\n        if (!chess) {\r\n            // chess is not in this board\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (!fromBoardRemove) {\r\n        board.boardData.removeChess(tileX, tileY, tileZ);\r\n    }\r\n    if (board._isBoard) {\r\n        GetChessData(chess).setBoard(null);\r\n    }\r\n\r\n    if (destroy && chess.destroy) {\r\n        chess.destroy();\r\n    }\r\n}","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let RingToTileXYArray = function (\r\n    board: ILogicBoard,\r\n    centerTileXY: XYType,\r\n    radius: number = 1,\r\n    out: XYType[] = []\r\n): XYType[] {\r\n\r\n    let tileArray = board.grid.ringToTileXYArray(centerTileXY, radius) as XYType[];\r\n    for (let i = 0, cnt = tileArray.length; i < cnt; i++) {\r\n        let tileXY = tileArray[i];\r\n        if (board.contains(tileXY.x, tileXY.y)) {\r\n            out.push(tileXY);\r\n        }\r\n    }\r\n    return out;\r\n}","import {\r\n    ILogicBoard,\r\n    IChess, XYZType\r\n} from '../ILogicBoard';\r\n\r\nexport let SwapChess = function (\r\n    board: ILogicBoard,\r\n    chessA: IChess,\r\n    chessB: IChess,\r\n    align: boolean = true\r\n): void {\r\n\r\n    let tileXYZA = board.chessToTileXYZ(chessA) as XYZType;\r\n    let tileXYZB = board.chessToTileXYZ(chessB) as XYZType;\r\n    if ((tileXYZA == null) || (tileXYZB == null)) {\r\n        return;\r\n    }\r\n    board.removeChess(chessA);\r\n    board.removeChess(chessB);\r\n    board.addChess(chessA, tileXYZB.x, tileXYZB.y, tileXYZB.z, align);\r\n    board.addChess(chessB, tileXYZA.x, tileXYZA.y, tileXYZA.z, align);\r\n};","import {\r\n    ILogicBoard,\r\n    ZType, XYType, IChess\r\n} from '../ILogicBoard';\r\nimport { TileXYZToChess } from './TileXYZToChess';\r\nimport { TileXYToChessArray } from './TileXYToChessArray';\r\n\r\n\r\nexport let TileXYArrayToChessArray = function (\r\n    board: ILogicBoard,\r\n    tileXYArray: XYType[],\r\n    tileZ?: ZType,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let tileZMode = (tileZ != null);\r\n    let tileXY: XYType,\r\n        chess: IChess;\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        tileXY = tileXYArray[i];\r\n        if (tileZMode) {\r\n            chess = TileXYZToChess(board, tileXY.x, tileXY.y, tileZ as ZType);\r\n            if (chess !== null) {\r\n                out.push(chess);\r\n            }\r\n        } else {\r\n            TileXYToChessArray(board, tileXY.x, tileXY.y, out);\r\n        }\r\n    }\r\n    return out;\r\n}","import {\r\n    ILogicBoard,\r\n    ZType,\r\n    IChess\r\n} from '../ILogicBoard';\r\n\r\nexport let TileZToChessArray = function (\r\n    board: ILogicBoard,\r\n    tileZ: ZType,\r\n    out: IChess[] = []\r\n): IChess[] {\r\n\r\n    let chessSet = board.boardData.ZToChessSet.get(tileZ);\r\n    if (chessSet) {\r\n        for (const chess of chessSet) {\r\n            out.push(chess);\r\n        }\r\n    }\r\n    return out;\r\n}","import {\r\n    ILogicBoard,\r\n    XYType, Vec2Type\r\n} from '../ILogicBoard';\r\n\r\nexport let TileXYArrayToWorldXYArray = function (\r\n    board: ILogicBoard,\r\n    tileXYArray: XYType[],\r\n    out: Vec2Type[] = []\r\n): Vec2Type[] {\r\n\r\n    for (let i = 0, cnt = tileXYArray.length; i < cnt; i++) {\r\n        let tileXY = tileXYArray[i];\r\n        out.push(board.tileXYToWorldXY(tileXY.x, tileXY.y));\r\n    }\r\n    return out;\r\n};","import {\r\n    ILogicBoard,\r\n    XType, YType, Vec2Type\r\n} from '../ILogicBoard';\r\n\r\nexport let TileXYToWorldXY = function (\r\n    board: ILogicBoard,\r\n    tileX: XType,\r\n    tileY: YType,\r\n    out?: Vec2Type | true\r\n): Vec2Type {\r\n\r\n    return board.grid.getWorldXY(tileX, tileY, out);\r\n}","import {\r\n    ILogicBoard,\r\n    ZType, IChess\r\n} from '../ILogicBoard';\r\n\r\nexport let WorldXYToChess = function (\r\n    board: ILogicBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    tileZ?: ZType,\r\n    out?: IChess[]\r\n): IChess | IChess[] {\r\n\r\n    let tileXY = board.worldXYToTileXY(worldX, worldY, true);\r\n    if (tileZ !== undefined) {\r\n        return board.tileXYZToChess(tileXY.x, tileXY.y, tileZ)\r\n    } else {\r\n        return board.tileXYToChessArray(tileXY.x, tileXY.y, out);\r\n    }\r\n}","import {\r\n    ILogicBoard,\r\n    XYType\r\n} from '../ILogicBoard';\r\n\r\nexport let WorldXYToTileXY = function (\r\n    board: ILogicBoard,\r\n    worldX: number,\r\n    worldY: number,\r\n    out: XYType | true = { x: 0, y: 0 }\r\n): XYType {\r\n\r\n    return board.grid.getTileXY(worldX, worldY, out);\r\n}","import '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\n\nfunction SetTint(tint, ...children) {\r\n    children.forEach(child => {\r\n        const vertexTint = child.vertexTint;\r\n        vertexTint[0] = tint;\r\n        vertexTint[1] = tint;\r\n        vertexTint[2] = tint;\r\n        vertexTint[3] = tint;\r\n        PackColors(child);\r\n    });\r\n    return children;\r\n}\n\nexport { SetTint };\n","import { GameInstance } from './GameInstance.js';\nimport { GetBanner } from './config/Banner.js';\nimport './renderer/BindingQueue.js';\nimport { GetRenderer } from './config/SetRenderer.js';\nimport './dom/GetElement.js';\nimport { GetParent } from './config/Parent.js';\nimport './config/Scenes.js';\nimport './textures/Frame.js';\nimport './textures/Texture.js';\nimport { Emit } from './events/Emit.js';\nimport { AddToDOM } from './dom/AddToDOM.js';\nimport { DOMContentLoaded } from './dom/DOMContentLoaded.js';\nimport { EventEmitter } from './events/EventEmitter.js';\nimport './events/EventInstance.js';\nimport './events/On.js';\nimport './events/Once.js';\nimport './scenes/CreateSceneRenderData.js';\nimport './scenes/ResetSceneRenderData.js';\nimport './scenes/SceneManagerInstance.js';\nimport { SceneManager } from './scenes/SceneManager.js';\nimport './textures/CreateCanvas.js';\nimport './textures/TextureManagerInstance.js';\nimport { TextureManager } from './textures/TextureManager.js';\n\nclass Game extends EventEmitter {\r\n    constructor(...settings) {\r\n        super();\r\n        this.VERSION = '4.0.0-beta1';\r\n        this.isBooted = false;\r\n        this.isPaused = false;\r\n        this.willUpdate = true;\r\n        this.willRender = true;\r\n        this.lastTick = 0;\r\n        this.elapsed = 0;\r\n        this.frame = 0;\r\n        GameInstance.set(this);\r\n        DOMContentLoaded(() => this.boot(settings));\r\n    }\r\n    boot(settings) {\r\n        settings.forEach(setting => setting());\r\n        const renderer = GetRenderer();\r\n        this.renderer = new renderer();\r\n        this.textureManager = new TextureManager();\r\n        this.sceneManager = new SceneManager();\r\n        const parent = GetParent();\r\n        if (parent) {\r\n            AddToDOM(this.renderer.canvas, parent);\r\n        }\r\n        this.isBooted = true;\r\n        GetBanner();\r\n        Emit(this, 'boot');\r\n        this.lastTick = performance.now();\r\n        this.step(this.lastTick);\r\n    }\r\n    pause() {\r\n        this.isPaused = true;\r\n    }\r\n    resume() {\r\n        this.isPaused = false;\r\n        this.lastTick = performance.now();\r\n    }\r\n    step(time) {\r\n        const delta = time - this.lastTick;\r\n        this.lastTick = time;\r\n        this.elapsed += delta;\r\n        if (!this.isPaused) {\r\n            if (this.willUpdate) {\r\n                this.sceneManager.update(delta, time);\r\n                Emit(this, 'update', delta, time);\r\n            }\r\n            if (this.willRender) {\r\n                this.renderer.render(this.sceneManager.render(this.frame));\r\n            }\r\n        }\r\n        this.frame++;\r\n        GameInstance.setFrame(this.frame);\r\n        GameInstance.setElapsed(this.elapsed);\r\n        requestAnimationFrame(now => this.step(now));\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nexport { Game };\n","class EventEmitter {\r\n    constructor() {\r\n        this.events = new Map();\r\n    }\r\n}\n\nexport { EventEmitter };\n","function DOMContentLoaded(callback) {\r\n    const readyState = document.readyState;\r\n    if (readyState === 'complete' || readyState === 'interactive') {\r\n        callback();\r\n        return;\r\n    }\r\n    const check = () => {\r\n        document.removeEventListener('deviceready', check, true);\r\n        document.removeEventListener('DOMContentLoaded', check, true);\r\n        window.removeEventListener('load', check, true);\r\n        callback();\r\n    };\r\n    if (!document.body) {\r\n        window.setTimeout(check, 20);\r\n    }\r\n    else if (window.hasOwnProperty('cordova')) {\r\n        document.addEventListener('deviceready', check, true);\r\n    }\r\n    else {\r\n        document.addEventListener('DOMContentLoaded', check, true);\r\n        window.addEventListener('load', check, true);\r\n    }\r\n}\n\nexport { DOMContentLoaded };\n","import { GetElement } from './GetElement.js';\n\nfunction AddToDOM(element, parent) {\r\n    const target = GetElement(parent);\r\n    target.appendChild(element);\r\n    return element;\r\n}\n\nexport { AddToDOM };\n","import { GameInstance } from '../GameInstance.js';\n\nlet title = 'Phaser';\r\nlet url = 'https://phaser4.io';\r\nlet color = '#fff';\r\nlet background = 'linear-gradient(#3e0081 40%, #00bcc3)';\r\nfunction Banner(gameTitle = '', gameURL = '', textColor, textBackground) {\r\n    return () => {\r\n        title = gameTitle;\r\n        url = gameURL;\r\n        if (textColor) {\r\n            color = textColor;\r\n        }\r\n        if (textBackground) {\r\n            background = textBackground;\r\n        }\r\n    };\r\n}\r\nfunction GetBanner() {\r\n    if (title !== '') {\r\n        const game = GameInstance.get();\r\n        const version = (title === 'Phaser') ? ' v' + game.VERSION : '';\r\n        console.log(`%c${title}${version}%c ${url}`, `padding: 4px 16px; color: ${color}; background: ${background}`, '');\r\n    }\r\n}\n\nexport { Banner, GetBanner };\n","import './BackgroundColor.js';\nimport './Size.js';\nimport '../renderer/BindingQueue.js';\nimport { SetRenderer } from './SetRenderer.js';\nimport './MaxTextures.js';\nimport './WebGLContext.js';\nimport '../renderer/webgl1/fbo/FBOSystem.js';\nimport '../renderer/webgl1/GL.js';\nimport '../renderer/webgl1/colors/GetRGBArray.js';\nimport '../math/matrix2d-funcs/ExactEquals.js';\nimport '../renderer/webgl1/fbo/CreateFramebuffer.js';\nimport '../renderer/webgl1/textures/CreateGLTexture.js';\nimport '../renderer/webgl1/fbo/DeleteFramebuffer.js';\nimport '../renderer/webgl1/textures/DeleteGLTexture.js';\nimport '../math/pow2/IsSizePowerOfTwo.js';\nimport '../renderer/webgl1/textures/SetGLTextureFilterMode.js';\nimport '../renderer/webgl1/textures/UpdateGLTexture.js';\nimport '../renderer/webgl1/textures/GLTextureBinding.js';\nimport '../renderer/webgl1/buffers/IndexedBuffer.js';\nimport '../textures/Frame.js';\nimport '../textures/Texture.js';\nimport '../renderer/webgl1/WebGLRendererInstance.js';\nimport '../renderer/webgl1/shaders/SingleTextureQuadShader.js';\nimport '../renderer/webgl1/shaders/MultiTextureQuadShader.js';\nimport '../renderer/webgl1/cameras/Ortho.js';\nimport '../renderer/webgl1/shaders/ShaderSystem.js';\nimport '../renderer/webgl1/shaders/CheckShaderMaxIfStatements.js';\nimport '../renderer/webgl1/textures/TextureSystem.js';\nimport { WebGLRenderer as WebGLRenderer$1 } from '../renderer/webgl1/WebGLRenderer.js';\n\nfunction WebGLRenderer() {\r\n    return () => {\r\n        SetRenderer(WebGLRenderer$1);\r\n    };\r\n}\n\nexport { WebGLRenderer };\n","import { GameInstance } from '../GameInstance.js';\nimport './SceneManagerInstance.js';\nimport './GetConfigValue.js';\nimport { Install } from './Install.js';\n\nclass Scene {\r\n    constructor(config) {\r\n        this.game = GameInstance.get();\r\n        this.events = new Map();\r\n        Install(this, config);\r\n    }\r\n}\n\nexport { Scene };\n","import '../../renderer/webgl1/colors/PackColor.js';\nimport { PackColors } from '../../renderer/webgl1/colors/PackColors.js';\n\nfunction SetAlpha(alpha, ...children) {\r\n    children.forEach(child => {\r\n        const vertexAlpha = child.vertexAlpha;\r\n        vertexAlpha[0] = alpha;\r\n        vertexAlpha[1] = alpha;\r\n        vertexAlpha[2] = alpha;\r\n        vertexAlpha[3] = alpha;\r\n        PackColors(child);\r\n    });\r\n    return children;\r\n}\n\nexport { SetAlpha };\n"],"names":["instance","frame","elapsed","GameInstance","game","current","bgColor","_width","_height","_resolution","GetWidth","GetHeight","GetResolution","queue","BindingQueue","texture","push","length","parent","maxTextures","GetMaxTextures","GetElement","target","element","document","getElementById","nodeType","body","GetParent","_scenes","gl","_contextAttributes","alpha","antialias","depth","premultipliedAlpha","FBOSystem","[object Object]","renderer","this","stack","bindFramebuffer","FRAMEBUFFER","viewport","width","height","framebuffer","clear","set","clearColor","COLOR_BUFFER_BIT","pop","len","entry","reset","GL","context","CreateGLTexture","binding","flipY","unpackPremultiplyAlpha","minFilter","magFilter","wrapS","wrapT","generateMipmap","isPOT","source","image","glTexture","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","DeleteGLTexture","isTexture","deleteTexture","GLTextureBinding","config","index","indexCounter","dirtyIndex","LINEAR","CLAMP_TO_EDGE","linear","mode","NEAREST","SetGLTextureFilterMode","UpdateGLTexture","isFramebuffer","deleteFramebuffer","DeleteFramebuffer","IndexedBuffer","batchSize","dataSize","indexSize","vertexElementSize","quadIndexSize","vertexByteSize","quadByteSize","quadElementSize","bufferByteSize","create","ibo","i","data","ArrayBuffer","Uint16Array","vertexViewF32","Float32Array","vertexViewU32","Uint32Array","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","indexBuffer","ELEMENT_ARRAY_BUFFER","STATIC_DRAW","Frame","key","x","y","trimmed","sourceSizeWidth","sourceSizeHeight","updateUVs","pivot","w","h","spriteSourceSizeX","spriteSourceSizeY","spriteSourceSizeWidth","spriteSourceSizeHeight","originX","originY","left","right","top","bottom","child","transform","origin","setExtent","baseTextureWidth","baseTextureHeight","u0","v0","u1","v1","Texture","frames","Map","addFrame","has","firstFrame","get","console","warn","setSize","destroy","WebGLRendererInstance","shaderSource","fragmentShader","vertexShader","SingleTextureQuadShader","attribs","aVertexPosition","aTextureCoord","aTextureId","aTintColor","uniforms","uProjectionMatrix","uCameraMatrix","uTexture","uTime","uResolution","renderToFBO","resolution","buffer","createShaders","count","attachment","COLOR_ATTACHMENT0","createFramebuffer","framebufferTexture2D","CreateFramebuffer","fragmentShaderSource","vertexShaderSource","createShader","FRAGMENT_SHADER","compileShader","failed","message","getShaderInfoLog","error","VERTEX_SHADER","program","createProgram","attachShader","linkProgram","useProgram","Object","keys","location","getAttribLocation","enableVertexAttribArray","getUniformLocation","projectionMatrix","cameraMatrix","textureID","uniformMatrix4fv","uniform1i","textures","textureIndex","uniform1f","performance","now","uniform2f","bindBuffers","stride","vertexAttribPointer","FLOAT","view","subarray","bufferSubData","fbo","add","drawElements","TRIANGLES","UNSIGNED_SHORT","draw","prevCount","MultiTextureQuadShader","super","src","replace","uniform1iv","ShaderSystem","currentShader","stackEntry","shader","currentEntry","singleQuadShader","flush","currentCamera","matrix","success","bind","rebind","flushTotal","fragTemplate","join","GenerateSrc","maxIfs","TextureSystem","startActiveTexture","tempTextures","maxGPUTextures","fragmentSrc","getShaderParameter","COMPILE_STATUS","CheckShaderMaxIfStatements","getParameter","MAX_TEXTURE_IMAGE_UNITS","maxConfigTextures","Math","max","forEach","texturesIndex","tempTexture","Uint8Array","currentActiveTexture","temp","setIndex","TEXTURE1","WebGLRenderer","clearBeforeRender","optimizeRedraw","autoResize","contextLost","setBackgroundColor","canvas","createElement","addEventListener","event","onContextLost","onContextRestored","initContext","shaders","getContext","disable","DEPTH_TEST","CULL_FACE","resize","init","style","toString","near","far","Ortho","preventDefault","color","output","r","g","b","a","GetRGBArray","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","update","renderData","numDirtyFrames","numDirtyCameras","cls","worlds","worldData","camera","renderList","worldTransform","c","d","tx","ty","children","renderNode","node","renderGL","postRenderGL","undefined","Matrix2D","Rectangle","rect","Contains","value","NOOP","Vec2Callback","callback","compareValue","_x","_y","StaticCamera","type","dirtyRender","bounds","world","RemoveChild","currentIndex","indexOf","GetChildIndex","removed","splice","RemoveChildAt","Emit","emitter","args","events","size","listeners","ee","apply","once","delete","SetParent","parentWorld","SetWorld","shift","numChildren","unshift","DepthFirstSearch","AddChild","updateWorld","DIRTY_CONST","RemoveChildrenBetween","beginIndex","endIndex","range","EventInstance","Off","hasContext","hasOnce","listener","On","TypeError","Set","Once","SceneManagerInstance","manager","SceneManager","scenes","sceneIndex","renderResult","gameFrame","numTotalFrames","boot","scene","delta","time","values","results","ResetSceneRenderData","CreateCanvas","TextureManagerInstance","TextureManager","createDefaultTextures","missing","strokeStyle","moveTo","lineTo","stroke","strokeRect","GetVertices","extent","x0","y0","x1","y1","x2","y2","x3","y3","BoundsComponent","entity","fixed","includeChildren","visibleOnly","area","isDirty","min","updateLocal","clearDirty","visible","childBounds","InputComponent","enabled","enabledChildren","hitArea","Vec2","Copy","TransformComponent","passthru","_rotation","local","position","scale","skew","updateExtent","setDirty","rotation","scaleX","scaleY","skewX","skewY","cos","sin","UpdateLocalTransform","gameObject","lt","wt","pa","pb","pc","pd","ptx","pty","UpdateWorldTransform","updateChildren","out","id","GameObject","name","willUpdate","willUpdateChildren","willRender","willRenderChildren","willCacheChildren","dirty","dirtyFrame","input","flag","flag2","postUpdate","reparentChildren","newParent","moved","ReparentChildren","DestroyChildren","Container","_alpha","PackColor","rgb","PackColors","sprite","vertexAlpha","tint","vertexTint","vertexColor","SetFrame","getFrame","setOrigin","hasTexture","vertexData","Sprite","_tint","fill","setTexture","SetTexture","UpdateVertices","preRender","request","offset","U32","BatchTexturedQuad","ctx","save","setTransform","globalAlpha","drawImage","restore","DrawTexturedQuad","CanvasTexture","Text","text","font","fillStyle","splitRegExp","padding","verticalAlign","lineSpacing","backgroundStyle","cornerRadius","textAlign","textBaseline","lineWidth","lineDash","setText","preRenderCallback","lineCap","lineJoin","setLineDash","imageSmoothingEnabled","lines","_text","split","strokeWidth","strokeWidthHalf","clearRect","syncContext","maxWidth","maxHeight","lineMetrics","vAlignAscent","metrics","measureText","averageLineHeight","ceil","abs","actualBoundingBoxAscent","actualBoundingBoxDescent","actualBoundingBoxLeft","actualBoundingBoxRight","ascent","descent","lineHeight","displayWidth","fixedWidth","displayHeight","fixedHeight","canvasWidth","canvasHeight","halfRadius","fillRect","isCenter","isRight","yOffset","line","strokeText","fillText","Array","isArray","updateText","UpdateCachedLayers","cachedLayers","dirtyCamera","layer","HasDirtyChildren","BuildRenderList","entries","WorldDepthFirstSearch","isRenderable","CalculateTotalRenderable","numRendered","numRenderable","forceRefresh","ResetWorldRenderData","BaseWorld","_updateListener","_renderListener","render","_shutdownListener","shutdown","sceneRenderData","worldRenderData","MergeRenderData","RemoveChildren","StaticWorld","Install","sceneManager","firstScene","property","defaultValue","prototype","hasOwnProperty","call","GetConfigValue","GetXYKey","Stack","items","l","arr","globEmptyMapPool","FreeEmptyMap","map","AddChessToZMap","chess","chessMap","prevX","prevY","prevZ","currX","currY","currZ","prevKey","currKey","zMap","newMap","GetEmptyMap","RemoveChessFromZMap","z","globEmptySetPool","FreeEmptySet","AddChessToSet","chessSet","GetEmptySet","RemoveChessFromSet","GetChess","boardData","XYToZMap","GetMaxMapKey","result","Infinity","item","GetMinMapKey","BoardData","chessToXYZ","XToChessSet","YToChessSet","ZToChessSet","_xMax","_xMin","_yMax","_yMin","clearBounds","prevXYZ","AddChess","RemoveChess","HasChess","GetXYZ","xMax","xMin","yMax","yMin","SetBoardWidth","board","infinityMode","SetBoardHeight","TileXYZToChess","tileX","tileY","tileZ","getChess","ChessData","blocker","on","removeChess","tileXYZ","chessToTileXYZ","addChess","direction","blockEdges","dir","GetChessData","rexChess","GridAlign","chessArray","getAllChess","cnt","tileXYToWorldXY","Between","atan2","RAD_TO_DEG","PI","RadToDeg","radians","ShortestBetween","angle1","angle2","difference","floor","zeroTileXY","MirrorMode","ForEachTileXYOrder","RandomInt","random","GetRandomItem","array","startIndex","randomIndex","globTileXY","GetTileXYAtDirection","directions","distance","srcTileXY","parseInt","resultTileXY","isNumberDirection","isNumberDistance","grid","getTileXYAtDirection","getWrapTileXY","allDirections","end","start","step","Wrap","IsEdgeBlocker","PI2","IsAngleInCone","chessA","chessB","face","cone","tileXYA","tileXYB","targetAngle","angleBetween","angle","deltaAngle","halfCone","epsilon","Equal","TileXYToChessArray","globWorldXY","LayoutMode","DirMode","OrthogonalMap","IsometricMap","ReverseDirMap","dirMap","OrthogonalMapIn","IsometricMapIn","StaggerAxis","StaggerIndex","SQRT3","sqrt","cr2cube","col","row","globCube","ODD_R","EVEN_R","ODD_Q","EVEN_Q","cube2cr","globCR","globCubeA","globCubeB","GetWorldXY","hexagon","worldX","worldY","_halfWidth","_halfHeight","DEG_TO_RAD","globPoints","DirectionToDeltaTileXY","DeltaTileXYToDirection","GetParity","parity","hexragon","srcTileX","srcTileY","newCubeX","newCubeY","newCubeZ","cubeXYZ","GetTileXY","q","cube","qr2cube","rx","round","ry","rz","dx","dy","dz","roundcube","Hexagon","radius","cellWidth","cellHeight","staggerAxis","staggerIndex","odd","setType","setDirectionMode","setOriginPosition","setRadius","setCellSize","even","sides","ALLDIR","halfDirections","HALFDIR","tileA","tileB","DirectionBetween","DirectionNormalize","roughMode","GetDistance","tileXY","FillPositionArray","angleOffset","flat","angleRad","halfW","quarterW","halfH","quarterH","GetGridPoints","neighborTileXY","deltaTileXYToDirMap","deltaTileX","deltaTileY","xEntry","GetNeighborTileDirection","GetNeighborTileXY","GetOppositeDirection","isRMode","Mirror","offsetTileX","offsetTileY","offsetX","offsetY","newX","newY","Offset","centerTileXY","j","k","centerCube","cx","cz","cy","RingToTileXYArray","Rotate","_savedOriginX","_savedOriginY","PathMode","NodeManager","createNodeCallback","nodePool","nodes","sn","createNode","pool","gOpenHeap","scoreFunction","content","sinkDown","bubbleUp","n","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","f","Search","astar","startNodeKey","endNodeKey","movingPoints","isPathSearch","isAStartMode","pathMode","isShortestPathMode","astarMode","nodeManager","freeAllNodes","startNode","getNode","endNode","heuristic","closestNode","closerH","currNode","closed","nextNode","nextNodeCost","nextNodes","getNextNodes","getCost","gScore","beenVisited","visited","prevNodes","rescoreElement","GetAStarNodePath","reverse","GetNodePathCallbacks","angleTo","minDeltaAngle","prevNode","diagonal","currLogicDir","logicDirTo","prevLogicDir","straight","AStar","weight","getAllNodes","path","GetNodePath","Shuffle","XYToKey","globXY","AStarNode","baseNode","dist","distanceTo","preNode","pathFinder","xy","KeyToXY","_px","_py","cost","neighborsTileXY","getNeighborTileXY","shuffleNeighbors","neighborNodes","cacheCost","getDistance","AngleBetween","wroldY","getNeighborTileDirection","worldXY","GetPath","endChess","endTileXY","startTileXYZ","setPathMode","getNodePath","PathFinder","costCallback","costCallbackScope","occupiedTest","blockerTest","edgeBlockerTest","setBoard","setCostFunction","setConstCost","setOccupiedTest","setBlockerTest","setEdgeBlockerTest","setCacheCostMode","setWeight","setShuffleNeighborsMode","constCost","scope","contains","hasBlocker","GetCost","startChess","hasChess","startTileX","startTileY","search","nodesMap","nodesList","sort","nodeA","nodeB","snA","snB","FindArea","BLOCKER","isClosest","getClosestNode","FindPath","pathCost","TileXYToCost","GetStyle","CreatePolygonTexture","points","textureManager","DrawCanvasTexture","minX","GetMinProperty","minY","GetMaxProperty","halfLW","beginPath","point","Indent","closePath","halfBound","Direction","parentElement","MyBoard","wrap","inifinity","_isBoard","setGrid","setWrapMode","setInfinityMode","setBoardSize","wrapMode","align","curTileXYZ","GetAngle","neighborAngle","angleToward","AngleSnapToDirection","wrapModeSave","infinityModeSave","AngleToward","getNeighborChessDirection","AreNeighbors","xyz","getXYZ","obj","window","constructor","e","IsPlainObject","isTileXYZ","ChessToTileXYZ","directionBetween","nearToFar","level","ringToTileXYArray","FilledRingToTileXYArray","tileXYArray","maxX","maxY","Fit","order","ForEachTileXY","GetAllChess","tileZArray","isEmpty","kcnt","tileXYZToChess","GetEmptyTileXYArray","getGridPoints","neighborTileZ","tileXYArrayToChessArray","tileXYToChessArray","GetNeighborChess","neighborChess","srcTileXYZ","neighborTileXYZ","GetNeighborChessDirection","borad","angleSnapToDirection","GetNeighborTileXYAtAngle","baord","getOppositeDirection","retryCount","getEmptyTileXYArray","GetRandomEmptyTileXY","GetWrapTileXY","getChessData","HasBlocker","HasEdgeBlocker","savedDirections","deltaDirection","IsDirectionInCone","worldXYToTileXY","IsOverlappingPoint","originTileXY","mirror","fromBoardRemove","RemoveAllChess","tileArray","rotate","tileXYZA","tileXYZB","SwapChess","tileZMode","TileXYArrayToChessArray","TileZToChessArray","TileXYArrayToWorldXYArray","getWorldXY","TileXYToWorldXY","WorldXYSnapToGrid","WorldXYToChess","getTileXY","WorldXYToTileXY","forEachTileXY","tile","SetTint","findPath","settings","VERSION","isBooted","isPaused","lastTick","readyState","check","removeEventListener","setTimeout","DOMContentLoaded","setting","appendChild","AddToDOM","version","log","GetBanner","requestAnimationFrame","WebGLRenderer$1","devicePixelRatio","Size","BackgroundColor","HexagonGrid","strokeGrid","createChess","emptyTileXYArray","emptyTileXY","SetAlpha","concat"],"mappings":"yBAAA,IAAIA,EACAC,EAAQ,EACRC,EAAU,EACd,MAAMC,EACG,IACMH,EAFTG,EAIIC,IACFJ,EAAWI,GALbD,EAOQ,IACCF,EARTE,EAUSE,IACPJ,EAAQI,GAXVF,EAgBWE,IACTH,EAAUG,GCpBlB,IAAIC,EAAU,ECAd,IAAIC,EAAS,IACTC,EAAU,IACVC,EAAc,EAWlB,SAASC,IACL,OAAOH,EAEX,SAASI,IACL,OAAOH,EAEX,SAASI,IACL,OAAOH,ECpBX,MAAMI,EAAQ,GACRC,EACIC,IACFF,EAAMG,KAAKD,IAFbD,EAIG,IACMD,EALTC,EAOK,KACHD,EAAMI,OAAS,GCTvB,IAAIjB,ECAJ,ICEIkB,ECFAC,EAAc,EASlB,SAASC,IACL,OAAOD,ECVX,SAASE,EAAWC,GAChB,IAAIC,EAYJ,OAXID,IACsB,iBAAXA,EACPC,EAAUC,SAASC,eAAeH,GAEX,iBAAXA,GAA2C,IAApBA,EAAOI,WAC1CH,EAAUD,IAGbC,IACDA,EAAUC,SAASG,MAEhBJ,EFHX,SAASK,IACL,OAAOV,EGXX,IAAIW,EAAU,GCAd,ICAIC,EDAAC,EAAqB,CACrBC,OAAO,EACPC,WAAW,EACXC,OAAO,EACPC,oBAAoB,GEJxB,MAAMC,EACFC,YAAYC,GACRC,KAAKC,MAAQ,GACbD,KAAKlC,QAAU,KACfkC,KAAKD,SAAWA,EAEpBD,QACIE,KAAKC,MAAQ,GACbD,KAAKlC,QAAU,KACf,MAAMiC,EAAWC,KAAKD,SAChBR,EAAKQ,EAASR,GACpBA,EAAGW,gBAAgBX,EAAGY,YAAa,MACnCZ,EAAGa,SAAS,EAAG,EAAGL,EAASM,MAAON,EAASO,QAE/CR,IAAIS,EAAaC,GAAQ,EAAMH,EAAQ,EAAGC,EAAS,GAC/CN,KAAKC,MAAMxB,KAAK,CAAE8B,YAAAA,EAAaF,MAAAA,EAAOC,OAAAA,IACtCN,KAAKS,IAAIF,EAAaC,EAAOH,EAAOC,GAExCR,IAAIS,EAAaC,GAAQ,EAAMH,EAAQ,EAAGC,EAAS,GAC/C,MACMf,EADWS,KAAKD,SACFR,GACpBA,EAAGW,gBAAgBX,EAAGY,YAAaI,GAC/BC,IACAjB,EAAGmB,WAAW,EAAG,EAAG,EAAG,GACvBnB,EAAGiB,MAAMjB,EAAGoB,mBAEZN,EAAQ,GACRd,EAAGa,SAAS,EAAG,EAAGC,EAAOC,GAE7BN,KAAKlC,QAAUyC,EAEnBT,MACIE,KAAKC,MAAMW,MACX,MAAMC,EAAMb,KAAKC,MAAMvB,OACvB,GAAImC,EAAM,EAAG,CACT,MAAMC,EAAQd,KAAKC,MAAMY,EAAM,GAC/Bb,KAAKS,IAAIK,EAAMP,aAAa,EAAOO,EAAMT,MAAOS,EAAMR,aAGtDN,KAAKe,QAGbjB,SACI,MAAMP,EAAKS,KAAKD,SAASR,GACzBA,EAAGW,gBAAgBX,EAAGY,YAAaH,KAAKlC,SAE5CgC,UACIE,KAAKC,MAAQ,ID9CrB,MAAMe,EACG,IACMzB,EAFTyB,EAIIC,IACF1B,EAAK0B,GEJb,SAASC,EAAgBC,GACrB,MAAM5B,EAAKyB,IACX,IAAKzB,EACD,OAEJ,MAAMZ,OAAEA,EAAMyC,MAAEA,EAAKC,uBAAEA,EAAsBC,UAAEA,EAASC,UAAEA,EAASC,MAAEA,EAAKC,MAAEA,EAAKC,eAAEA,EAAcC,MAAEA,GAAUR,EACvGS,EAASjD,EAAOkD,MACtB,IAAIxB,EAAQ1B,EAAO0B,MACfC,EAAS3B,EAAO2B,OACpB,MAAMwB,EAAYvC,EAAGwC,gBAqBrB,OApBAxC,EAAGyC,cAAczC,EAAG0C,UACpB1C,EAAG2C,YAAY3C,EAAG4C,WAAYL,GAC9BvC,EAAG6C,YAAY7C,EAAG8C,oBAAqBjB,GACvC7B,EAAG6C,YAAY7C,EAAG+C,+BAAgCjB,GAC9CO,GACArC,EAAGgD,WAAWhD,EAAG4C,WAAY,EAAG5C,EAAGiD,KAAMjD,EAAGiD,KAAMjD,EAAGkD,cAAeb,GACpEvB,EAAQuB,EAAOvB,MACfC,EAASsB,EAAOtB,QAGhBf,EAAGgD,WAAWhD,EAAG4C,WAAY,EAAG5C,EAAGiD,KAAMnC,EAAOC,EAAQ,EAAGf,EAAGiD,KAAMjD,EAAGkD,cAAe,MAE1FlD,EAAGmD,cAAcnD,EAAG4C,WAAY5C,EAAGoD,mBAAoBrB,GACvD/B,EAAGmD,cAAcnD,EAAG4C,WAAY5C,EAAGqD,mBAAoBrB,GACvDhC,EAAGmD,cAAcnD,EAAG4C,WAAY5C,EAAGsD,eAAgBrB,GACnDjC,EAAGmD,cAAcnD,EAAG4C,WAAY5C,EAAGuD,eAAgBrB,GAC/CC,GAAkBC,GAClBpC,EAAGmC,eAAenC,EAAG4C,YAEzBhB,EAAQ3C,QAAUsD,EACXA,EC9BX,SAASiB,EAAgBvE,GACrB,MAAMe,EAAKyB,IACNzB,GAGDA,EAAGyD,UAAUxE,IACbe,EAAG0D,cAAczE,GCAzB,MAAM0E,EACFpD,YAAYnB,EAAQwE,EAAS,IACzBnD,KAAKoD,MAAQ,EACbpD,KAAKqD,cAAgB,EACrBrD,KAAKsD,YAAa,EAClBtD,KAAKqB,wBAAyB,EAC9BrB,KAAKoB,OAAQ,EACbpB,KAAK2B,OAAQ,EACb3B,KAAK0B,gBAAiB,EACtB,MAAMnC,EAAKyB,ICjBnB,IAA0BX,EAAOC,EDkBzBN,KAAKrB,OAASA,EACdqB,KAAK2B,OCnBatB,EDmBY1B,EAAO0B,MCnBZC,EDmBmB3B,EAAO2B,SClBnDD,EAAQ,GAAKC,EAAS,IAGQ,IAAzBD,EAASA,EAAQ,IAA2C,IAA3BC,EAAUA,EAAS,IDgBzD,MAAM9B,QAAEA,EAAU,KAAI+B,YAAEA,EAAc,KAAIc,uBAAEA,GAAyB,EAAIC,UAAEA,EAAY/B,EAAGgE,OAAMhC,UAAEA,EAAYhC,EAAGgE,OAAM/B,MAAEA,EAAQjC,EAAGiE,cAAa/B,MAAEA,EAAQlC,EAAGiE,cAAa9B,eAAEA,EAAiB1B,KAAK2B,MAAKP,MAAEA,GAAQ,GAAU+B,EAC5NnD,KAAKsB,UAAYA,EACjBtB,KAAKuB,UAAYA,EACjBvB,KAAKwB,MAAQA,EACbxB,KAAKyB,MAAQA,EACbzB,KAAK0B,eAAiBA,EACtB1B,KAAKoB,MAAQA,EACbpB,KAAKqB,uBAAyBA,EAC1Bd,IACAP,KAAKO,YAAcA,GAEnB/B,EACAwB,KAAKxB,QAAUA,EAGf0C,EAAgBlB,MAGxBF,UAAU2D,GACFzD,KAAKxB,SErCjB,SAAgCA,EAASiF,GAAS,GAC9C,MAAMlE,EAAKyB,IACXzB,EAAGyC,cAAczC,EAAG0C,UACpB1C,EAAG2C,YAAY3C,EAAG4C,WAAY3D,GAC9B,MAAMkF,EAAO,EAAWnE,EAAGgE,OAAShE,EAAGoE,QACvCpE,EAAGmD,cAAcnD,EAAG4C,WAAY5C,EAAGoD,mBAAoBe,GACvDnE,EAAGmD,cAAcnD,EAAG4C,WAAY5C,EAAGqD,mBAAoBc,GFgC/CE,CAAuB5D,KAAKxB,QAASiF,GAG7C3D,SACI,MAAMtB,EAAUwB,KAAKxB,QAIrB,OAHIA,GACAuE,EAAgBvE,GAEb0C,EAAgBlB,MAE3BF,SAEI,OADgBE,KAAKxB,QGjD7B,SAAyB2C,GACrB,MAAM5B,EAAKyB,IACLY,EAAST,EAAQxC,OAAOkD,MACxBxB,EAAQuB,EAAOvB,MACfC,EAASsB,EAAOtB,OAOtB,OANID,EAAQ,GAAKC,EAAS,IACtBf,EAAGyC,cAAczC,EAAG0C,UACpB1C,EAAG2C,YAAY3C,EAAG4C,WAAYhB,EAAQ3C,SACtCe,EAAG6C,YAAY7C,EAAG8C,oBAAqBlB,EAAQC,OAC/C7B,EAAGgD,WAAWhD,EAAG4C,WAAY,EAAG5C,EAAGiD,KAAMjD,EAAGiD,KAAMjD,EAAGkD,cAAeb,IAEjET,EAAQ3C,QH2CAqF,CAAgB7D,MAHhBkB,EAAgBlB,MAM/BF,SAASsD,GACLpD,KAAKsD,WAAcF,IAAUpD,KAAKoD,MAClCpD,KAAKoD,MAAQA,EAEjBtD,UACIiD,EAAgB/C,KAAKxB,SI9D7B,SAA2B+B,GACvB,MAAMhB,EAAKyB,IACPzB,GAAMA,EAAGuE,cAAcvD,IACvBhB,EAAGwE,kBAAkBxD,GJ4DrByD,CAAkBhE,KAAKO,aACvBP,KAAKrB,OAAS,KACdqB,KAAKxB,QAAU,KACfwB,KAAKO,YAAc,MKlE3B,MAAM0D,EACFnE,YAAYoE,EAAWC,EAAUC,EAAWC,EAAmBC,GAC3DtE,KAAKkE,UAAYA,EACjBlE,KAAKmE,SAAWA,EAChBnE,KAAKoE,UAAYA,EACjBpE,KAAKqE,kBAAoBA,EACzBrE,KAAKsE,cAAgBA,EACrBtE,KAAKuE,eAAiBF,EAAoBF,EAC1CnE,KAAKwE,aAAqC,EAAtBxE,KAAKuE,eACzBvE,KAAKyE,gBAAsC,EAApBJ,EACvBrE,KAAK0E,eAAiBR,EAAYlE,KAAKwE,aACvCxE,KAAK2E,SAET7E,SACI,IAAI8E,EAAM,GACV,IAAK,IAAIC,EAAI,EAAGA,EAAK7E,KAAKkE,UAAYlE,KAAKoE,UAAYS,GAAK7E,KAAKoE,UAC7DQ,EAAInG,KAAKoG,EAAI,EAAGA,EAAI,EAAGA,EAAI,EAAGA,EAAI,EAAGA,EAAI,EAAGA,EAAI,GAEpD7E,KAAK8E,KAAO,IAAIC,YAAY/E,KAAK0E,gBACjC1E,KAAKoD,MAAQ,IAAI4B,YAAYJ,GAC7B5E,KAAKiF,cAAgB,IAAIC,aAAalF,KAAK8E,MAC3C9E,KAAKmF,cAAgB,IAAIC,YAAYpF,KAAK8E,MAC1C,MAAMvF,EAAKyB,IACXhB,KAAKqF,aAAe9F,EAAG+F,eACvB/F,EAAGgG,WAAWhG,EAAGiG,aAAcxF,KAAKqF,cACpC9F,EAAGkG,WAAWlG,EAAGiG,aAAcxF,KAAK8E,KAAMvF,EAAGmG,cAC7C1F,KAAK2F,YAAcpG,EAAG+F,eACtB/F,EAAGgG,WAAWhG,EAAGqG,qBAAsB5F,KAAK2F,aAC5CpG,EAAGkG,WAAWlG,EAAGqG,qBAAsB5F,KAAKoD,MAAO7D,EAAGsG,aACtDtG,EAAGgG,WAAWhG,EAAGiG,aAAc,MAC/BZ,EAAM,GAEV9E,YClCJ,MAAMgG,EACFhG,YAAYtB,EAASuH,EAAKC,EAAGC,EAAG5F,EAAOC,GACnCN,KAAKkG,SAAU,EACflG,KAAKxB,QAAUA,EACfwB,KAAK+F,IAAMA,EACX/F,KAAKgG,EAAIA,EACThG,KAAKiG,EAAIA,EACTjG,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACdN,KAAKmG,gBAAkB9F,EACvBL,KAAKoG,iBAAmB9F,EACxBN,KAAKqG,YAETvG,SAASkG,EAAGC,GACRjG,KAAKsG,MAAQ,CAAEN,EAAAA,EAAGC,EAAAA,GAEtBnG,QAAQO,EAAOC,GACXN,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACdN,KAAKmG,gBAAkB9F,EACvBL,KAAKoG,iBAAmB9F,EACxBN,KAAKqG,YAETvG,cAAcO,EAAOC,GACjBN,KAAKmG,gBAAkB9F,EACvBL,KAAKoG,iBAAmB9F,EAE5BR,QAAQO,EAAOC,EAAQ0F,EAAGC,EAAGM,EAAGC,GAC5BxG,KAAKkG,SAAU,EACflG,KAAKmG,gBAAkB9F,EACvBL,KAAKoG,iBAAmB9F,EACxBN,KAAKyG,kBAAoBT,EACzBhG,KAAK0G,kBAAoBT,EACzBjG,KAAK2G,sBAAwBJ,EAC7BvG,KAAK4G,uBAAyBJ,EAElC1G,UAAU+G,EAASC,GACf,MAAMX,EAAkBnG,KAAKmG,gBACvBC,EAAmBpG,KAAKoG,iBAC9B,IAAIW,EACAC,EACAC,EACAC,EAaJ,OAZIlH,KAAKkG,SACLa,EAAO/G,KAAKyG,kBAAqBI,EAAUV,EAC3Ca,EAAQD,EAAO/G,KAAK2G,sBACpBM,EAAMjH,KAAK0G,kBAAqBI,EAAUV,EAC1Cc,EAASD,EAAMjH,KAAK4G,yBAGpBG,GAAQF,EAAUV,EAClBa,EAAQD,EAAOZ,EACfc,GAAOH,EAAUV,EACjBc,EAASD,EAAMb,GAEZ,CAAEW,KAAAA,EAAMC,MAAAA,EAAOC,IAAAA,EAAKC,OAAAA,GAE/BpH,UAAUqH,GACN,MAAMC,EAAYD,EAAMC,UAClBP,EAAUO,EAAUC,OAAOrB,EAC3Bc,EAAUM,EAAUC,OAAOpB,EAC3BE,EAAkBnG,KAAKmG,gBACvBC,EAAmBpG,KAAKoG,iBAC9B,IAAIJ,EACAC,EACA5F,EACAC,EACAN,KAAKkG,SACLF,EAAIhG,KAAKyG,kBAAqBI,EAAUV,EACxCF,EAAIjG,KAAK0G,kBAAqBI,EAAUV,EACxC/F,EAAQL,KAAK2G,sBACbrG,EAASN,KAAK4G,yBAGdZ,GAAKa,EAAUV,EACfF,GAAKa,EAAUV,EACf/F,EAAQ8F,EACR7F,EAAS8F,GAEbgB,EAAUE,UAAUtB,EAAGC,EAAG5F,EAAOC,GAErCR,YACI,MAAMkG,EAAEA,EAACC,EAAEA,EAAC5F,MAAEA,EAAKC,OAAEA,GAAWN,KAC1BuH,EAAmBvH,KAAKxB,QAAQ6B,MAChCmH,EAAoBxH,KAAKxB,QAAQ8B,OACvCN,KAAKyH,GAAKzB,EAAIuB,EACdvH,KAAK0H,GAAKzB,EAAIuB,EACdxH,KAAK2H,IAAM3B,EAAI3F,GAASkH,EACxBvH,KAAK4H,IAAM3B,EAAI3F,GAAUkH,GCrFjC,MAAMK,EACF/H,YAAY+B,EAAOxB,EAAOC,GACtBN,KAAK+F,IAAM,GACPlE,IACAxB,EAAQwB,EAAMxB,MACdC,EAASuB,EAAMvB,QAEnBN,KAAK6B,MAAQA,EACb7B,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACdN,KAAK8H,OAAS,IAAIC,IAClB/H,KAAK8E,KAAO,GACZ9E,KAAKgI,SAAS,SAAU,EAAG,EAAG3H,EAAOC,GACrC/B,EAAiByB,MAErBF,SAASiG,EAAKC,EAAGC,EAAG5F,EAAOC,GACvB,GAAIN,KAAK8H,OAAOG,IAAIlC,GAChB,OAAO,KAEX,MAAMrI,EAAQ,IAAIoI,EAAM9F,KAAM+F,EAAKC,EAAGC,EAAG5F,EAAOC,GAKhD,OAJAN,KAAK8H,OAAOrH,IAAIsF,EAAKrI,GAChBsC,KAAKkI,YAAsC,WAAxBlI,KAAKkI,WAAWnC,MACpC/F,KAAKkI,WAAaxK,GAEfA,EAEXoC,SAASiG,GACL,IAAKA,EACD,OAAO/F,KAAKkI,WAEZnC,aAAeD,IACfC,EAAMA,EAAIA,KAEd,IAAIrI,EAAQsC,KAAK8H,OAAOK,IAAIpC,GAK5B,OAJKrI,IACD0K,QAAQC,KAAK,kBAAkBtC,GAC/BrI,EAAQsC,KAAKkI,YAEVxK,EAEXoC,QAAQO,EAAOC,GACXN,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACAN,KAAK8H,OAAOK,IAAI,UACxBG,QAAQjI,EAAOC,GAEzBR,UACQE,KAAKmB,SACLnB,KAAKmB,QAAQoH,UAEjBvI,KAAK8H,OAAOtH,QACZR,KAAK8E,KAAO,KACZ9E,KAAK6B,MAAQ,KACb7B,KAAKkI,WAAa,MCxD1B,IAAIzK,EACJ,MAAM+K,EACG,IACM/K,EAFT+K,EAIIzI,IACFtC,EAAWsC,GCUb0I,EAAe,CACjBC,eAAgB,uVAiBhBC,aAAc,uiBA0BlB,MAAMC,EACF9I,YAAYqD,EAAS,IACjBnD,KAAK6I,QAAU,CAAEC,gBAAiB,EAAGC,cAAe,EAAGC,WAAY,EAAGC,WAAY,GAClFjJ,KAAKkJ,SAAW,CAAEC,kBAAmB,EAAGC,cAAe,EAAGC,SAAU,EAAGC,MAAO,EAAGC,YAAa,GAC9FvJ,KAAKwJ,aAAc,EACnBxJ,KAAKD,SAAWyI,IAChB,MAAMtE,UAAEA,EAAY,KAAIC,SAAEA,EAAW,EAACC,UAAEA,EAAY,EAACC,kBAAEA,EAAoB,EAACC,cAAEA,EAAgB,EAACoE,eAAEA,EAAiBD,EAAaC,eAAcC,aAAEA,EAAeF,EAAaE,aAAYtI,MAAEA,EAAQlC,IAAUmC,OAAEA,EAASlC,IAAWqL,WAAEA,EAAapL,IAAemL,YAAEA,GAAc,GAAUrG,EACzRnD,KAAK0J,OAAS,IAAIzF,EAAcC,EAAWC,EAAUC,EAAWC,EAAmBC,GACnFtE,KAAK2J,cAAcjB,EAAgBC,GACnC3I,KAAK4J,MAAQ,EACb5J,KAAKwJ,YAAcA,EACnB,MAAMhL,EAAU,IAAIqJ,EAAQ,KAAMxH,EAAQoJ,EAAYnJ,EAASmJ,GACzDtI,EAAU,IAAI+B,EAAiB1E,GACrCA,EAAQ2C,QAAUA,EAClBA,EAAQZ,YCxEhB,SAA2B/B,EAASqL,GAChC,MAAMtK,EAAKyB,IACN6I,IACDA,EAAatK,EAAGuK,mBAEpB,MAAMvJ,EAAchB,EAAGwK,oBAIvB,OAHAxK,EAAGW,gBAAgBX,EAAGY,YAAaI,GACnChB,EAAGyK,qBAAqBzK,EAAGY,YAAa0J,EAAYtK,EAAG4C,WAAY3D,EAAS,GAC5Ee,EAAGW,gBAAgBX,EAAGY,YAAa,MAC5BI,ED+DmB0J,CAAkB9I,EAAQ3C,SAChDwB,KAAKxB,QAAUA,EACfwB,KAAKO,YAAcY,EAAQZ,YAE/BT,cAAcoK,EAAsBC,GAChC,MAAM5K,EAAKS,KAAKD,SAASR,GACnBmJ,EAAiBnJ,EAAG6K,aAAa7K,EAAG8K,iBAC1C9K,EAAGkJ,aAAaC,EAAgBwB,GAChC3K,EAAG+K,cAAc5B,GACjB,IAAI6B,GAAS,EACTC,EAAUjL,EAAGkL,iBAAiB/B,GAC9B8B,EAAQ9L,OAAS,IACjB6L,GAAS,EACTnC,QAAQsC,MAAMF,IAElB,MAAM7B,EAAepJ,EAAG6K,aAAa7K,EAAGoL,eAQxC,GAPApL,EAAGkJ,aAAaE,EAAcwB,GAC9B5K,EAAG+K,cAAc3B,GACjB6B,EAAUjL,EAAGkL,iBAAiB/B,GAC1B8B,EAAQ9L,OAAS,IACjB6L,GAAS,EACTnC,QAAQsC,MAAMF,IAEdD,EACA,OAEJ,MAAMK,EAAUrL,EAAGsL,gBACnBtL,EAAGuL,aAAaF,EAASjC,GACzBpJ,EAAGuL,aAAaF,EAASlC,GACzBnJ,EAAGwL,YAAYH,GACfrL,EAAGyL,WAAWJ,GACd5K,KAAK4K,QAAUA,EACf,IAAK,MAAM7E,KAAOkF,OAAOC,KAAKlL,KAAK6I,SAAU,CACzC,MAAMsC,EAAW5L,EAAG6L,kBAAkBR,EAAS7E,GAC/CxG,EAAG8L,wBAAwBF,GAC3BnL,KAAK6I,QAAQ9C,GAAOoF,EAExB,IAAK,MAAMpF,KAAOkF,OAAOC,KAAKlL,KAAKkJ,UAC/BlJ,KAAKkJ,SAASnD,GAAOxG,EAAG+L,mBAAmBV,EAAS7E,GAG5DjG,KAAKyL,EAAkBC,EAAcC,GACjC,IAAKzL,KAAK4K,QACN,OAAO,EAEX,MAAM7K,EAAWC,KAAKD,SAChBR,EAAKQ,EAASR,GACd2J,EAAWlJ,KAAKkJ,SAQtB,OAPA3J,EAAGyL,WAAWhL,KAAK4K,SACnBrL,EAAGmM,iBAAiBxC,EAASC,mBAAmB,EAAOoC,GACvDhM,EAAGmM,iBAAiBxC,EAASE,eAAe,EAAOoC,GACnDjM,EAAGoM,UAAUzC,EAASG,SAAUtJ,EAAS6L,SAASC,aAAaJ,IAC/DlM,EAAGuM,UAAU5C,EAASI,MAAOyC,YAAYC,OACzCzM,EAAG0M,UAAU/C,EAASK,YAAaxJ,EAASM,MAAON,EAASO,QAC5DN,KAAKkM,YAAYlM,KAAK0J,OAAO/D,YAAa3F,KAAK0J,OAAOrE,eAC/C,EAEXvF,YAAY6F,EAAaN,GACrB,MAAM9F,EAAKS,KAAKD,SAASR,GACnB4M,EAASnM,KAAK0J,OAAOnF,eACrBsE,EAAU7I,KAAK6I,QACrBtJ,EAAGgG,WAAWhG,EAAGqG,qBAAsBD,GACvCpG,EAAGgG,WAAWhG,EAAGiG,aAAcH,GAC/B9F,EAAG6M,oBAAoBvD,EAAQC,gBAAiB,EAAGvJ,EAAG8M,OAAO,EAAOF,EAAQ,GAC5E5M,EAAG6M,oBAAoBvD,EAAQE,cAAe,EAAGxJ,EAAG8M,OAAO,EAAOF,EAAQ,GAC1E5M,EAAG6M,oBAAoBvD,EAAQG,WAAY,EAAGzJ,EAAG8M,OAAO,EAAOF,EAAQ,IACvE5M,EAAG6M,oBAAoBvD,EAAQI,WAAY,EAAG1J,EAAGkD,eAAe,EAAM0J,EAAQ,IAC9EnM,KAAK4J,MAAQ,EAEjB9J,KAAK8J,GACD,MAAM7J,EAAWC,KAAKD,SAChBR,EAAKQ,EAASR,GACdmK,EAAS1J,KAAK0J,OACpB,GAAIE,IAAUF,EAAOxF,UACjB3E,EAAGkG,WAAWlG,EAAGiG,aAAckE,EAAO5E,KAAMvF,EAAGmG,kBAE9C,CACD,MAAM4G,EAAO5C,EAAOzE,cAAcsH,SAAS,EAAG3C,EAAQF,EAAOjF,iBAC7DlF,EAAGiN,cAAcjN,EAAGiG,aAAc,EAAG8G,GAErCtM,KAAKwJ,aACLzJ,EAAS0M,IAAIC,IAAI1M,KAAKO,aAAa,GAEvChB,EAAGoN,aAAapN,EAAGqN,UAAWhD,EAAQF,EAAOpF,cAAe/E,EAAGsN,eAAgB,GAC3E7M,KAAKwJ,aACLzJ,EAAS0M,IAAI7L,MAGrBd,QACI,MAAM8J,EAAQ5J,KAAK4J,MACnB,OAAc,IAAVA,IAGJ5J,KAAK8M,KAAKlD,GACV5J,KAAK+M,UAAYnD,EACjB5J,KAAK4J,MAAQ,GACN,IErIf,MAAMoD,UAA+BpE,EACjC9I,YAAYqD,EAAS,CAAEuF,eApBJ,6UAqBfuE,MAAM9J,GAEVrD,cAAcoK,EAAsBC,GAChC,MAAMvL,EAAcC,IACpB,IAAIqO,EAAM,GACV,IAAK,IAAIrI,EAAI,EAAGA,EAAIjG,EAAaiG,IACzBA,EAAI,IACJqI,GAAO,aAEPrI,EAAIjG,EAAc,IAClBsO,GAAO,oBAAoBrI,QAE/BqI,GAAO,QACPA,GAAO,oCAAoCrI,sBAC3CqI,GAAO,QAGXhD,GADAA,EAAuBA,EAAqBiD,QAAQ,YAAa,GAAGvO,IACxBuO,QAAQ,cAAeD,GACnED,MAAMtD,cAAcO,EAAsBC,GAE9CrK,KAAKyL,EAAkBC,GACnB,IAAKxL,KAAK4K,QACN,OAAO,EAEX,MAAM7K,EAAWC,KAAKD,SAChBR,EAAKQ,EAASR,GACd2J,EAAWlJ,KAAKkJ,SAQtB,OAPA3J,EAAGyL,WAAWhL,KAAK4K,SACnBrL,EAAGmM,iBAAiBxC,EAASC,mBAAmB,EAAOoC,GACvDhM,EAAGmM,iBAAiBxC,EAASE,eAAe,EAAOoC,GACnDjM,EAAG6N,WAAWlE,EAASG,SAAUtJ,EAAS6L,SAASC,cACnDtM,EAAGuM,UAAU5C,EAASI,MAAOyC,YAAYC,OACzCzM,EAAG0M,UAAU/C,EAASK,YAAaxJ,EAASM,MAAON,EAASO,QAC5DN,KAAKkM,YAAYlM,KAAK0J,OAAO/D,YAAa3F,KAAK0J,OAAOrE,eAC/C,GCxDf,MAAMgI,EACFvN,YAAYC,EAAUuN,GAClBtN,KAAKD,SAAWA,EAChB,MAAMwN,EAAa,CACfC,OAAQ,IAAIF,GAEhBtN,KAAKC,MAAQ,CAACsN,GACdvN,KAAKyN,aAAeF,EACpBvN,KAAKlC,QAAUyP,EAAWC,OAC1BxN,KAAK0N,iBAAmB,IAAI9E,EAEhC9I,IAAI0N,EAAQ/B,GACR,MAAM8B,EAAa,CAAEC,OAAAA,EAAQ/B,UAAAA,GAE7B,OADAzL,KAAKC,MAAMxB,KAAK8O,GACTA,EAEXzN,IAAI0N,EAAQ/B,GACRzL,KAAK2N,QACL,MAAM5N,EAAWC,KAAKD,SAChBwL,EAAmBxL,EAASwL,iBAC5BC,EAAezL,EAAS6N,cAAcC,OACtCC,EAAUN,EAAOO,KAAKxC,EAAkBC,EAAcC,GAC5D,GAAIqC,EAAS,CACT,MAAMhN,EAAQd,KAAK0M,IAAIc,EAAQ/B,GAC/BzL,KAAKyN,aAAe3M,EACpBd,KAAKlC,QAAU0P,EAEnB,OAAOM,EAEXhO,WAAW2L,GACPzL,KAAKS,IAAIT,KAAK0N,iBAAkBjC,GAEpC3L,MACIE,KAAK2N,QACL,MAAM1N,EAAQD,KAAKC,MACfA,EAAMvB,OAAS,GACfuB,EAAMW,MAEVZ,KAAKyN,aAAexN,EAAMA,EAAMvB,OAAS,GACzCsB,KAAKlC,QAAUkC,KAAKyN,aAAaD,OAErC1N,QACIE,KAAKY,MACLZ,KAAKgO,SAETlO,QACI,QAAIE,KAAKlC,QAAQ6P,UACb3N,KAAKD,SAASkO,cACP,GAIfnO,SACI,MAAMC,EAAWC,KAAKD,SAChBwL,EAAmBxL,EAASwL,iBAC5BC,EAAezL,EAAS6N,cAAcC,OACtC/P,EAAUkC,KAAKyN,aACrB3P,EAAQ0P,OAAOO,KAAKxC,EAAkBC,EAAc1N,EAAQ2N,WAEhE3L,eACIE,KAAKY,MACLZ,KAAKgO,SAETlO,SAEAA,YClFJ,MAAMoO,EAAe,CACjB,2BACA,mBACA,oBACA,YACA,4BACA,KACFC,KAAK,MACP,SAASC,EAAYC,GACjB,IAAInB,EAAM,GACV,IAAK,IAAIrI,EAAI,EAAGA,EAAIwJ,IAAUxJ,EACtBA,EAAI,IACJqI,GAAO,WAEPrI,EAAIwJ,EAAS,IACbnB,GAAO,cAAcrI,UAG7B,OAAOqI,ECNX,MAAMoB,EACFxO,YAAYC,GACRC,KAAKuO,mBAAqB,EAC1BvO,KAAKD,SAAWA,EAChBC,KAAKwO,aAAe,GACpBxO,KAAK6L,aAAe,GAExB/L,OACI,MAAMP,EAAKS,KAAKD,SAASR,GACzB,IAAIkP,EDDZ,SAAoCJ,EAAQ9O,GACxC,MAAMiO,EAASjO,EAAG6K,aAAa7K,EAAG8K,iBAClC,OAAa,CACT,MAAMqE,EAAcR,EAAaf,QAAQ,cAAeiB,EAAYC,IAGpE,GAFA9O,EAAGkJ,aAAa+E,EAAQkB,GACxBnP,EAAG+K,cAAckD,GACZjO,EAAGoP,mBAAmBnB,EAAQjO,EAAGqP,gBAIlC,MAHAP,EAAUA,EAAS,EAAK,EAMhC,OAAOA,ECZkBQ,CAA2BtP,EAAGuP,aAAavP,EAAGwP,yBAA0BxP,GAC7F,MAAMyP,EAAoBnQ,IACA,IAAtBmQ,GAA4BA,EAAoB,GAAKA,EAAoBP,EtBhBjF7P,EsBiBuB6P,EAEVO,EAAoB,GAAKA,EAAoBP,IAClDA,EAAiBQ,KAAKC,IAAI,EAAGF,IAEjC,MAAMR,EAAexO,KAAKwO,aACtBA,EAAa9P,QACb8P,EAAaW,QAAQ3Q,IACjBe,EAAG0D,cAAczE,KAGzB,MAAM4E,EAAQ,GACd,IAAK,IAAIgM,EAAgB,EAAGA,EAAgBX,EAAgBW,IAAiB,CACzE,MAAMC,EAAc9P,EAAGwC,gBACvBxC,EAAGyC,cAAczC,EAAG0C,SAAWmN,GAC/B7P,EAAG2C,YAAY3C,EAAG4C,WAAYkN,GAC9B9P,EAAGgD,WAAWhD,EAAG4C,WAAY,EAAG5C,EAAGiD,KAAM,EAAG,EAAG,EAAGjD,EAAGiD,KAAMjD,EAAGkD,cAAe,IAAI6M,WAAW,CAAC,EAAG,EAAG,IAAK,OACxGd,EAAaY,GAAiBC,EAC9BjM,EAAM3E,KAAK2Q,GAEfpP,KAAKpB,YAAc6P,EACnBzO,KAAK6L,aAAezI,EACpBpD,KAAKuP,qBAAuB,EAEhCzP,SACI,MAAMxB,EAAQC,IACd,IAAK,IAAIsG,EAAI,EAAGA,EAAIvG,EAAMI,OAAQmG,IAAK,CACnC,MAAMrG,EAAUF,EAAMuG,GACjBrG,EAAQ2C,UACT3C,EAAQ2C,QAAU,IAAI+B,EAAiB1E,IAG/CD,IAEJuB,QACI,MAAMP,EAAKS,KAAKD,SAASR,GACnBiQ,EAAOxP,KAAKwO,aAClB,IAAK,IAAI3J,EAAI,EAAGA,EAAI2K,EAAK9Q,OAAQmG,IAC7BtF,EAAGyC,cAAczC,EAAG0C,SAAW4C,GAC/BtF,EAAG2C,YAAY3C,EAAG4C,WAAYqN,EAAK3K,IAEvC7E,KAAKuP,qBAAuB,EAC5BvP,KAAKuO,qBAETzO,KAAKtB,EAAS4E,EAAQ,GAClB,MAAM7D,EAAKS,KAAKD,SAASR,GACnB4B,EAAU3C,EAAQ2C,QACxBA,EAAQsO,SAASrM,GACjB7D,EAAGyC,cAAczC,EAAG0C,SAAWmB,GAC/B7D,EAAG2C,YAAY3C,EAAG4C,WAAYhB,EAAQ3C,SAE1CsB,OAAOsD,EAAQ,GACX,MAAM7D,EAAKS,KAAKD,SAASR,GACzBA,EAAGyC,cAAczC,EAAG0C,SAAWmB,GAC/B7D,EAAG2C,YAAY3C,EAAG4C,WAAYnC,KAAKwO,aAAapL,IAC5CA,EAAQ,GACRpD,KAAKuO,qBAGbzO,QAAQtB,GACJ,MAAMe,EAAKS,KAAKD,SAASR,GACnB4B,EAAU3C,EAAQ2C,QAClBoO,EAAuBvP,KAAKuP,qBAClC,QAAIpO,EAAQkC,cAAgBrD,KAAKuO,sBAGjCpN,EAAQkC,aAAerD,KAAKuO,mBACxBgB,EAAuBvP,KAAKpB,aAC5BuC,EAAQsO,SAASF,GACjBhQ,EAAGyC,cAAczC,EAAG0C,SAAWsN,GAC/BhQ,EAAG2C,YAAY3C,EAAG4C,WAAYhB,EAAQ3C,SACtCwB,KAAKuP,yBAGLvP,KAAKD,SAAS4N,QACd3N,KAAKuO,qBACLpN,EAAQkC,aAAerD,KAAKuO,mBAC5BpN,EAAQsO,SAAS,GACjBlQ,EAAGyC,cAAczC,EAAGmQ,UACpBnQ,EAAG2C,YAAY3C,EAAG4C,WAAYhB,EAAQ3C,SACtCwB,KAAKuP,qBAAuB,IAEzB,IC9Ef,MAAMI,EACF7P,cACIE,KAAKU,WAAa,CAAC,EAAG,EAAG,EAAG,GAC5BV,KAAKiO,WAAa,EAClBjO,KAAK4P,mBAAoB,EACzB5P,KAAK6P,gBAAiB,EACtB7P,KAAK8P,YAAa,EAClB9P,KAAK+P,aAAc,EACnB/P,KAAK4N,cAAgB,KACrB5N,KAAKK,MAAQlC,IACb6B,KAAKM,OAASlC,IACd4B,KAAKyJ,WAAapL,IAClB2B,KAAKgQ,mB7BjCFjS,G6BkCH,MAAMkS,EAAShR,SAASiR,cAAc,UACtCD,EAAOE,iBAAiB,mBAAqBC,GAAUpQ,KAAKqQ,cAAcD,IAAQ,GAClFH,EAAOE,iBAAiB,uBAAwB,IAAMnQ,KAAKsQ,qBAAqB,GAChFtQ,KAAKiQ,OAASA,EACdjQ,KAAKyM,IAAM,IAAI5M,EAAUG,MACzBA,KAAK4L,SAAW,IAAI0C,EAActO,MAClCA,KAAKuQ,cACL/H,EAA0BxI,MAC1BA,KAAKwQ,QAAU,IAAInD,EAAarN,KAAMgN,GAE1ClN,cACI,MAAMP,EAAKS,KAAKiQ,OAAOQ,WAAW,QpBxC/BjR,GoByCHwB,EAAOzB,GACPS,KAAKT,GAAKA,EACVA,EAAGmR,QAAQnR,EAAGoR,YACdpR,EAAGmR,QAAQnR,EAAGqR,WACd5Q,KAAK6Q,OAAO7Q,KAAKK,MAAOL,KAAKM,OAAQN,KAAKyJ,YAC1CzJ,KAAK4L,SAASkF,OAElBhR,OAAOO,EAAOC,EAAQmJ,EAAa,GAC/BzJ,KAAKK,MAAQA,EAAQoJ,EACrBzJ,KAAKM,OAASA,EAASmJ,EACvBzJ,KAAKyJ,WAAaA,EAClB,MAAMwG,EAASjQ,KAAKiQ,OACpBA,EAAO5P,MAAQL,KAAKK,MACpB4P,EAAO3P,OAASN,KAAKM,OACjBN,KAAK8P,aACLG,EAAOc,MAAM1Q,OAASL,KAAKK,MAAQoJ,GAAYuH,WAAa,KAC5Df,EAAOc,MAAMzQ,QAAUN,KAAKM,OAASmJ,GAAYuH,WAAa,MAElEhR,KAAKT,GAAGa,SAAS,EAAG,EAAGJ,KAAKK,MAAOL,KAAKM,QACxCN,KAAKuL,iBCxEb,SAAelL,EAAOC,EAAQ2Q,GAAO,EAAIC,EAAM,GAI3C,OAAO,IAAIhM,aAAa,CAHN,GAAK7E,GAAV,EAGiB,EAAG,EAAG,EAAG,EAFrB,EAAIC,GAAT,EAEkC,EAAG,EAAG,EAAG,EADvC,GAAK2Q,EAAOC,GAAjB,EACoD,GAAI,EAAG,EAAG,EAAG,IDoEjDC,CAAM9Q,EAAOC,GAEzCR,cAAcsQ,GACVA,EAAMgB,iBACNpR,KAAK+P,aAAc,EAEvBjQ,oBACIE,KAAK+P,aAAc,EACnB/P,KAAKuQ,cAETzQ,mBAAmBuR,GAEf,OEpFR,SAAqBA,EAAOC,EAAS,IACjC,MAAMC,EAAIF,GAAS,GAAK,IAClBG,EAAIH,GAAS,EAAI,IACjBI,EAAY,IAARJ,EACJK,EAAKL,EAAQ,SAAYA,IAAU,GAAK,IAC9CC,EAAO,GAAKC,EAAI,IAChBD,EAAO,GAAKE,EAAI,IAChBF,EAAO,GAAKG,EAAI,IAChBH,EAAO,GAAKI,EAAI,IF2EZC,CAAYN,EAAOrR,KAAKU,YACjBV,KAEXF,MAAMS,EAAc,KAAMF,EAAQL,KAAKK,MAAOC,EAASN,KAAKM,QACxD,MAAMf,EAAKS,KAAKT,GAChBA,EAAGW,gBAAgBX,EAAGY,YAAaI,GACnChB,EAAGa,SAAS,EAAG,EAAGC,EAAOC,GACzBf,EAAGqS,OAAOrS,EAAGsS,OACbtS,EAAGuS,UAAUvS,EAAGwS,IAAKxS,EAAGyS,qBACxBhS,KAAKiO,WAAa,EAClBjO,KAAK4N,cAAgB,KACrB5N,KAAK4L,SAASqG,SAElBnS,OAAOoS,GACH,GAAIlS,KAAK+P,YACL,OAGJ,GADA/P,KAAKe,QACDf,KAAK6P,gBAAgD,IAA9BqC,EAAWC,gBAAuD,IAA/BD,EAAWE,gBACrE,OAEJ,MAAM7S,EAAKS,KAAKT,GAChB,GAAIS,KAAK4P,kBAAmB,CACxB,MAAMyC,EAAMrS,KAAKU,WACjBnB,EAAGmB,WAAW2R,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAC1C9S,EAAGiB,MAAMjB,EAAGoB,kBAEhB,MAAM2R,EAASJ,EAAWK,UAC1B,IAAK,IAAI1N,EAAI,EAAGA,EAAIyN,EAAO5T,OAAQmG,IAAK,CACpC,MAAM2N,OAAEA,EAAMC,WAAEA,GAAeH,EAAOzN,GACjC7E,KAAK4N,gBGjHD8D,EHiH+Bc,EAAOE,eGjHnCjB,EHiHmDzR,KAAK4N,cAAc8E,eGhHlFhB,EAAEA,IAAMD,EAAEC,GACdA,EAAED,IAAMA,EAAEA,GACVC,EAAEiB,IAAMlB,EAAEkB,GACVjB,EAAEkB,IAAMnB,EAAEmB,GACVlB,EAAEmB,KAAOpB,EAAEoB,IACXnB,EAAEoB,KAAOrB,EAAEqB,MH4GH9S,KAAK2N,QACL3N,KAAK4N,cAAgB4E,EACrBxS,KAAKwQ,QAAQxC,UAEjByE,EAAWtD,QAAQrO,IACXA,EAAMiS,SAASrU,OACfsB,KAAKgT,WAAWlS,GAGhBA,EAAMmS,KAAKC,SAASlT,QG3HxC,IAAqB0R,EAAGD,EH+HhBzR,KAAK2N,QAET7N,WAAWgB,GACPA,EAAMmS,KAAKC,SAASlT,MACpBc,EAAMiS,SAAS5D,QAAQhI,IACfA,EAAM4L,SAASrU,OAAS,EACxBsB,KAAKgT,WAAW7L,GAGhBA,EAAM8L,KAAKC,SAASlT,QAG5Bc,EAAMmS,KAAKE,aAAanT,MAE5BF,QACIE,KAAKwQ,QAAQ7C,QAEjB7N,UACI0I,OAA0B4K,IIjJlC,MAAMC,EACFvT,YAAY4R,EAAI,EAAGD,EAAI,EAAGkB,EAAI,EAAGC,EAAI,EAAGC,EAAK,EAAGC,EAAK,GACjD9S,KAAKS,IAAIiR,EAAGD,EAAGkB,EAAGC,EAAGC,EAAIC,GAE7BhT,IAAI4R,EAAI,EAAGD,EAAI,EAAGkB,EAAI,EAAGC,EAAI,EAAGC,EAAK,EAAGC,EAAK,GAOzC,OANA9S,KAAK0R,EAAIA,EACT1R,KAAKyR,EAAIA,EACTzR,KAAK2S,EAAIA,EACT3S,KAAK4S,EAAIA,EACT5S,KAAK6S,GAAKA,EACV7S,KAAK8S,GAAKA,EACH9S,KAEXF,WACI,OAAOE,KAAKS,MAEhBX,UACI,MAAO,CAACE,KAAK0R,EAAG1R,KAAKyR,EAAGzR,KAAK2S,EAAG3S,KAAK4S,EAAG5S,KAAK6S,GAAI7S,KAAK8S,IAE1DhT,UAAUoN,GACN,OAAOlN,KAAKS,IAAIyM,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIA,EAAI,KClBpE,MAAMoG,EACFxT,YAAYkG,EAAI,EAAGC,EAAI,EAAG5F,EAAQ,EAAGC,EAAS,GAC1CN,KAAKS,IAAIuF,EAAGC,EAAG5F,EAAOC,GAE1BR,IAAIkG,EAAI,EAAGC,EAAI,EAAG5F,EAAQ,EAAGC,EAAS,GAKlC,OAJAN,KAAKgG,EAAIA,EACThG,KAAKiG,EAAIA,EACTjG,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACPN,KAEXF,SAASkG,EAAGC,GACR,OCdR,SAAkBsN,EAAMvN,EAAGC,GACvB,QAAIsN,EAAKlT,OAAS,GAAKkT,EAAKjT,QAAU,KAG9BiT,EAAKvN,GAAKA,GAAKuN,EAAKvN,EAAIuN,EAAKlT,OAAS2F,GAAKuN,EAAKtN,GAAKA,GAAKsN,EAAKtN,EAAIsN,EAAKjT,QAAU2F,GDU/EuN,CAASxT,KAAMgG,EAAGC,GAE7Be,UAAUyM,GACFA,GAASzT,KAAKgG,EACdhG,KAAKK,MAAQ,EAGbL,KAAKK,MAAQoT,EAAQzT,KAAKgG,EAGlCgB,YACI,OAAOhH,KAAKgG,EAAIhG,KAAKK,MAEzB6G,WAAWuM,GACHA,GAASzT,KAAKiG,EACdjG,KAAKM,OAAS,EAGdN,KAAKM,OAASmT,EAAQzT,KAAKiG,EAGnCiB,aACI,OAAOlH,KAAKiG,EAAIjG,KAAKM,QEpC7B,SAASoT,KCET,MAAMC,EACF7T,YAAY8T,EAAU5N,EAAI,EAAGC,EAAI,EAAG4N,GAAe,GAC/C7T,KAAK6T,cAAe,EACpB7T,KAAK8T,GAAK9N,EACVhG,KAAK+T,GAAK9N,EACVjG,KAAK4T,SAAWA,EAChB5T,KAAK6T,aAAeA,EAExB/T,IAAIkG,EAAI,EAAGC,EAAI,GAIX,OAHAjG,KAAK8T,GAAK9N,EACVhG,KAAK+T,GAAK9N,EACVjG,KAAK4T,SAAS5T,MACPA,KAEXF,UACIE,KAAK4T,SAAWF,EAEpB1N,MAAMyN,KACGzT,KAAK6T,cAAiB7T,KAAK6T,cAAgBJ,IAAUzT,KAAK8T,MAC3D9T,KAAK8T,GAAKL,EACVzT,KAAK4T,SAAS5T,OAGtBgG,QACI,OAAOhG,KAAK8T,GAEhB7N,MAAMwN,KACGzT,KAAK6T,cAAiB7T,KAAK6T,cAAgBJ,IAAUzT,KAAK8T,MAC3D9T,KAAK+T,GAAKN,EACVzT,KAAK4T,SAAS5T,OAGtBiG,QACI,OAAOjG,KAAK+T,IC9BpB,MAAMC,EACFlU,cACIE,KAAKiU,KAAO,eACZjU,KAAKkU,aAAc,EACnB,MAAMrW,EAAOD,IACboC,KAAKD,SAAWlC,EAAKkC,SACrBC,KAAK6N,OAAS,IAAI3I,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC7ElF,KAAKmU,OAAS,IAAIb,EAClBtT,KAAK0S,eAAiB,IAAIW,EAC1BrT,KAAKe,QAETjB,QACI,MAAMO,EAAQL,KAAKD,SAASM,MACtBC,EAASN,KAAKD,SAASO,OAC7BN,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACdN,KAAKmU,OAAO1T,IAAI,EAAG,EAAGJ,EAAOC,GAEjCR,UACIE,KAAKoU,MAAQ,KACbpU,KAAK0S,eAAiB,KACtB1S,KAAKD,SAAW,KAChBC,KAAK6N,OAAS,KACd7N,KAAKmU,OAAS,MCzBtB,SAASE,EAAY1V,EAAQwI,GACzB,MAAMmN,ECJV,SAAuB3V,EAAQwI,GAC3B,OAAOxI,EAAOoU,SAASwB,QAAQpN,GDGVqN,CAAc7V,EAAQwI,GAI3C,OAHImN,GAAgB,GELxB,SAAuB3V,EAAQyE,GAC3B,MAAM2P,EAAWpU,EAAOoU,SACxB,IAAI5L,EACJ,GAAI/D,GAAS,GAAKA,EAAQ2P,EAASrU,OAAQ,CACvC,MAAM+V,EAAU1B,EAAS2B,OAAOtR,EAAO,GACnCqR,EAAQ,KACRtN,EAAQsN,EAAQ,GAChBtN,EAAMxI,OAAS,OFDnBgW,CAAchW,EAAQ2V,GAEnBnN,EGRX,SAASyN,GAAKC,EAASzE,KAAU0E,GAC7B,GAA4B,IAAxBD,EAAQE,OAAOC,OAAeH,EAAQE,OAAO9M,IAAImI,GACjD,OAAO,EAEX,MAAM6E,EAAYJ,EAAQE,OAAO5M,IAAIiI,GACrC,IAAK,MAAM8E,KAAMD,EACbC,EAAGtB,SAASuB,MAAMD,EAAGjU,QAAS6T,GAC1BI,EAAGE,MACHH,EAAUI,OAAOH,GAMzB,OAHuB,IAAnBD,EAAUD,MACVH,EAAQE,OAAOM,OAAOjF,IAEnB,ECLX,SAASkF,GAAU3W,KAAWoU,GAC1BA,EAAS5D,QAAQhI,IACTA,EAAMxI,QACN0V,EAAYlN,EAAMxI,OAAQwI,GAE9BA,EAAMxI,OAASA,IAEnB,MAAM4W,EAAc5W,EAAOyV,MAI3B,OAHImB,GCbR,SAAkBnB,KAAUrB,GACxBA,EAAS5D,QAAQhI,IACTA,EAAMiN,QACNQ,GAAKzN,EAAMiN,MCPO,mBDOuBjN,EAAOA,EAAMiN,OACtDQ,GAAKzN,ECRa,mBDQiBA,EAAOA,EAAMiN,QAEpDjN,EAAMiN,MAAQA,EACdQ,GAAKR,EEXa,eFWajN,EAAOiN,GACtCQ,GAAKzN,EEZa,eFYaA,EAAOiN,KDMtCoB,CAASD,KIlBjB,SAA0B5W,GACtB,MAAMsB,EAAQ,CAACtB,GACT2S,EAAS,GACf,KAAOrR,EAAMvB,OAAS,GAAG,CACrB,MAAMuU,EAAOhT,EAAMwV,QACnBnE,EAAO7S,KAAKwU,GACZ,MAAMyC,EAAczC,EAAKyC,YACzB,GAAIA,EAAc,EACd,IAAK,IAAI7Q,EAAI6Q,EAAc,EAAG7Q,GAAK,EAAGA,IAClC5E,EAAM0V,QAAQ1C,EAAKF,SAASlO,IAKxC,OADAyM,EAAOmE,QACAnE,EJIsBsE,CAAiBjX,IAEvCoU,EKVX,SAAS8C,GAASlX,EAAQwI,GAItB,OAHAxI,EAAOoU,SAAStU,KAAK0I,GACrBmO,GAAU3W,EAAQwI,GAClBA,EAAMC,UAAU0O,cACT3O,ECdX,MAAM4O,GAES,EAFTA,GAIW,EAJXA,GAMM,GANNA,GAOM,GAPNA,GAQO,GARPA,GAUK,IAVLA,GAYO,GCZb,SAASC,GAAsBrX,EAAQsX,EAAa,EAAGC,GACnD,MAAMnD,EAAWpU,EAAOoU,cACPK,IAAb8C,IACAA,EAAWnD,EAASrU,QAExB,MAAMyX,EAAQD,EAAWD,EACzB,GAAIE,EAAQ,GAAKA,GAASD,EAAU,CAChC,MAAMzB,EAAU1B,EAAS2B,OAAOuB,EAAYE,GAI5C,OAHA1B,EAAQtF,QAAQhI,IACZA,EAAMxI,OAAS,OAEZ8V,EAGP,MAAO,GCdf,MAAM2B,GACFtW,YAAY8T,EAAU3S,EAASmU,GAAO,GAClCpV,KAAK4T,SAAWA,EAChB5T,KAAKiB,QAAUA,EACfjB,KAAKoV,KAAOA,GCFpB,SAASiB,GAAIxB,EAASzE,EAAOwD,EAAU3S,EAASmU,GAC5C,MAAML,EAASF,EAAQE,OACjBE,EAAYF,EAAO5M,IAAIiI,GAC7B,GAAKwD,EAGA,GAAIA,aAAoBwC,GACzBnB,EAAUI,OAAOzB,OAEhB,CACD,MAAM0C,GAAcrV,EACdsV,OAAoBnD,IAATgC,EACjB,IAAK,MAAMoB,KAAYvB,EACduB,EAAS5C,WAAaA,GACtB0C,GAAcE,EAASvV,UAAYA,GACnCsV,GAAWC,EAASpB,OAASA,GAC9BH,EAAUI,OAAOmB,QAZzBzB,EAAOM,OAAOjF,GAmBlB,OAHuB,IAAnB6E,EAAUD,MACVD,EAAOM,OAAOjF,GAEXyE,ECvBX,SAAS4B,GAAG5B,EAASzE,EAAOwD,EAAU3S,EAAU4T,EAASO,GAAO,GAC5D,GAAwB,mBAAbxB,EACP,MAAM,IAAI8C,UAAU,2BAExB,MAAMF,EAAW,IAAIJ,GAAcxC,EAAU3S,EAASmU,GAChDH,EAAYJ,EAAQE,OAAO5M,IAAIiI,GAOrC,OANK6E,EAIDA,EAAUvI,IAAI8J,GAHd3B,EAAQE,OAAOtU,IAAI2P,EAAO,IAAIuG,IAAI,CAACH,KAKhCA,ECXX,SAASI,GAAK/B,EAASzE,EAAOwD,EAAU3S,EAAU4T,GAC9C,OAAO4B,GAAG5B,EAASzE,EAAOwD,EAAU3S,GAAS,GCJjD,IAAIxD,GACJ,MAAMoZ,GACG,IACMpZ,GAFToZ,GAIIC,IACFrZ,GAAWqZ,GCInB,MAAMC,GACFjX,cACIE,KAAKgX,OAAS,IAAIjP,IAClB/H,KAAKiX,WAAa,EAClBjX,KAAK2N,OAAQ,EACb3N,KAAKkX,aCdF,CACHC,UAAW,EACXC,eAAgB,EAChBjF,eAAgB,EAChBC,gBAAiB,EACjBG,UAAW,IDUXvS,KAAKnC,KAAOD,IACZiZ,GAAyB7W,MACzB4W,GAAK5W,KAAKnC,KAAM,OAAQ,IAAMmC,KAAKqX,QAEvCvX,OhDbOR,EgDcS6P,QAAQmI,GAAS,IAAIA,GAErCxX,OAAOyX,EAAOC,GACV,IAAK,MAAMF,KAAStX,KAAKgX,OAAOS,SAC5B7C,GAAK0C,EAAO,SAAUC,EAAOC,GAGrC1X,OAAOqX,GACH,MAAMO,EAAU1X,KAAKkX,cE7B7B,SAA8BhF,EAAYiF,EAAY,GAClDjF,EAAWiF,UAAYA,EACvBjF,EAAWkF,eAAiB,EAC5BlF,EAAWC,eAAiB,EAC5BD,EAAWE,gBAAkB,EAC7BF,EAAWK,UAAU7T,OAAS,EFyB1BiZ,CAAqBD,EAASP,GAC9B,IAAK,MAAMG,KAAStX,KAAKgX,OAAOS,SAC5B7C,GAAK0C,EAAO,SAAUI,GAM1B,OAJI1X,KAAK2N,QACL+J,EAAQvF,iBACRnS,KAAK2N,OAAQ,GAEV+J,GGtCf,SAASE,GAAavX,EAAOC,GACzB,MAAM2P,EAAShR,SAASiR,cAAc,UAGtC,OAFAD,EAAO5P,MAAQA,EACf4P,EAAO3P,OAASA,EACT2P,EAAOQ,WAAW,MCJ7B,IAAIhT,GACJ,MAAMoa,GACG,IACMpa,GAFToa,GAIIf,IACFrZ,GAAWqZ,GCAnB,MAAMgB,GACFhY,cACIE,KAAK4L,SAAW,IAAI7D,IACpB/H,KAAK+X,wBACLF,GAA2B7X,MAE/BF,wBACIE,KAAK0M,IAAI,UAAW,IAAI7E,EAAQ+P,GAAa,GAAI,IAAI3H,SACrD,MAAM+H,EAAUJ,GAAa,GAAI,IACjCI,EAAQC,YAAc,OACtBD,EAAQE,OAAO,EAAG,GAClBF,EAAQG,OAAO,GAAI,IACnBH,EAAQI,SACRJ,EAAQK,WAAW,GAAK,GAAK,GAAI,IACjCrY,KAAK0M,IAAI,YAAa,IAAI7E,EAAQmQ,EAAQ/H,SAE9CnQ,IAAIiG,GACA,MAAM6F,EAAW5L,KAAK4L,SACtB,OAAIA,EAAS3D,IAAIlC,GACN6F,EAASzD,IAAIpC,GAGb6F,EAASzD,IAAI,aAG5BrI,IAAIiG,GACA,OAAO/F,KAAK4L,SAAS3D,IAAIlC,GAE7BjG,IAAIiG,EAAKnE,GACL,IAAIpD,EACJ,MAAMoN,EAAW5L,KAAK4L,SAWtB,OAVKA,EAAS3D,IAAIlC,KAEVvH,EADAoD,aAAkBiG,EACRjG,EAGA,IAAIiG,EAAQjG,GAE1BpD,EAAQuH,IAAMA,EACd6F,EAASnL,IAAIsF,EAAKvH,IAEfA,GC/Cf,SAAS8Z,GAAYlR,GACjB,MAAMsK,EAAEA,EAACD,EAAEA,EAACkB,EAAEA,EAACC,EAAEA,EAACC,GAAEA,EAAEC,GAAEA,GAAO1L,EAAUgN,OACnCpO,EAAEA,EAACC,EAAEA,EAACe,MAAEA,EAAKE,OAAEA,GAAWE,EAAUmR,OAS1C,MAAO,CAAEC,GARGxS,EAAI0L,EAAMzL,EAAI0M,EAAKE,EAQlB4F,GAPDzS,EAAIyL,EAAMxL,EAAI2M,EAAKE,EAOd4F,GANL1S,EAAI0L,EAAMxK,EAASyL,EAAKE,EAMf8F,GALT3S,EAAIyL,EAAMvK,EAAS0L,EAAKE,EAKX8F,GAJb5R,EAAQ0K,EAAMxK,EAASyL,EAAKE,EAIXgG,GAHjB7R,EAAQyK,EAAMvK,EAAS0L,EAAKE,EAGPgG,GAFrB9R,EAAQ0K,EAAMzL,EAAI0M,EAAKE,EAEEkG,GADzB/R,EAAQyK,EAAMxL,EAAI2M,EAAKE,GCLvC,MAAMkG,GACFlZ,YAAYmZ,GACRjZ,KAAKkZ,OAAQ,EACblZ,KAAKmZ,iBAAkB,EACvBnZ,KAAKoZ,aAAc,EACnBpZ,KAAKiZ,OAASA,EACdjZ,KAAKqZ,KAAO,IAAI/F,EAEpBxT,IAAIkG,EAAGC,EAAG5F,EAAOC,GACbN,KAAKqZ,KAAK5Y,IAAIuF,EAAGC,EAAG5F,EAAOC,GAE/BR,MAII,OAHIE,KAAKiZ,OAAOK,QAAQvD,MAAwB/V,KAAKkZ,OACjDlZ,KAAKiS,SAEFjS,KAAKqZ,KAEhBvZ,cACI,MAAM0Y,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,GAAOT,GAAYtY,KAAKiZ,OAAO7R,WAC7DpB,EAAIiJ,KAAKsK,IAAIf,EAAIE,EAAIE,EAAIE,GACzB7S,EAAIgJ,KAAKsK,IAAId,EAAIE,EAAIE,EAAIE,GACzB/R,EAAQiI,KAAKC,IAAIsJ,EAAIE,EAAIE,EAAIE,GAC7B5R,EAAS+H,KAAKC,IAAIuJ,EAAIE,EAAIE,EAAIE,GACpC,OAAO/Y,KAAKqZ,KAAK5Y,IAAIuF,EAAGC,EAAGe,EAAQhB,EAAGkB,EAASjB,GAEnDnG,SACI,MAAMqU,EAASnU,KAAKwZ,cAEpB,GADAxZ,KAAKiZ,OAAOQ,WAAW1D,KAClB/V,KAAKmZ,kBAAoBnZ,KAAKiZ,OAAOvD,YACtC,OAAOvB,EAEX,MAAMiF,EAAcpZ,KAAKoZ,YACnBrG,EAAW/S,KAAKiZ,OAAOlG,SAC7B,IAAI/M,EAAImO,EAAOnO,EACXC,EAAIkO,EAAOlO,EACXe,EAAQmN,EAAOnN,MACfE,EAASiN,EAAOjN,OACpB,IAAK,IAAIrC,EAAI,EAAGA,EAAIkO,EAASrU,OAAQmG,IAAK,CACtC,MAAMsC,EAAQ4L,EAASlO,GACvB,IAAKsC,GAAUiS,IAAgBjS,EAAMuS,QACjC,SAEJ,MAAMC,EAAcxS,EAAMgN,OAAOhM,MAC7BwR,EAAY3T,EAAIA,IAChBA,EAAI2T,EAAY3T,GAEhB2T,EAAY1T,EAAIA,IAChBA,EAAI0T,EAAY1T,GAEhB0T,EAAY3S,MAAQA,IACpBA,EAAQ2S,EAAY3S,OAEpB2S,EAAYzS,OAASA,IACrBA,EAASyS,EAAYzS,QAG7B,OAAOiN,EAAO1T,IAAIuF,EAAGC,EAAGe,EAAQhB,EAAGkB,EAASjB,GAEhDnG,UACIE,KAAKiZ,OAAS,KACdjZ,KAAKqZ,KAAO,MCjEpB,MAAMO,GACF9Z,YAAYmZ,GACRjZ,KAAK6Z,SAAU,EACf7Z,KAAK8Z,iBAAkB,EACvB9Z,KAAKiZ,OAASA,EAElBnZ,UACIE,KAAKiZ,OAAS,KACdjZ,KAAK+Z,QAAU,MCRvB,MAAMC,GACFla,YAAYkG,EAAI,EAAGC,EAAI,GACnBjG,KAAKS,IAAIuF,EAAGC,GAEhBnG,IAAIkG,EAAI,EAAGC,EAAI,GAGX,OAFAjG,KAAKgG,EAAIA,EACThG,KAAKiG,EAAIA,EACFjG,KAEXF,WACI,MAAO,CAACE,KAAKgG,EAAGhG,KAAKiG,GAEzBnG,UAAUoN,GACN,OAAOlN,KAAKS,IAAIyM,EAAI,GAAIA,EAAI,IAEhCpN,WACI,MAAO,MAAME,KAAKgG,QAAQhG,KAAKiG,MChBvC,SAASgU,GAAK/M,EAAKnO,GACf,OAAOA,EAAO0B,IAAIyM,EAAIwE,EAAGxE,EAAIuE,EAAGvE,EAAIyF,EAAGzF,EAAI0F,EAAG1F,EAAI2F,GAAI3F,EAAI4F,ICW9D,MAAMoH,GACFpa,YAAYmZ,EAAQjT,EAAI,EAAGC,EAAI,GAC3BjG,KAAKma,UAAW,EAChBna,KAAKoa,UAAY,EACjBpa,KAAKiZ,OAASA,EACdjZ,KAAKqa,MAAQ,IAAIhH,EACjBrT,KAAKoU,MAAQ,IAAIf,EACjBrT,KAAKsa,SAAW,IAAI3G,EAAa,IAAM3T,KAAKiS,SAAUjM,EAAGC,GACzDjG,KAAKua,MAAQ,IAAI5G,EAAa,IAAM3T,KAAKiS,SAAU,EAAG,GAAG,GACzDjS,KAAKwa,KAAO,IAAI7G,EAAa,IAAM3T,KAAKiS,SAAU,EAAG,GAAG,GACxDjS,KAAKqH,OAAS,IAAIsM,EAAa,IAAM3T,KAAKya,e/DtBpC,GACA,I+DsBNza,KAAKuY,OAAS,IAAIjF,EAEtBxT,SACIE,KAAKwZ,cACLxZ,KAAK8V,cAEThW,cACIE,KAAKiZ,OAAOyB,SAAS3E,GAAuBA,IC9BpD,SAA8B3O,GAC1B,MAAMiT,EAAQjT,EAAUiT,MAClBrU,EAAIoB,EAAUkT,SAAStU,EACvBC,EAAImB,EAAUkT,SAASrU,EACvB0U,EAAWvT,EAAUuT,SACrBC,EAASxT,EAAUmT,MAAMvU,EACzB6U,EAASzT,EAAUmT,MAAMtU,EACzB6U,EAAQ1T,EAAUoT,KAAKxU,EACvB+U,EAAQ3T,EAAUoT,KAAKvU,EAC7BoU,EAAM5Z,IAAIwO,KAAK+L,IAAIL,EAAWI,GAASH,EAAQ3L,KAAKgM,IAAIN,EAAWI,GAASH,GAAS3L,KAAKgM,IAAIN,EAAWG,GAASD,EAAQ5L,KAAK+L,IAAIL,EAAWG,GAASD,EAAQ7U,EAAGC,GDsB9JiV,CAAqBlb,MAEzBF,cACI,MAAMmZ,EAASjZ,KAAKiZ,OACpBA,EAAOyB,SAAS3E,GAAuBA,IEjC/C,SAA8BoF,GAC1B,MAAMxc,EAASwc,EAAWxc,OACpByI,EAAY+T,EAAW/T,UACvBgU,EAAKhU,EAAUiT,MACfgB,EAAKjU,EAAUgN,MACrB,GAAKzV,EAGA,GAAIyI,EAAU+S,SACfF,GAAKtb,EAAOyI,UAAUgN,MAAOiH,OAE5B,CACD,MAAM3J,EAAEA,EAACD,EAAEA,EAACkB,EAAEA,EAACC,EAAEA,EAACC,GAAEA,EAAEC,GAAEA,GAAOsI,GACvB1J,EAAG4J,EAAI7J,EAAG8J,EAAI5I,EAAG6I,EAAI5I,EAAG6I,EAAI5I,GAAI6I,EAAK5I,GAAI6I,GAAQhd,EAAOyI,UAAUgN,MAC1EiH,EAAG5a,IAAIiR,EAAI4J,EAAK7J,EAAI+J,EAAI9J,EAAI6J,EAAK9J,EAAIgK,EAAI9I,EAAI2I,EAAK1I,EAAI4I,EAAI7I,EAAI4I,EAAK3I,EAAI6I,EAAI5I,EAAKyI,EAAKxI,EAAK0I,EAAKE,EAAK7I,EAAK0I,EAAKzI,EAAK2I,EAAKE,QARxH1B,GAAKmB,EAAIC,GF4BTO,CAAqB3C,GACjBA,EAAOvD,aACP1V,KAAK6b,iBAGb/b,iBACI,MAAMiT,EAAW/S,KAAKiZ,OAAOlG,SAC7B,IAAK,IAAIlO,EAAI,EAAGA,EAAIkO,EAASrU,OAAQmG,IAAK,CACxBkO,EAASlO,GACjBuC,UAAU0O,eAGxBhW,cAAckG,EAAGC,EAAG6V,EAAM,IAAI9B,IAC1B,MAAMtI,EAAEA,EAACD,EAAEA,EAACkB,EAAEA,EAACC,EAAEA,EAACC,GAAEA,EAAEC,GAAEA,GAAO9S,KAAKoU,MAC9B2H,EAAK,GAAMrK,EAAIkB,EAAMD,GAAKlB,GAGhC,OAFAqK,EAAI9V,EAAK4M,EAAImJ,EAAK/V,GAAO2M,EAAIoJ,EAAK9V,GAAQ6M,EAAKH,EAAME,EAAKD,GAAMmJ,EAChED,EAAI7V,EAAKyL,EAAIqK,EAAK9V,GAAOwL,EAAIsK,EAAK/V,IAAS8M,EAAKpB,EAAMmB,EAAKpB,GAAMsK,EAC1DD,EAEXhc,cAAckG,EAAGC,EAAG6V,EAAM,IAAI9B,IAC1B,MAAMtI,EAAEA,EAACD,EAAEA,EAACkB,EAAEA,EAACC,EAAEA,EAACC,GAAEA,EAAEC,GAAEA,GAAO9S,KAAKoU,MAGpC,OAFA0H,EAAI9V,EAAK0L,EAAI1L,EAAM2M,EAAI1M,EAAK4M,EAC5BiJ,EAAI7V,EAAKwL,EAAIzL,EAAM4M,EAAI3M,EAAK6M,EACrBgJ,EAEXhc,UAAUkG,EAAGC,EAAG5F,EAAOC,GACnBN,KAAKuY,OAAO9X,IAAIuF,EAAGC,EAAG5F,EAAOC,GAC7BN,KAAKiZ,OAAOyB,SAAS3E,GAAuBA,IAEhDjW,aAAaO,EAAOC,GAChB,MAAMiY,EAASvY,KAAKuY,OACdU,EAASjZ,KAAKiZ,YACN7F,IAAV/S,IACAkY,EAAOlY,MAAQA,QAEJ+S,IAAX9S,IACAiY,EAAOjY,OAASA,GAEpBiY,EAAOvS,GAAMhG,KAAKqH,OAAQ,EAAIkR,EAAOlY,MACrCkY,EAAOtS,GAAMjG,KAAKqH,OAAQ,EAAIkR,EAAOjY,OACrC2Y,EAAOyB,SAAS3E,GAAuBA,IAE3C4E,aAAalH,GACLA,IAAUzT,KAAKoa,YACfpa,KAAKoa,UAAY3G,EACjBzT,KAAKiS,UAGb0I,eACI,OAAO3a,KAAKoa,UAEhBta,UACIE,KAAKsa,SAAS/R,UACdvI,KAAKua,MAAMhS,UACXvI,KAAKwa,KAAKjS,UACVvI,KAAKqH,OAAOkB,UACZvI,KAAKiZ,OAAS,KACdjZ,KAAKqa,MAAQ,KACbra,KAAKoU,MAAQ,KACbpU,KAAKsa,SAAW,KAChBta,KAAKua,MAAQ,KACbva,KAAKwa,KAAO,KACZxa,KAAKqH,OAAS,KACdrH,KAAKuY,OAAS,MGrEtB,MAAMyD,GACFlc,YAAYkG,EAAI,EAAGC,EAAI,GACnBjG,KAAKiU,KAAO,aACZjU,KAAKic,KAAO,GACZjc,KAAKkc,YAAa,EAClBlc,KAAKmc,oBAAqB,EAC1Bnc,KAAKoc,YAAa,EAClBpc,KAAKqc,oBAAqB,EAC1Brc,KAAKsc,mBAAoB,EACzBtc,KAAKuc,MAAQ,EACbvc,KAAKwc,WAAa,EAClBxc,KAAK0Z,SAAU,EACf1Z,KAAK+S,SAAW,GAChB/S,KAAK+U,OAAS,IAAIhN,IAClB/H,KAAKoH,UAAY,IAAI8S,GAAmBla,KAAMgG,EAAGC,GACjDjG,KAAKmU,OAAS,IAAI6E,GAAgBhZ,MAClCA,KAAKyc,MAAQ,IAAI7C,GAAe5Z,MAChCA,KAAKuc,MAAQxG,GACb/V,KAAKoH,UAAU6K,SAEnBnS,eACI,OAAQE,KAAK0Z,SAAW1Z,KAAKoc,WAEjCtc,QAAQ4c,GACJ,OAA+B,IAAvB1c,KAAKuc,MAAQG,GAEzB5c,WAAW4c,GAIP,OAHI1c,KAAKsZ,QAAQoD,KACb1c,KAAKuc,OAASG,GAEX1c,KAEXF,SAAS4c,EAAMC,GAQX,OAPK3c,KAAKsZ,QAAQoD,KACd1c,KAAKuc,OAASG,EACd1c,KAAKwc,WAAa5e,KAEjBoC,KAAKsZ,QAAQqD,KACd3c,KAAKuc,OAASI,GAEX3c,KAEXF,OAAOyX,EAAOC,GACV,GAAIxX,KAAKmc,mBAAoB,CACzB,MAAMpJ,EAAW/S,KAAK+S,SACtB,IAAK,IAAIlO,EAAI,EAAGA,EAAIkO,EAASrU,OAAQmG,IAAK,CACtC,MAAMsC,EAAQ4L,EAASlO,GACnBsC,GAASA,EAAM+U,YACf/U,EAAM8K,OAAOsF,EAAOC,IAIhCxX,KAAK4c,WAAWrF,EAAOC,GAE3B1X,WAAWyX,EAAOC,IAElB1X,SAASC,IAETD,aAAaC,IAEbD,aAAaC,IAEbD,iBAAiBC,IAEjB2V,kBACI,OAAO1V,KAAK+S,SAASrU,OAEzBoB,QAAQ+c,GACAA,ECvFZ,SAA0Ble,EAAQme,EAAW7G,EAAa,EAAGC,GACzD,MAAM6G,EAAQ/G,GAAsBrX,EAAQsX,EAAYC,GACxDZ,GAAUwH,KAAcC,GACxBA,EAAM5N,QAAQhI,IACVA,EAAMC,UAAU0O,gBDoFZkH,CAAiBhd,KAAM6c,GEjGnC,SAAyBle,EAAQsX,EAAa,EAAGC,GAC7BF,GAAsBrX,EAAQsX,EAAYC,GAClD/G,QAAQhI,IACZA,EAAMoB,YFiGF0U,CAAgBjd,MAEpB4U,GAAK5U,KGxGQ,UHwGYA,MACzBA,KAAKoH,UAAUmB,UACfvI,KAAKmU,OAAO5L,UACZvI,KAAKyc,MAAMlU,UACXvI,KAAK+U,OAAOvU,QACZR,KAAKoU,MAAQ,KACbpU,KAAKrB,OAAS,KACdqB,KAAK+S,SAAW,MIhFxB,MAAMmK,WAAkBlB,GACpBlc,YAAYkG,EAAI,EAAGC,EAAI,GACnBgH,MAAMjH,EAAGC,GACTjG,KAAKmd,OAAS,EACdnd,KAAKiU,KAAO,YAEhBnU,QAAQO,EAAOC,EAASD,GAEpB,OADAL,KAAKoH,UAAUqT,aAAapa,EAAOC,GAC5BN,KAEXF,YAAYkG,EAAGC,GAEX,OADAjG,KAAKoH,UAAUkT,SAAS7Z,IAAIuF,EAAGC,GACxBjG,KAEXF,UAAUkG,EAAGC,EAAID,GAEb,OADAhG,KAAKoH,UAAUC,OAAO5G,IAAIuF,EAAGC,GACtBjG,KAEXF,QAAQkG,EAAGC,EAAID,GAEX,OADAhG,KAAKoH,UAAUoT,KAAK/Z,IAAIuF,EAAGC,GACpBjG,KAEXF,SAASkG,EAAGC,EAAID,GAEZ,OADAhG,KAAKoH,UAAUmT,MAAM9Z,IAAIuF,EAAGC,GACrBjG,KAEXF,YAAY2T,GAER,OADAzT,KAAKoH,UAAUuT,SAAWlH,EACnBzT,KAEXK,UAAUoT,GACNzT,KAAKoH,UAAUqT,aAAahH,GAEhCpT,YACI,OAAOL,KAAKoH,UAAUmR,OAAOlY,MAEjCC,WAAWmT,GACPzT,KAAKoH,UAAUqT,kBAAarH,EAAWK,GAE3CnT,aACI,OAAON,KAAKoH,UAAUmR,OAAOjY,OAEjC0F,MAAMyN,GACFzT,KAAKoH,UAAUkT,SAAStU,EAAIyN,EAEhCzN,QACI,OAAOhG,KAAKoH,UAAUkT,SAAStU,EAEnCC,MAAMwN,GACFzT,KAAKoH,UAAUkT,SAASrU,EAAIwN,EAEhCxN,QACI,OAAOjG,KAAKoH,UAAUkT,SAASrU,EAEnCY,YAAY4M,GACRzT,KAAKoH,UAAUC,OAAOrB,EAAIyN,EAE9B5M,cACI,OAAO7G,KAAKoH,UAAUC,OAAOrB,EAEjCc,YAAY2M,GACRzT,KAAKoH,UAAUC,OAAOpB,EAAIwN,EAE9B3M,cACI,OAAO9G,KAAKoH,UAAUC,OAAOpB,EAEjC6U,UAAUrH,GACNzT,KAAKoH,UAAUoT,KAAKxU,EAAIyN,EAE5BqH,YACI,OAAO9a,KAAKoH,UAAUoT,KAAKxU,EAE/B+U,UAAUtH,GACNzT,KAAKoH,UAAUoT,KAAKvU,EAAIwN,EAE5BsH,YACI,OAAO/a,KAAKoH,UAAUoT,KAAKvU,EAE/B2U,WAAWnH,GACPzT,KAAKoH,UAAUmT,MAAMvU,EAAIyN,EAE7BmH,aACI,OAAO5a,KAAKoH,UAAUmT,MAAMvU,EAEhC6U,WAAWpH,GACPzT,KAAKoH,UAAUmT,MAAMtU,EAAIwN,EAE7BoH,aACI,OAAO7a,KAAKoH,UAAUmT,MAAMtU,EAEhC0U,aAAalH,GACTzT,KAAKoH,UAAUuT,SAAWlH,EAE9BkH,eACI,OAAO3a,KAAKoH,UAAUuT,SAE1Blb,YACI,OAAOO,KAAKmd,OAEhB1d,UAAUgU,GACFA,IAAUzT,KAAKmd,SACfnd,KAAKmd,OAAS1J,EACdzT,KAAK0a,SAAS3E,MCrI1B,SAASqH,GAAUC,EAAK5d,GAEpB,QADiC,KAAZ,IAARA,EAAe,KACb,GAAM4d,KAAS,ECAlC,SAASC,GAAWC,GAChB,MAAM9d,EAAQ8d,EAAOC,YACfC,EAAOF,EAAOG,WACdrM,EAAQkM,EAAOI,YAKrB,OAJAtM,EAAM,GAAK+L,GAAUK,EAAK,GAAIhe,EAAM,IACpC4R,EAAM,GAAK+L,GAAUK,EAAK,GAAIhe,EAAM,IACpC4R,EAAM,GAAK+L,GAAUK,EAAK,GAAIhe,EAAM,IACpC4R,EAAM,GAAK+L,GAAUK,EAAK,GAAIhe,EAAM,IAC7B8d,ECVX,SAASK,GAASpf,EAASuH,KAAQgN,GAC/B,MAAMrV,EAAQc,EAAQqf,SAAS9X,IACzB0B,GAAEA,EAAEE,GAAEA,EAAED,GAAEA,EAAEE,GAAEA,EAAEtB,MAAEA,GAAU5I,EAqBlC,OApBAqV,EAAS5D,QAAQhI,IACb,IAAKA,GAASzJ,IAAUyJ,EAAMzJ,MAC1B,OAEJyJ,EAAMzJ,MAAQA,EACV4I,GACAa,EAAM2W,UAAUxX,EAAMN,EAAGM,EAAML,GAEnCkB,EAAMzJ,MAAM4J,UAAUH,GACtBA,EAAM4W,YAAa,EACnB,MAAMjZ,EAAOqC,EAAM6W,WACnBlZ,EAAK,GAAK2C,EACV3C,EAAK,GAAK4C,EACV5C,EAAK,GAAK2C,EACV3C,EAAK,GAAK8C,EACV9C,EAAK,IAAM6C,EACX7C,EAAK,IAAM8C,EACX9C,EAAK,IAAM6C,EACX7C,EAAK,IAAM4C,IAERqL,ECoBX,MAAMkL,WAAef,GACjBpd,YAAYkG,EAAGC,EAAGzH,EAASd,GACvBuP,MAAMjH,EAAGC,GACTjG,KAAK+d,YAAa,EAClB/d,KAAKke,MAAQ,SACble,KAAKiU,KAAO,SACZjU,KAAKge,WAAa,IAAI9Y,aAAa,IAAIiZ,KAAK,GAC5Cne,KAAK2d,YAAc,IAAIvY,YAAY,GAAG+Y,KAAK,YAC3Cne,KAAKwd,YAAc,IAAItY,aAAa,GAAGiZ,KAAK,GAC5Cne,KAAK0d,WAAa,IAAItY,YAAY,GAAG+Y,KAAK,UAC1Cne,KAAKoe,WAAW5f,EAASd,GAE7BoC,WAAWiG,EAAKrI,GAEZ,OCnDR,SAAoBqI,EAAKrI,KAAUqV,GAC/B,GAAKhN,EAOA,CACD,IAAIvH,EAEAA,EADAuH,aAAe8B,EACL9B,EAGA8R,KAA6B1P,IAAIpC,GAE1CvH,GAIDuU,EAAS5D,QAAQhI,IACbA,EAAM3I,QAAUA,IAEpBof,GAASpf,EAASd,KAAUqV,IAN5B3K,QAAQC,KAAK,wBAAwBtC,QAfzCgN,EAAS5D,QAAQhI,IACbA,EAAM3I,QAAU,KAChB2I,EAAMzJ,MAAQ,KACdyJ,EAAM4W,YAAa,ID6CvBM,CAAWtY,EAAKrI,EAAOsC,MAChBA,KAEXF,SAASiG,GAEL,OADA6X,GAAS5d,KAAKxB,QAASuH,EAAK/F,MACrBA,KAEXF,eACI,OAAQE,KAAK0Z,SAAW1Z,KAAKoc,YAAcpc,KAAK+d,YAAc/d,KAAKP,MAAQ,EAE/EK,YACQE,KAAKsZ,QAAQvD,MACbuH,GAAWtd,MACXA,KAAKyZ,WAAW1D,KAEhB/V,KAAKsZ,QAAQvD,OErEzB,SAAwBwH,GACpB,MAAMzY,EAAOyY,EAAOS,YACdxF,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,GAAOT,GAAYiF,EAAOnW,WAC9DtC,EAAK,GAAK0T,EACV1T,EAAK,GAAK2T,EACV3T,EAAK,GAAK4T,EACV5T,EAAK,GAAK6T,EACV7T,EAAK,IAAM8T,EACX9T,EAAK,IAAM+T,EACX/T,EAAK,IAAMgU,EACXhU,EAAK,IAAMiU,EF4DHuF,CAAete,MACfA,KAAKyZ,WAAW1D,KAGxBjW,SAASC,GACLC,KAAKue,YG7Eb,SAA2BhB,EAAQxd,GAC/B,MAAMvB,EAAU+e,EAAO/e,QACjBgP,EAASzN,EAASyQ,QAAQ1S,QAC1B4L,EAAS8D,EAAO9D,OAChBvI,EAAU3C,EAAQ2C,QACpBqM,EAAO5D,QAAUF,EAAOxF,WACxBnE,EAAS4N,QAEb,MAAM7I,EAAOyY,EAAOS,WACpBje,EAAS6L,SAAS4S,QAAQhgB,GAC1B,MAAMqN,EAAe1K,EAAQiC,MAC7B0B,EAAK,GAAK+G,EACV/G,EAAK,IAAM+G,EACX/G,EAAK,IAAM+G,EACX/G,EAAK,IAAM+G,EACX,MAAM4S,EAASjR,EAAO5D,MAAQF,EAAOjF,gBACrCiF,EAAOzE,cAAcxE,IAAIqE,EAAM2Z,GAC/B,MAAMpN,EAAQkM,EAAOI,YACfe,EAAMhV,EAAOvE,cACnBuZ,EAAID,EAAS,GAAKpN,EAAM,GACxBqN,EAAID,EAAS,IAAMpN,EAAM,GACzBqN,EAAID,EAAS,IAAMpN,EAAM,GACzBqN,EAAID,EAAS,IAAMpN,EAAM,GACzB7D,EAAO5D,QHuDH+U,CAAkB3e,KAAMD,GAE5BD,aAAaC,GACTC,KAAKue,YIjFb,SAA0BhB,EAAQxd,GAC9B,MAAMrC,EAAQ6f,EAAO7f,MACrB,IAAKA,EACD,OAEJ,MAAMkhB,EAAM7e,EAAS6e,IACfxX,EAAYmW,EAAOnW,WACnBsK,EAAEA,EAACD,EAAEA,EAACkB,EAAEA,EAACC,EAAEA,EAACC,GAAEA,EAAEC,GAAEA,GAAO1L,EAAUgN,OACnCpO,EAAEA,EAACC,EAAEA,GAAMmB,EAAUmR,OAC3BqG,EAAIC,OACJD,EAAIE,aAAapN,EAAGD,EAAGkB,EAAGC,EAAGC,EAAIC,GACjC8L,EAAIG,YAAcxB,EAAO9d,MACzBmf,EAAII,UAAUthB,EAAMc,QAAQqD,MAAOnE,EAAMsI,EAAGtI,EAAMuI,EAAGvI,EAAM2C,MAAO3C,EAAM4C,OAAQ0F,EAAGC,EAAGvI,EAAM2C,MAAO3C,EAAM4C,QACzGse,EAAIK,UJqEAC,CAAiBlf,KAAMD,GAE3BN,YACI,OAAOO,KAAKmd,OAEhB1d,UAAUgU,GACN,GAAIA,IAAUzT,KAAKmd,OAAQ,CACvBnd,KAAKmd,OAAS1J,EACd,MAAM+J,EAAcxd,KAAKwd,YACzBA,EAAY,GAAK/J,EACjB+J,EAAY,GAAK/J,EACjB+J,EAAY,GAAK/J,EACjB+J,EAAY,GAAK/J,EACjBzT,KAAK0a,SAAS3E,KAGtB0H,WACI,OAAOzd,KAAKke,MAEhBT,SAAShK,GACL,GAAIA,IAAUzT,KAAKke,MAAO,CACtBle,KAAKke,MAAQzK,EACb,MAAMiK,EAAa1d,KAAK0d,WACxBA,EAAW,GAAKjK,EAChBiK,EAAW,GAAKjK,EAChBiK,EAAW,GAAKjK,EAChBiK,EAAW,GAAKjK,EAChBzT,KAAK0a,SAAS3E,KAGtBjW,QAAQ+c,GACJ5P,MAAM1E,QAAQsU,GACd7c,KAAKxB,QAAU,KACfwB,KAAKtC,MAAQ,KACbsC,KAAK+d,YAAa,EAClB/d,KAAKge,WAAa,KAClBhe,KAAK2d,YAAc,KACnB3d,KAAKwd,YAAc,KACnBxd,KAAK0d,WAAa,MKnH1B,SAASyB,GAAc9e,EAAQ,GAAIC,EAAS,IACxC,MAAMse,EAAMhH,GAAavX,EAAOC,GAChC,OAAO,IAAIuH,EAAQ+W,EAAI3O,QCuC3B,MAAMmP,WAAanB,GACfne,YAAYkG,EAAGC,EAAGoZ,EAAO,GAAIC,EAAMC,GAC/BtS,MAAMjH,EAAGC,EAAGkZ,MACZnf,KAAKwf,YAAc,iBACnBxf,KAAKyf,QAAU,CAAE1Y,KAAM,EAAGC,MAAO,EAAGC,IAAK,EAAGC,OAAQ,GACpDlH,KAAK0f,cAAgB,SACrB1f,KAAK2f,YAAc,EACnB3f,KAAKsf,KAAO,iBACZtf,KAAKuf,UAAY,OACjBvf,KAAKiY,YAAc,GACnBjY,KAAK4f,gBAAkB,GACvB5f,KAAK6f,aAAe,EACpB7f,KAAK8f,UAAY,OACjB9f,KAAK+f,aAAe,aACpB/f,KAAKggB,UAAY,EACjBhgB,KAAKigB,SAAW,GAChBjgB,KAAKN,WAAY,EACjBM,KAAKiU,KAAO,OACZ,MAAMpW,EAAOD,IACboC,KAAKyJ,WAAa5L,EAAKkC,SAAS0J,WAChCzJ,KAAKiQ,OAASjQ,KAAKxB,QAAQqD,MAC3B7B,KAAKiB,QAAUjB,KAAKiQ,OAAOQ,WAAW,MAClC6O,IACAtf,KAAKsf,KAAOA,GAEZC,IACAvf,KAAKuf,UAAYA,GAErBvf,KAAKkgB,QAAQb,GAEjBvf,YAAYmQ,EAAQ2O,GACZ5e,KAAKmgB,mBACLngB,KAAKmgB,kBAAkBlQ,EAAQ2O,GAEnCA,EAAIU,KAAOtf,KAAKsf,KAChBV,EAAImB,aAAe/f,KAAK+f,aACxBnB,EAAIkB,UAAY9f,KAAK8f,UACrBlB,EAAIW,UAAYvf,KAAKuf,UACrBX,EAAI3G,YAAcjY,KAAKiY,YACvB2G,EAAIoB,UAAYhgB,KAAKggB,UACrBpB,EAAIwB,QAAU,QACdxB,EAAIyB,SAAW,QACfzB,EAAI0B,YAAYtgB,KAAKigB,UACrBrB,EAAI2B,sBAAwBvgB,KAAKN,UAErCI,aACI,MAAMmQ,EAASjQ,KAAKiQ,OACd2O,EAAM5e,KAAKiB,QACXwI,EAAazJ,KAAKyJ,WAClB+W,EAAQxgB,KAAKygB,MAAMC,MAAM1gB,KAAKwf,aAC9BC,EAAUzf,KAAKyf,QACfF,EAAYvf,KAAKuf,UACjBtH,EAAcjY,KAAKiY,YACnB0I,EAAc3gB,KAAKggB,UACnBL,EAAc3f,KAAK2f,YACnBiB,EAAmBD,EAAc,EAAKA,EAAc,EAAI,EAC9D/B,EAAIiC,UAAU,EAAG,EAAG5Q,EAAO5P,MAAO4P,EAAO3P,QACzCN,KAAK8gB,YAAY7Q,EAAQ2O,GACzBA,EAAIkB,UAAY,QAChB,IAAIiB,EAAW,EACXC,EAAY,EACZ/a,EAAI,EACR,MAAMgb,EAAc,GACdC,EAAuC,WAAvBlhB,KAAK0f,cACrByB,EAAUvC,EAAIwC,YAAY,QAC1BC,EAAoBpS,KAAKqS,KAAKrS,KAAKsS,IAAIJ,EAAQK,yBAA2BvS,KAAKsS,IAAIJ,EAAQM,2BAA6Bd,EAC9H,IAAK,IAAI9b,EAAI,EAAGA,EAAI2b,EAAM9hB,OAAQmG,IAAK,CACnC,MAAMsc,EAAUvC,EAAIwC,YAAYZ,EAAM3b,IAChCkC,EAAOoa,EAAQO,sBACf1a,EAAQma,EAAQQ,uBACtB,IAAIC,EAAST,EAAQK,wBACjBK,EAAUV,EAAQM,0BAChBG,GAAWC,IAAyB,KAAbrB,EAAM3b,KAC/B+c,EAASP,EACTQ,EAAU,GAEd,MAAM7B,EAAY/Q,KAAKqS,KAAKrS,KAAKsS,IAAIxa,GAAQkI,KAAKsS,IAAIva,IAAU2Z,EAC1DmB,EAAa7S,KAAKqS,KAAKrS,KAAKsS,IAAIK,GAAU3S,KAAKsS,IAAIM,IAAYlB,EACjEO,GACAjb,GAAK2b,EAAShB,EACV/b,EAAI,IACJoB,GAAK0Z,EAAciB,GAEvBI,EAAY/a,EAAI4b,EAAUjB,IAG1B3a,EAAI+a,GAAcc,EAAaD,EAAWjB,GAC1CI,GAAac,EACTjd,EAAI2b,EAAM9hB,OAAS,IACnBsiB,GAAarB,IAGrBoB,EAAW9R,KAAKC,IAAI6R,EAAUf,GAC9BiB,EAAYxiB,KAAK,CAAEuhB,UAAAA,EAAW8B,WAAAA,EAAYF,OAAAA,EAAQC,QAAAA,EAAS9a,KAAAA,EAAMC,MAAAA,EAAOf,EAAAA,IAE5E8a,GAAYtB,EAAQ1Y,KAAO0Y,EAAQzY,MACnCga,GAAavB,EAAQxY,IAAMwY,EAAQvY,OACnC,MAAM6a,EAAgB/hB,KAAe,WAAIA,KAAKgiB,WAAajB,EACrDkB,EAAiBjiB,KAAgB,YAAIA,KAAKkiB,YAAclB,EACxDmB,EAAclT,KAAKqS,KAAKS,EAAetY,GACvC2Y,EAAenT,KAAKqS,KAAKW,EAAgBxY,GAC3CwG,EAAO5P,QAAU8hB,GAAelS,EAAO3P,SAAW8hB,IAClDnS,EAAO5P,MAAQ8hB,EACflS,EAAO3P,OAAS8hB,EAChBpiB,KAAKxB,QAAQ8J,QAAQyZ,EAAcE,GACnCjiB,KAAKsI,QAAQyZ,EAAcE,IAE/BrD,EAAIC,OACJD,EAAIrE,MAAM9Q,EAAYA,GACtBzJ,KAAK8gB,YAAY7Q,EAAQ2O,GACzB,MAAMgB,EAAkB5f,KAAK4f,gBAC7B,GAAIA,EAAiB,CACjBhB,EAAIC,OACJD,EAAIW,UAAYK,EAChBhB,EAAI3G,YAAc2H,EAClB,MAAMC,EAAe7f,KAAK6f,aACpBwC,EAAcxC,EAAe,EAAKA,EAAe,EAAI,EACvDA,IACAjB,EAAIoB,UAAYH,EAChBjB,EAAIvG,WAAWgK,EAAYA,EAAYN,EAAelC,EAAcoC,EAAgBpC,IAExFjB,EAAI0D,SAASD,EAAYA,EAAYN,EAAelC,EAAcoC,EAAgBpC,GAClFjB,EAAIK,UAER,MAAMa,EAAY9f,KAAK8f,UACjByC,EAA0B,WAAdzC,EACZ0C,EAAyB,UAAd1C,GAAuC,QAAdA,EACpC2C,GAAYR,EAAgBjB,GAAa,EAAKvB,EAAQxY,IAC5D,IAAK,IAAIpC,EAAI,EAAGA,EAAI2b,EAAM9hB,OAAQmG,IAAK,CACnC,MAAM6d,EAAOlC,EAAM3b,GACbsc,EAAUF,EAAYpc,GAC5B,IAAIgO,EAAK4M,EAAQ1Y,KAAOoa,EAAQpa,KAAO6Z,EACvC,MAAM9N,EAAK2P,EAAUtB,EAAQlb,EACzBsc,EACA1P,EAAKkP,EAAe,EAEfS,IACL3P,EAAKkP,EAAenB,GAEpB3I,GACA2G,EAAI+D,WAAWD,EAAM7P,EAAIC,GAEzByM,GACAX,EAAIgE,SAASF,EAAM7P,EAAIC,GAQ/B,OALA8L,EAAIK,UACAjf,KAAKxB,QAAQ2C,SACbnB,KAAKxB,QAAQ2C,QAAQ8Q,SAEzBjS,KAAK0a,SAAS3E,IACP/V,KAEXqf,WACI,OAAOrf,KAAKygB,MAEhBpB,SAAS5L,GACLzT,KAAKkgB,QAAQzM,GAEjB3T,QAAQ2T,EAAQ,IAQZ,OAPIoP,MAAMC,QAAQrP,KACdA,EAAQA,EAAMtF,KAAK,OAEnBsF,IAAUzT,KAAKygB,QACfzgB,KAAKygB,MAAQhN,EAAMzC,WACnBhR,KAAK+iB,cAEF/iB,KAEXF,QAAQ+c,GACJ7c,KAAKxB,QAAQ+J,UACbvI,KAAKuf,UAAY,KACjBvf,KAAKiY,YAAc,KACnBjY,KAAK4f,gBAAkB,KACvB5f,KAAKiQ,OAAS,KACdjQ,KAAKiB,QAAU,KACfgM,MAAM1E,QAAQsU,IC3NtB,SAASmG,GAAmBC,EAAcC,GACtCD,EAAa9T,QAAQgU,IACbD,GCHZ,SAA0BvkB,GACtB,GAAIA,EAAOsU,KAAKqG,QAAQvD,IACpB,OAAO,EAEX,MAAM9V,EAAQ,CAACtB,GACf,KAAOsB,EAAMvB,OAAS,GAAG,CACrB,MAAMoC,EAAQb,EAAMW,MACpB,GAAIE,EAAMmS,KAAKqG,QAAQvD,IACnB,OAAO,EAEX,MAAML,EAAc5U,EAAMiS,SAASrU,OACnC,GAAIgX,EAAc,EACd,IAAK,IAAI7Q,EAAI,EAAGA,EAAI6Q,EAAa7Q,IAC7B5E,EAAMxB,KAAKqC,EAAMiS,SAASlO,IAKtC,OADA5E,EAAMvB,OAAS,GACR,EDfgB0kB,CAAiBD,GAChCA,EAAMlQ,KAAKyH,SAAS3E,IAGpBoN,EAAMpQ,SAASrU,OAAS,IEHpC,SAAS2kB,GAAgBjP,GACrB,MAAM6O,EAAe,GAEfK,ECTV,SAASC,EAAsBN,EAActkB,EAAQ2S,EAAS,IAC1D,IAAK,IAAIzM,EAAI,EAAGA,EAAIlG,EAAO+W,YAAa7Q,IAAK,CACzC,MAAMoO,EAAOtU,EAAOoU,SAASlO,GAC7B,GAAIoO,EAAKuQ,eAAgB,CACrB,MAAMzQ,EAAW,GACXjS,EAAQ,CAAEmS,KAAAA,EAAMF,SAAAA,GACtBzB,EAAO7S,KAAKqC,GACRmS,EAAKoJ,oBAAsBpJ,EAAKyC,YAAc,IAC1CzC,EAAKqJ,mBACL2G,EAAaxkB,KAAKqC,GAEtByiB,EAAsBN,EAAchQ,EAAMF,KAItD,OAAOzB,EDNSiS,CAAsBN,EAAc7O,EADtC,IAERlC,EAAakC,EAAMlC,WACrB+Q,EAAavkB,OAAS,GACtBskB,GAAmBC,EAAc7O,EAAM5B,OAAO0B,aAElDoP,EAAQnU,QAAQrO,IACRA,EAAMiS,SAASrU,OEf3B,SAAS+kB,EAAyB3iB,EAAOoR,GACrCA,EAAWwR,cACXxR,EAAWyR,gBACP7iB,EAAMmS,KAAKuJ,YAActK,EAAWiF,WACpCjF,EAAWsK,aAEf1b,EAAMiS,SAAS5D,QAAQhI,IACfA,EAAM4L,SAASrU,OAAS,GACxB+kB,EAAyBtc,EAAO+K,KFQhCuR,CAAyB3iB,EAAOoR,IAGhCA,EAAWwR,cACXxR,EAAWyR,gBACP7iB,EAAMmS,KAAKuJ,YAActK,EAAWiF,WACpCjF,EAAWsK,gBAIvBtK,EAAWO,WAAa6Q,EACpBlP,EAAMwP,eACN1R,EAAWsK,aACXpI,EAAMwP,cAAe,GG7B7B,SAASC,GAAqB3R,EAAYiF,GACtCjF,EAAWiF,UAAYA,EACvBjF,EAAWsK,WAAa,EACxBtK,EAAWwR,YAAc,EACzBxR,EAAWyR,cAAgB,EAC3BzR,EAAWO,WAAW/T,OAAS,EC0CnC,MAAMolB,WAAkB9H,GACpBlc,YAAYwX,GACRrK,QACAjN,KAAK4jB,cAAe,EACpB5jB,KAAKiU,KAAO,YACZjU,KAAKsX,MAAQA,EACbtX,KAAKoU,MAAQpU,KACbA,KAAK+U,OAAS,IAAIhN,IAClB/H,KAAK+jB,gBAAkBtN,GAAGa,EAAO,SAAU,CAACC,EAAOC,IAASxX,KAAKiS,OAAOsF,EAAOC,IAC/ExX,KAAKgkB,gBAAkBvN,GAAGa,EAAO,SAAWpF,GAAelS,KAAKikB,OAAO/R,IACvElS,KAAKkkB,kBAAoBzN,GAAGa,EAAO,WAAY,IAAMtX,KAAKmkB,YAC1DvN,GAAKU,EAAO,UAAW,IAAMtX,KAAKuI,WAEtCzI,OAAOyX,EAAOC,GACLxX,KAAKkc,aAGVtH,GAAK5U,KChEO,SDgEYuX,EAAOC,EAAMxX,MACrCiN,MAAMgF,OAAOsF,EAAOC,IAExB1X,WAAWyX,EAAOC,GACd5C,GAAK5U,KEpEW,aFoEYuX,EAAOC,EAAMxX,MAE7CF,OAAOskB,GACH,MAAMlS,EAAalS,KAAKkS,WACxB2R,GAAqB3R,EAAYkS,EAAgBjN,WAC5CnX,KAAKoc,YAAepc,KAAK0Z,UAG9B2J,GAAgBrjB,MAChB4U,GAAK5U,KG7EY,cH6EYkS,EAAYlS,MI7EjD,SAAyBokB,EAAiBC,GACtCD,EAAgBjS,gBAAkBkS,EAAgB7H,WAClD4H,EAAgBhN,gBAAkBiN,EAAgBX,YAC9CW,EAAgB7R,OAAO0B,aACvBkQ,EAAgBhS,kBAEpBgS,EAAgB7R,UAAU9T,KAAK4lB,GJwE3BC,CAAgBF,EAAiBlS,GAC7BlS,KAAKwS,SACLxS,KAAKwS,OAAO0B,aAAc,IAGlCpU,WACI,MAAMwX,EAAQtX,KAAKsX,MACnBjB,GAAIiB,EAAO,SAAUtX,KAAK+jB,iBAC1B1N,GAAIiB,EAAO,SAAUtX,KAAKgkB,iBAC1B3N,GAAIiB,EAAO,WAAYtX,KAAKkkB,mBKnFpC,SAAwBvlB,KAAWoU,GAC/BA,EAAS5D,QAAQhI,IACbkN,EAAY1V,EAAQwI,KLkFpBod,CAAevkB,MACf4U,GAAK5U,KMzFc,gBNyFYA,MAC/B6jB,GAAqB7jB,KAAKkS,WAAY,GAClClS,KAAKwS,QACLxS,KAAKwS,OAAOzR,QAGpBjB,QAAQ+c,GACJ5P,MAAM1E,QAAQsU,GACdjI,GAAK5U,KlBjGQ,UkBiGYA,MACzB6jB,GAAqB7jB,KAAKkS,WAAY,GAClClS,KAAKwS,QACLxS,KAAKwS,OAAOjK,UAEhBvI,KAAK+U,OAAOvU,QACZR,KAAKwS,OAAS,KACdxS,KAAKkS,WAAa,KAClBlS,KAAK+U,OAAS,MOvDtB,MAAMyP,WAAoBV,GACtBhkB,YAAYwX,GACRrK,MAAMqK,GACNtX,KAAKiU,KAAO,cACZjU,KAAKwS,OAAS,IAAIwB,EAClBhU,KAAKkS,WCtDF,CACHM,ODqDwCxS,KAAKwS,OCpD7C2E,UAAW,EACXqF,WAAY,EACZkH,YAAa,EACbC,cAAe,EACflR,WAAY,KCJpB,SAASgS,GAAQnN,EAAOnU,EAAS,IAC7B,MAAMuhB,EAAe7N,KACf7B,EAAO0P,EAAa1N,OAAOhC,KAC3BiC,EAAayN,EAAazN,WAC1B0N,EAAuB,IAAT3P,EACE,iBAAX7R,EACPmU,EAAMvR,IAAM5C,GAEPA,IAAYA,GAAUwhB,KAC3BrN,EAAMvR,ICZd,SAAwB5C,EAAQyhB,EAAUC,GACtC,OAAI5Z,OAAO6Z,UAAUC,eAAeC,KAAK7hB,EAAQyhB,GACtCzhB,EAAOyhB,GAGPC,EDOKI,CAAe9hB,EAAQ,MAAO,QAAU8T,EAAWjG,aAE/D0T,EAAa1N,OAAO/O,IAAIqP,EAAMvR,KAC9BqC,QAAQC,KAAK,6BAA+BiP,EAAMvR,MAGlD2e,EAAa1N,OAAOvW,IAAI6W,EAAMvR,IAAKuR,GACnCoN,EAAa/W,OAAQ,EACrB+W,EAAazN,cElBd,IAAIiO,GAAW,SAClBlf,EACAC,GAGA,YAAemN,IAANpN,QAA2BoN,IAANnN,OAAoBmN,EAAY,GAAGpN,KAAKC,WCP7Dkf,GAGTrlB,cACIE,KAAKolB,MAAQ,GAGjBtlB,UACIE,KAAKQ,QACLR,KAAKolB,WAAQhS,EAGjBtT,MACI,OAAQE,KAAKolB,MAAM1mB,OAAS,EAAKsB,KAAKolB,MAAMxkB,MAAQ,KAGxDd,KAAKulB,GAED,OADArlB,KAAKolB,MAAM3mB,KAAK4mB,GACTrlB,KAGXF,aAAawlB,GAGT,OAFAtlB,KAAKolB,MAAM3mB,KAAK0W,MAAMnV,KAAKolB,MAAOE,GAClCA,EAAI5mB,OAAS,EACNsB,KAGXF,QAEI,OADAE,KAAKolB,MAAM1mB,OAAS,EACbsB,MC3Bf,IAAIulB,GAAmB,IAAIJ,GAUhBK,GAAe,SAAUC,GAChCF,GAAiB9mB,KAAKgnB,ICLfC,GAAiB,SACxBC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,GAAKL,IAAUG,GAAWF,IAAUG,GAAWF,IAAUG,EACrD,OAEJ,IAAIC,EAAUjB,GAASW,EAAOC,GAC1BM,EAAUlB,GAASc,EAAOC,GAC9B,GAAIE,EAAS,CACT,IAAIE,EAAOT,EAASzd,IAAIge,GAExB,GADAE,EAAKhR,OAAO0Q,GACRI,IAAYC,EAEZ,YADAC,EAAK5lB,IAAIylB,EAAOP,GAEK,IAAdU,EAAKrR,OACZwQ,GAAaa,GACbT,EAASvQ,OAAO8Q,IAGxB,GAAIC,EAAS,CACT,IAAIC,EAAOT,EAASzd,IAAIie,GACpBC,EACAA,EAAK5lB,IAAIylB,EAAOP,IAEhBU,EDnCa,WACrB,IAAIC,EAASf,GAAiB3kB,MAI9B,OAHe,OAAX0lB,IACAA,EAAS,IAAIve,KAEVue,EC8BQC,GACPF,EAAK5lB,IAAIylB,EAAOP,GAChBC,EAASnlB,IAAI2lB,EAASC,MAKvBG,GAAsB,SAC7BZ,EACA5f,EACAC,EACAwgB,GAEA,IAAI1gB,EAAMmf,GAASlf,EAAGC,GAClBogB,EAAOT,EAASzd,IAAIpC,GACpBsgB,SACUjT,IAANqT,GACAJ,EAAKhR,OAAOoR,GACM,IAAdJ,EAAKrR,OACLwQ,GAAaa,GACbT,EAASvQ,OAAOtP,MAGpBsgB,EAAK7lB,QACLglB,GAAaa,GACbT,EAASvQ,OAAOtP,MC9DxB2gB,GAAmB,IAAIvB,GAUhBwB,GAAe,SAAUlB,GAChCiB,GAAiBjoB,KAAKgnB,ICNfmB,GAAgB,SACvBjB,EACAC,EACAO,EACAC,GAEA,GAAID,IAAYC,EAAhB,CAIA,QAAgBhT,IAAZ+S,EAAuB,CACvB,IAAIU,EAAWjB,EAASzd,IAAIge,GACxBU,IACAA,EAASxR,OAAOsQ,GACM,IAAlBkB,EAAS7R,OACT2R,GAAaE,GACbjB,EAASvQ,OAAO8Q,KAK5B,QAAgB/S,IAAZgT,EAAuB,CACvB,IAAIS,EAAWjB,EAASzd,IAAIie,GACxBS,EACAA,EAASna,IAAIiZ,IAEbkB,ED7Ba,WACrB,IAAIP,EAASI,GAAiB9lB,MAI9B,OAHe,OAAX0lB,IACAA,EAAS,IAAI3P,KAEV2P,ECwBYQ,GACXD,EAASna,IAAIiZ,GACbC,EAASnlB,IAAI2lB,EAASS,OAKvBE,GAAqB,SAC5BnB,EACA7f,EACA4f,GAGA,IAAIkB,EAAWjB,EAASzd,IAAIpC,GACxB8gB,IACAA,EAASxR,OAAOsQ,GACM,IAAlBkB,EAAS7R,OACT2R,GAAaE,GACbjB,EAASvQ,OAAOtP,MC5CjBihB,GAAW,SAClBC,EACAjhB,EACAC,EACAwgB,GAEA,IAAIJ,EAAOY,EAAUC,SAAS/e,IAAI+c,GAASlf,EAAGC,IAC9C,YAAamN,IAATiT,EACO,UAGDjT,IAANqT,EACQJ,EAAKpe,IAAIwe,GAAMJ,EAAKle,IAAIse,GAAK,KAE9BJ,GCrBJc,GAAe,SAAU1B,GAChC,IAAI2B,GAAUC,EAAAA,EACd,IAAK,MAAOthB,EAAKuhB,KAAS7B,EAClB2B,EAASrhB,IACTqhB,EAASrhB,GAGjB,OAAOqhB,GAGAG,GAAe,SAAU9B,GAChC,IAAI2B,EAASC,EAAAA,EACb,IAAK,MAAOthB,EAAKuhB,KAAS7B,EAClB2B,EAASrhB,IACTqhB,EAASrhB,GAGjB,OAAOqhB,SCJEI,GAYT1nB,cACIE,KAAKynB,WAAa,IAAI1f,IACtB/H,KAAKknB,SAAW,IAAInf,IACpB/H,KAAK0nB,YAAc,IAAI3f,IACvB/H,KAAK2nB,YAAc,IAAI5f,IACvB/H,KAAK4nB,YAAc,IAAI7f,IAEvB/H,KAAK6nB,WAAQzU,EACbpT,KAAK8nB,WAAQ1U,EACbpT,KAAK+nB,WAAQ3U,EACbpT,KAAKgoB,WAAQ5U,EAGjBtT,UACIE,KAAKQ,QAGTV,QAOI,OANAE,KAAKynB,WAAWjnB,QAChBR,KAAKknB,SAAS1mB,QACdR,KAAK0nB,YAAYlnB,QACjBR,KAAK2nB,YAAYnnB,QACjBR,KAAK4nB,YAAYpnB,QACjBR,KAAKioB,cACEjoB,KAGXF,cAKI,OAJAE,KAAK6nB,WAAQzU,EACbpT,KAAK8nB,WAAQ1U,EACbpT,KAAK+nB,WAAQ3U,EACbpT,KAAKgoB,WAAQ5U,EACNpT,KAGXF,SACI6lB,EACA3f,EACAC,EACAwgB,GAKA,OC7Dc,SAClBQ,EACAtB,EACA3f,EACAC,EACAwgB,GAGA,IAAIyB,EAAUjB,EAAUQ,WAAWtf,IAAIwd,GACnCE,EAAQ,EAAYqC,EAAQliB,OAAIoN,EAChC0S,EAAQ,EAAYoC,EAAQjiB,OAAImN,EAChC2S,EAAQ,EAAYmC,EAAQjiB,OAAImN,EAEhC8U,GACAA,EAAQliB,EAAIA,EACZkiB,EAAQjiB,EAAIA,EACZiiB,EAAQzB,EAAIA,GAEZQ,EAAUQ,WAAWhnB,IAAIklB,EAAO,CAAE3f,EAAGA,EAAGC,EAAGA,EAAGwgB,EAAGA,IAErDf,GAAeC,EAAOsB,EAAUC,SAAUrB,EAAOC,EAAOC,EAAO/f,EAAGC,EAAGwgB,GACrEG,GAAcjB,EAAOsB,EAAUS,YAAa7B,EAAO7f,GACnD4gB,GAAcjB,EAAOsB,EAAUU,YAAa7B,EAAO7f,GACnD2gB,GAAcjB,EAAOsB,EAAUW,YAAa7B,EAAOU,GDoC/C0B,CAASnoB,KAAM2lB,EAAO3f,EAAGC,EAAGwgB,GAC5BzmB,KAAKioB,cACEjoB,KAGXF,SACIkG,EACAC,EACAwgB,GAGA,OAAOO,GAAShnB,KAAMgG,EAAGC,EAAGwgB,GAGhC3mB,YACIkG,EACAC,EACAwgB,GAKA,OEhFiB,SACrBQ,EACAjhB,EACAC,EACAwgB,GAGA,QAAUrT,IAANqT,EAAiB,CACjB,IAAId,EAAQqB,GAASC,EAAWjhB,EAAGC,EAAGwgB,GACtC,QAAcrT,IAAVuS,EACA,OAGJsB,EAAUQ,WAAWpS,OAAOsQ,GAC5Ba,GAAoBS,EAAUC,SAAUlhB,EAAGC,EAAGwgB,GAC9CM,GAAmBE,EAAUS,YAAa1hB,EAAG2f,GAC7CoB,GAAmBE,EAAUU,YAAa1hB,EAAG0f,GAC7CoB,GAAmBE,EAAUW,YAAanB,EAAGd,OAE1C,CAEH,IAAIU,EAAOW,GAASC,EAAWjhB,EAAGC,GAClC,GAAIogB,EAAM,CACN,IAAK,MAAOI,EAAGd,KAAUU,EACrBY,EAAUQ,WAAWpS,OAAOsQ,GAE5BoB,GAAmBE,EAAUS,YAAa1hB,EAAG2f,GAC7CoB,GAAmBE,EAAUU,YAAa1hB,EAAG0f,GAC7CoB,GAAmBE,EAAUW,YAAanB,EAAGd,GAIjDa,GAAoBS,EAAUC,SAAUlhB,EAAGC,KF8C/CmiB,CAAYpoB,KAAMgG,EAAGC,EAAGwgB,GACxBzmB,KAAKioB,cACEjoB,KAGXF,SACI6lB,GAGA,OG9Fc,SAClBsB,EACAtB,GAGA,OAAOsB,EAAUQ,WAAWxf,IAAI0d,GHyFrB0C,CAASroB,KAAM2lB,GAG1B7lB,SACIkG,EACAC,EACAwgB,GAGA,OInGc,SAClBQ,EACAjhB,EACAC,EACAwgB,GAGA,OAAyC,OAAjCO,GAASC,EAAWjhB,EAAGC,EAAGwgB,GJ4FvBjT,CAASxT,KAAMgG,EAAGC,EAAGwgB,GAGhC3mB,OACI6lB,GAGA,OK3GY,SAChBsB,EACAtB,GAGA,OAAOsB,EAAUQ,WAAWtf,IAAIwd,IAAU,KLsG/B2C,CAAOtoB,KAAM2lB,GAGxB4C,WAII,YAHmBnV,IAAfpT,KAAK6nB,QACL7nB,KAAK6nB,MAAQV,GAAannB,KAAK0nB,cAE5B1nB,KAAK6nB,MAGhBW,WAII,YAHmBpV,IAAfpT,KAAK8nB,QACL9nB,KAAK8nB,MAAQP,GAAavnB,KAAK0nB,cAE5B1nB,KAAK8nB,MAGhBW,WAII,YAHmBrV,IAAfpT,KAAK+nB,QACL/nB,KAAK+nB,MAAQZ,GAAannB,KAAK2nB,cAE5B3nB,KAAK+nB,MAGhBW,WAII,YAHmBtV,IAAfpT,KAAKgoB,QACLhoB,KAAKgoB,MAAQT,GAAavnB,KAAK2nB,cAE5B3nB,KAAKgoB,OM1Ib,IAAIW,GAAgB,SACvBC,EACAvoB,GAGA,IAAIuoB,EAAMC,aAGV,QAAqBzV,IAAhBwV,EAAMvoB,OAAyBuoB,EAAMvoB,OAASA,EAC/CuoB,EAAMvoB,MAAQA,MADlB,CAMA,IAAK,IAAI2F,EAAI3F,EAAO2F,EAAI4iB,EAAMvoB,MAAO2F,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAI2iB,EAAMtoB,OAAQ2F,KAKtC2iB,EAAMvoB,MAAQA,ICpBPyoB,GAAiB,SACxBF,EACAtoB,GAGA,IAAIsoB,EAAMC,aAGV,QAAsBzV,IAAjBwV,EAAMtoB,QAA0BsoB,EAAMtoB,QAAUA,EACjDsoB,EAAMtoB,OAASA,MADnB,CAMA,IAAK,IAAI0F,EAAI,EAAGA,EAAI4iB,EAAMvoB,MAAO2F,IAC7B,IAAK,IAAIC,EAAI3F,EAAQ2F,EAAI2iB,EAAMtoB,OAAQ2F,KAM3C2iB,EAAMtoB,OAASA,ICjBRyoB,GAAiB,SACxBH,EACAI,EACAC,EACAC,GAGA,OAAON,EAAM3B,UAAUkC,SAASH,EAAOC,EAAOC,UCPrCE,GAKTtpB,YAAYnB,GACRqB,KAAKrB,OAASA,EACdqB,KAAK4oB,MAAQ,KACb5oB,KAAKqpB,SAAU,EACfrpB,KAAKqX,OAGTvX,OACkC,iBAAjBE,KAAW,QAAmBA,KAAKrB,OAAO2qB,IACnDtpB,KAAKrB,OAAO2qB,GAAG,UAAWtpB,KAAKuI,QAASvI,MAIhDF,UACQE,KAAK4oB,OACL5oB,KAAK4oB,MAAMW,YAAYvpB,KAAKrB,QAGhCqB,KAAKrB,YAASyU,EACdpT,KAAK4oB,MAAQ,KAGjB9oB,SAAS8oB,GAGL,OADA5oB,KAAK4oB,MAAQA,EACN5oB,KAGXwpB,cACI,OAAkB,MAAdxpB,KAAK4oB,MACE,KAEJ5oB,KAAK4oB,MAAMa,eAAezpB,KAAKrB,QAG1CmB,SAASopB,GAEL,GAAkB,MAAdlpB,KAAK4oB,MACL,OAAO5oB,KAGX,IAAIwpB,EAAUxpB,KAAKwpB,QAEnB,OADAxpB,KAAK4oB,MAAMc,SAAS1pB,KAAKrB,OAAQ6qB,EAAQxjB,EAAGwjB,EAAQvjB,EAAGijB,GAAO,GACvDlpB,KAGXF,WAAW2T,GAAiB,GAGxB,OADAzT,KAAKqpB,QAAU5V,EACRzT,KAGXF,aACI6pB,EACAlW,GAAiB,GAGa,kBAAlBzT,KAAY,UACpBA,KAAKqpB,QAAU,IAGnB,IAAIA,EAAUrpB,KAAKqpB,QACnB,GAA2B,mBAAU,CACjC,IAAIO,EAAaD,EACjB,IAAK,IAAIE,KAAOD,EACZP,EAAQQ,GAAOD,EAAWC,QAG9BR,EAAQM,GAAalW,EAEzB,OAAOzT,KAGXF,aAAa6pB,GAET,MAA8B,kBAAlB3pB,KAAY,YAInBA,KAAKqpB,QAAQtE,eAAe4E,IAGtB3pB,KAAKqpB,QAAQM,KCzFzB,IAAIG,GAAe,SACtBnE,GAMA,OAHKA,EAAMZ,eAAe,cACtBY,EAAMoE,SAAW,IAAIX,GAAUzD,IAE5BA,EAAMoE,UCNNC,GAAY,SACnBpB,EACAjD,EACAqD,EACAC,GAGA,QAAc7V,IAAVuS,EAAqB,CACrB,IAAIsE,EAAarB,EAAMsB,cACvB,IAAK,IAAIrlB,EAAI,EAAGslB,EAAMF,EAAWvrB,OAAQmG,EAAIslB,EAAKtlB,IAAK,CACnD,IAAI8gB,EAAQsE,EAAWplB,GACnB2kB,EAAUZ,EAAMa,eAAe9D,GAEnCiD,EAAMwB,gBAAgBZ,EAAQxjB,EAAGwjB,EAAQvjB,EAAG0f,QAE7C,CACH,QAAcvS,IAAV4V,EAAqB,CACrB,IAAIQ,EAAUZ,EAAMa,eAAe9D,GACnCqD,EAAQQ,EAAQxjB,EAChBijB,EAAQO,EAAQvjB,EAGpB2iB,EAAMwB,gBAAgBpB,EAAOC,EAAOtD,KC3BjC0E,GAAU,SACjB3R,EACAC,EACAC,EACAC,GAGA,OAAO5J,KAAKqb,MAAMzR,EAAKF,EAAIC,EAAKF,ICPpC,MAAM6R,GAAa,IAAMtb,KAAKub,GAEvB,IAAIC,GAAW,SAAUC,GAE5B,OAAOA,EAAUH,ICJVI,GAAkB,SACzBC,EACAC,GAGA,IAAIC,EAAaD,EAASD,EAC1B,OAAmB,IAAfE,EACO,EAIJA,EAAsB,IADjB7b,KAAK8b,OAAOD,IAAe,KAAQ,MCmB/CE,GAAqB,CAAEhlB,EAAG,EAAGC,EAAG,GCiFpC,IAAYglB,GCvEAC,IDuEZ,SAAYD,GACRA,aACAA,+BACAA,aACAA,aACAA,2BACAA,aACAA,eAPJ,CAAYA,KAAAA,QCvEZ,SAAYC,GACRA,wBACAA,wBACAA,wBACAA,wBAJJ,CAAYA,KAAAA,QCjCL,ICNIC,GAAY,SAAU5R,EAAarK,GAC1C,OAAOD,KAAK8b,MAAM9b,KAAKmc,UAAYlc,EAAMqK,EAAM,GAAKA,ICD7C8R,GAAgB,SACvBC,EACAC,EAAqB,EACrB7sB,EAAiB4sB,EAAM5sB,QAGvB,IAAI8sB,EAAcD,EAAatc,KAAK8b,MAAM9b,KAAKmc,SAAW1sB,GAC1D,YAA+B0U,IAAvBkY,EAAME,GAA8B,KAAOF,EAAME,ICmCzDC,GAAqB,CAAEzlB,EAAG,EAAGC,EAAG,GCpCzBylB,GAAuB,SAC9B9C,EACAjD,EACAgG,EACAC,EACA9P,GAGA,IAAI+P,EAAYjD,EAAMa,eAAe9D,GACrC,GAAkB,OAAdkG,EACA,OAAO,KAGiB,qBAEpBF,GAD6B,IAA7BA,EAAWpX,QAAQ,KACNuX,SAASH,GAETA,EAAWjL,MAAM,KAAK+E,IAAKoE,GAAQiC,SAASjC,EAAK,MAItE,IAwBIkC,EAxBAC,EAA6C,mBAC7CC,EAA0C,mBAC9C,GAAID,GAAqBC,EAAkB,CAEvC,IAAI7E,EAASwB,EAAMsD,KAAKC,qBACpBN,EACAF,EACAC,EACA9P,GAMJ,OAJA8M,EAAMwD,cAAchF,EAAOphB,EAAGohB,EAAOnhB,EAAGmhB,GACtB,OAAbA,EAAOphB,GAA6B,OAAbohB,EAAOnhB,IAC/BmhB,EAAS,MAENA,EAWX,GARKvE,MAAMC,QAAQhH,KACfA,EAAM,IAES,OAAf6P,IACAA,EAAa/C,EAAMsD,KAAKG,eAIxBL,EAEA,GAAInJ,MAAMC,QAAQ8I,GACd,IAAK,IAAI/mB,EAAI,EAAGslB,EAAMyB,EAASltB,OAAQmG,EAAIslB,EAAKtlB,IAC5CknB,EAAeL,GAAqB9C,EAAOiD,EAAWF,EAAYC,EAAS/mB,IACtD,OAAjBknB,GACAjQ,EAAIrd,KAAKstB,OAGd,CACH,IAAIO,EACAC,EACAC,EAOJ,KALIF,IAAAA,EAAM,EACNC,MAAAA,GAAUD,EAAM,EAAK,GAAK,GAC1BE,KAAAA,GAASF,GAAOC,EAAS,GAAK,IAC9BX,GAEAW,IAAUD,EACVP,EAAeL,GAAqB9C,EAAOiD,EAAWF,EAAYW,GAC7C,OAAjBP,GACAjQ,EAAIrd,KAAKstB,QAEV,GAAIQ,EAAQD,EACf,IAAK,IAAIznB,EAAI0nB,EAAO1nB,GAAKynB,EAAKznB,GAAK2nB,EAC/BT,EAAeL,GAAqB9C,EAAOiD,EAAWF,EAAY9mB,GAC7C,OAAjBknB,GACAjQ,EAAIrd,KAAKstB,QAIjB,IAAK,IAAIlnB,EAAI0nB,EAAO1nB,GAAKynB,EAAKznB,GAAK2nB,EAC/BT,EAAeL,GAAqB9C,EAAOiD,EAAWF,EAAY9mB,GAC7C,OAAjBknB,GACAjQ,EAAIrd,KAAKstB,QAQzB,IAAK,IAAIlnB,EAAI,EAAGslB,EAAOwB,EAAwBjtB,OAAQmG,EAAIslB,EAAKtlB,IACxDonB,GACAF,EAAeL,GAAqB9C,EAAOiD,EAAWF,EAAW9mB,GAAI+mB,GAChD,OAAjBG,GACAjQ,EAAIrd,KAAKstB,IAGbL,GAAqB9C,EAAOiD,EAAWF,EAAW9mB,GAAI+mB,EAAU9P,GAM5E,OAAOA,GC5GA2Q,GAAO,SACdhZ,EACA8F,EACArK,GAGA,IAAIiH,EAAQjH,EAAMqK,EAClB,OAAQA,IAAU9F,EAAQ8F,GAAOpD,EAASA,GAASA,GC2BnDsV,GAAqB,CAAEzlB,EAAG,EAAGC,EAAG,GCAhCymB,GAAgB,SAChBrD,EACAM,GAGA,OAAiB,IAAZN,IAAmC,IAAZA,EACjBA,GAEwB,IAAvBA,EAAQM,IC/BxB,MAAMgD,GAAgB,EAAV1d,KAAKub,GCXV,ICOIoC,GAAgB,SACvBhE,EACAiE,EACAC,EACAC,EACAC,GAGA,IAAIC,EAAUrE,EAAMa,eAAeoD,GAC/BK,EAAUtE,EAAMa,eAAeqD,GAC/BK,EAAcvE,EAAMwE,aAAaH,EAASC,GFjB3B,IAAUG,EAAAA,EEkBAF,EAA7BA,GFjBAE,GAAgBV,KAEH,EACFU,EAGAA,EAAQV,GEYnB,IAAIW,EAAare,KAAKsS,IAAI4L,EAAcJ,GACxCO,EAAare,KAAKsK,IAAI+T,EAAYX,GAAMW,GACxC,IAAIC,EAAWP,EAAO,EACtB,ODtBe,SACftb,EACAD,EACA+b,EAAkB,MAGlB,OAAOve,KAAKsS,IAAI7P,EAAID,GAAK+b,ECgBlBC,CAAMH,EAAYC,IAAcD,EAAaC,GAGxD,MAAMZ,GAAgB,EAAV1d,KAAKub,GCpBV,IC0BHiB,GAAqB,CAAEzlB,EAAG,EAAGC,EAAG,GCLhCwlB,GAAqB,CAAEzlB,EAAG,EAAGC,EAAG,GCIhCwlB,GAAqB,CAAEzlB,EAAG,EAAGC,EAAG,GCvBzBynB,GAAqB,SAC5B9E,EACAI,EACAC,EACAnN,EAAgB,IAGhB,IAAIuK,EAAOuC,EAAM3B,UAAUkC,SAASH,EAAOC,GAC3C,IAAK,MAAOC,EAAOvD,KAAUU,EACzBvK,EAAIrd,KAAKknB,GAEb,OAAO7J,GCAP6R,GAAwB,CAAE3nB,EAAG,EAAGC,EAAG,GClBvC,IAAY2nB,GAOAC,IAPZ,SAAYD,GACRA,+BACAA,6BAFJ,CAAYA,KAAAA,QAOZ,SAAYC,GACRA,sBACAA,sBAFJ,CAAYA,KAAAA,QCJZ,MAAMC,GAAwC,CAC1C,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,GAAI,IAEHC,GAAuCD,GCD7C,IAAIE,GAAgB,SAChBC,GAGA,IACIntB,EACAkF,EACAC,EAHA6V,EAA8B,GAIlC,IAAK,IAAI+N,KAAOoE,EACZntB,EAAQmtB,EAAOpE,GACf7jB,EAAIlF,EAAM,GACVmF,EAAInF,EAAM,GACLgb,EAAIiJ,eAAe/e,KACpB8V,EAAI9V,GAAK,IAEb8V,EAAI9V,GAAGC,GAAK6lB,SAASjC,GAEzB,OAAO/N,GAGckS,GAAcE,IACfF,GAAcG,ICjCtC,IAAYP,GASAQ,GASAC,IAlBZ,SAAYT,GACRA,qBACAA,uBACAA,qBACAA,uBAJJ,CAAYA,KAAAA,QASZ,SAAYQ,GACRA,aACAA,mBACAA,aACAA,uBAJJ,CAAYA,KAAAA,QASZ,SAAYC,GACRA,mBACAA,iBAFJ,CAAYA,KAAAA,QCwJZ,MAAMC,GAAQrf,KAAKsf,KAAK,YCxJRC,GACZ9qB,EACA+qB,EACAC,EACA5S,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,IAOxC,QAJY,IAAR3K,IACAA,EAAM6S,IAGFjrB,GACJ,KAAKkqB,GAAWgB,MACZ9S,EAAI9V,EAAIyoB,GAAOC,GAAa,EAANA,IAAY,EAClC5S,EAAI2K,EAAIiI,EACR,MAEJ,KAAKd,GAAWiB,OACZ/S,EAAI9V,EAAIyoB,GAAOC,GAAa,EAANA,IAAY,EAClC5S,EAAI2K,EAAIiI,EACR,MAEJ,KAAKd,GAAWkB,MACZhT,EAAI9V,EAAIyoB,EACR3S,EAAI2K,EAAIiI,GAAOD,GAAa,EAANA,IAAY,EAClC,MACJ,KAAKb,GAAWmB,OACZjT,EAAI9V,EAAIyoB,EACR3S,EAAI2K,EAAIiI,GAAOD,GAAa,EAANA,IAAY,EAI1C,OADA3S,EAAI7V,GAAK6V,EAAI9V,EAAI8V,EAAI2K,EACd3K,WA0CKkT,GACZtrB,EACAsC,EACAC,EACAwgB,EACA3K,EAAyB,CAAE9V,EAAG,EAAGC,EAAG,IAOpC,QAJY,IAAR6V,IACAA,EAAMmT,IAGFvrB,GACJ,KAAKkqB,GAAWgB,MACZ9S,EAAI9V,EAAIA,GAAKygB,GAAS,EAAJA,IAAU,EAC5B3K,EAAI7V,EAAIwgB,EACR,MACJ,KAAKmH,GAAWiB,OACZ/S,EAAI9V,EAAIA,GAAKygB,GAAS,EAAJA,IAAU,EAC5B3K,EAAI7V,EAAIwgB,EACR,MAEJ,KAAKmH,GAAWkB,MACZhT,EAAI9V,EAAIA,EACR8V,EAAI7V,EAAIwgB,GAAKzgB,GAAS,EAAJA,IAAU,EAC5B,MACJ,KAAK4nB,GAAWmB,OACZjT,EAAI9V,EAAIA,EACR8V,EAAI7V,EAAIwgB,GAAKzgB,GAAS,EAAJA,IAAU,EAGpC,OAAO8V,EAkCX,IAAI6S,GAAqB,CAAE3oB,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,GACtCwI,GAAqB,CAAEjpB,EAAG,EAAGC,EAAG,GCnHhCipB,GAAsB,CAAElpB,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,GACvC0I,GAAsB,CAAEnpB,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,GCzBvCyI,GAAsB,CAAElpB,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,GACvC0I,GAAsB,CAAEnpB,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,GCjBhC2I,GAAa,SACpBC,EACArG,EACAC,EACAnN,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGX,qBACnBgjB,EAAQD,EAAM/iB,EACd+iB,EAAQA,EAAMhjB,IAGN,IAAR8V,IACAA,EAAM6R,IAGV,IAAI2B,EAAUtG,EAAQqG,EAAQhvB,MAC1BkvB,EAAUtG,EAAQoG,EAAQ/uB,OAC9B,OAAQ+uB,EAAQ3rB,MACZ,KAAKkqB,GAAWgB,MACA,EAAR3F,IACAqG,GAAUD,EAAQG,YAEtBD,GAAU,IACV,MAEJ,KAAK3B,GAAWiB,OACA,EAAR5F,IACAqG,GAAUD,EAAQG,YAEtBD,GAAU,IACV,MAEJ,KAAK3B,GAAWkB,MACZQ,GAAU,IACE,EAARtG,IACAuG,GAAUF,EAAQI,aAEtB,MAEJ,KAAK7B,GAAWmB,OACZO,GAAU,IACE,EAARtG,IACAuG,GAAUF,EAAQI,aAQ9B,OAJAH,GAAUD,EAAQrpB,EAClBupB,GAAUF,EAAQppB,EAClB6V,EAAI9V,EAAIspB,EACRxT,EAAI7V,EAAIspB,EACDzT,GAGP6R,GAAwB,CAAE3nB,EAAG,EAAGC,EAAG,GCzDvC,MAAMypB,GAAazgB,KAAKub,GAAK,IAEtB,ICmFHmF,GAAyB,GCPtB,IAAIC,GAAqD,CAzE7B,CAC/B,CACI,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,GAAI,IAET,CACI,CAAC,EAAI,GACL,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,GAAK,KAGsB,CAChC,CACI,CAAC,EAAI,GACL,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,GAAK,IAEV,CACI,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,GAAI,KAGsB,CAC/B,CACI,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,GAAI,GACL,CAAC,GAAK,IAEV,CACI,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,EAAI,KAGuB,CAChC,CACI,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,EAAI,IAET,CACI,CAAC,EAAI,GACL,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,GAAI,GACL,CAAC,GAAK,MC/DV5B,GAAgB,SAChBC,GAGA,IACIjoB,EAAWC,EADX6V,EAAmC,GAEvC,IAAK,IAAI+N,KAAOoE,GACVjoB,EAAGC,GAAKgoB,EAAOpE,GACZ/N,EAAIiJ,eAAe/e,KACpB8V,EAAI9V,GAAK,IAEb8V,EAAI9V,GAAGC,GAAK6lB,SAASjC,GAEzB,OAAO/N,GAKA+T,GAAqD,CAC5D,CACI7B,GAAc4B,GAAuB,GAAG,IACxC5B,GAAc4B,GAAuB,GAAG,KAE5C,CACI5B,GAAc4B,GAAuB,GAAG,IACxC5B,GAAc4B,GAAuB,GAAG,KAE5C,CACI5B,GAAc4B,GAAuB,GAAG,IACxC5B,GAAc4B,GAAuB,GAAG,KAE5C,CACI5B,GAAc4B,GAAuB,GAAG,IACxC5B,GAAc4B,GAAuB,GAAG,eC1ChCE,GACZpsB,EACAslB,EACAC,GAGA,IAAI8G,EACJ,OAAQrsB,GACJ,KAAKkqB,GAAWgB,MAChB,KAAKhB,GAAWiB,OACZkB,EAAiB,EAAR9G,EACT,MAEJ,KAAK2E,GAAWkB,MAChB,KAAKlB,GAAWmB,OACZgB,EAAiB,EAAR/G,EAGjB,OAAO+G,ECfJ,ICCIrE,GAAuB,SAC9BsE,EACAnE,EACAlC,EACAiC,EACA9P,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,KAGtB,IAAR6V,IACAA,EAAM2P,IAGV,IAAI/nB,EAAOssB,EAAStsB,KAChBusB,EAAWpE,EAAU7lB,EACrBkqB,EAAWrE,EAAU5lB,EAEzB,GAAiB,IAAb2lB,EAAgB,CAChB,IAAImE,EAASD,GAAUpsB,EAAMusB,EAAUC,GACvCpU,EAAI9V,EAAIiqB,EAAWL,GAAuBlsB,GAAMqsB,GAAQpG,GAAW,GACnE7N,EAAI7V,EAAIiqB,EAAWN,GAAuBlsB,GAAMqsB,GAAQpG,GAAW,QAChE,GAAiB,IAAbiC,EACP9P,EAAI9V,EAAIiqB,EACRnU,EAAI7V,EAAIiqB,MACL,CACH,IACIC,EACAC,EACAC,EAHAC,EAAU9B,GAAQ9qB,EAAMusB,EAAUC,GAAU,GAKhD,OAAQvG,GACJ,KAAK,EACDwG,EAAWG,EAAQtqB,EACnBoqB,EAAWE,EAAQrqB,EAAI2lB,EACvByE,EAAWC,EAAQ7J,EAAImF,EACvB,MACJ,KAAK,EACDuE,EAAWG,EAAQtqB,EAAI4lB,EACvBwE,EAAWE,EAAQrqB,EACnBoqB,EAAWC,EAAQ7J,EAAImF,EACvB,MACJ,KAAK,EACDuE,EAAWG,EAAQtqB,EAAI4lB,EACvBwE,EAAWE,EAAQrqB,EAAI2lB,EACvByE,EAAWC,EAAQ7J,EACnB,MACJ,KAAK,EACD0J,EAAWG,EAAQtqB,EACnBoqB,EAAWE,EAAQrqB,EAAI2lB,EACvByE,EAAWC,EAAQ7J,EAAImF,EACvB,MACJ,KAAK,EACDuE,EAAWG,EAAQtqB,EAAI4lB,EACvBwE,EAAWE,EAAQrqB,EACnBoqB,EAAWC,EAAQ7J,EAAImF,EACvB,MACJ,QACIuE,EAAWG,EAAQtqB,EAAI4lB,EACvBwE,EAAWE,EAAQrqB,EAAI2lB,EACvByE,EAAWC,EAAQ7J,EAG3BuI,GAAQtrB,EAAMysB,EAAUC,EAAUC,EAAUvU,GAGhD,OAAOA,GAGP2P,GAAuB,CAAEzlB,EAAG,EAAGC,EAAG,GClE/B,IAAIsqB,GAAY,SACnBlB,EACAC,EACAC,EACAzT,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAclC,IAAIuqB,EACAjf,EAEJ,OAdwB,qBACpBge,EAASD,EAAOrpB,EAChBqpB,EAASA,EAAOtpB,IAGR,IAAR8V,IACAA,EAAM2P,IAGV6D,GAAUD,EAAQrpB,EAClBupB,GAAUF,EAAQppB,EAIVopB,EAAQ3rB,MACZ,KAAKkqB,GAAWgB,MAChB,KAAKhB,GAAWiB,OACZtd,EAAKge,GA3BA,EAAI,GA2BgBF,EAAQ/uB,OACjCkwB,EAAKlB,EAASD,EAAQhvB,MA3BjB,EAAI,GA2BiCkvB,EAASF,EAAQ/uB,QAC3D,MAEJ,KAAKstB,GAAWkB,MAChB,KAAKlB,GAAWmB,OACZxd,EAAKge,EAASF,EAAQ/uB,OAhCjB,EAAI,GAgCkCgvB,EAASD,EAAQhvB,OAC5DmwB,EAAKlB,GAlCA,EAAI,GAkCgBD,EAAQhvB,MAIzC,IAAIowB,WXqFJD,EACAjf,EACAuK,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,IASxC,OANY,IAAR3K,IACAA,EAAM6S,IAEV7S,EAAI9V,EAAIwqB,EACR1U,EAAI7V,GAAKuqB,EAAIjf,EACbuK,EAAI2K,EAAIlV,EACDuK,EWhGI4U,CAAQF,EAAGjf,EAAGod,IAGzB,gBXSA3oB,EACAC,EACAwgB,EACA3K,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,IAGrB,qBAEfzgB,GADA8V,EAAM9V,GACEA,EACRC,EAAI6V,EAAI7V,EACRwgB,EAAI3K,EAAI2K,IAGA,IAAR3K,IACAA,EAAM6S,IAGV,IAAIgC,EAAK1hB,KAAK2hB,MAAM5qB,GAChB6qB,EAAK5hB,KAAK2hB,MAAM3qB,GAChB6qB,EAAK7hB,KAAK2hB,MAAMnK,GAEhBsK,EAAK9hB,KAAKsS,IAAIoP,EAAK3qB,GACnBgrB,EAAK/hB,KAAKsS,IAAIsP,EAAK5qB,GACnBgrB,EAAKhiB,KAAKsS,IAAIuP,EAAKrK,GAElBsK,EAAKC,GAAQD,EAAKE,EACnBN,GAAME,EAAKC,EACJE,EAAKC,EACZJ,GAAMF,EAAKG,EAEXA,GAAMH,EAAKE,EAEf/U,EAAI9V,EAAI2qB,EACR7U,EAAI7V,EAAI4qB,EACR/U,EAAI2K,EAAIqK,EW7CRI,CAAUT,GACVzB,GAAQK,EAAQ3rB,KAAM+sB,EAAKzqB,EAAGyqB,EAAKxqB,EAAGwqB,EAAKhK,EAAG3K,GACvCA,GAGP6S,GAAqB,CAAE3oB,EAAG,EAAGC,EAAG,EAAGwgB,EAAG,GACtCgF,GAAuB,CAAEzlB,EAAG,EAAGC,EAAG,GCQlCwlB,GAAuB,CAAEzlB,EAAG,EAAGC,EAAG,GCHlCwlB,GAAuB,CAAEzlB,EAAG,EAAGC,EAAG,GCMlCwlB,GAAuB,CAAEzlB,EAAG,EAAGC,EAAG,SCxCzBkrB,iBhBATrxB,aAAYkG,EACRA,EAAI,EAACC,EACLA,EAAI,EAACmrB,OACLA,EAAkBC,UAClBA,EAAY,EAACC,WACbA,EAAa,EAACC,YACdA,EAAcnD,GAAYpoB,EAACwrB,aAC3BA,EAAenD,GAAaoD,KACnB,IAETzxB,KAAK0xB,QAAQH,EAAaC,GAC1BxxB,KAAK2xB,mBAEL3xB,KAAK4xB,kBAAkB5rB,EAAGC,QAEXmN,IAAXge,EACApxB,KAAK6xB,UAAUT,GAEfpxB,KAAK8xB,YAAYT,EAAWC,GAIpCxxB,UAASkG,EACLA,EAAI,EAACC,EACLA,EAAI,EAACmrB,OACLA,EAAkBC,UAClBA,EAAY,EAACC,WACbA,EAAa,EAACC,YACdA,EAAcnD,GAAYpoB,EAACwrB,aAC3BA,EAAenD,GAAaoD,KACpB,IAYR,OAVAzxB,KAAK0xB,QAAQH,EAAaC,GAC1BxxB,KAAK2xB,mBAEL3xB,KAAK4xB,kBAAkB5rB,EAAGC,QACXmN,IAAXge,EACApxB,KAAK6xB,UAAUT,GAEfpxB,KAAK8xB,YAAYT,EAAWC,GAGzBtxB,KAGXF,SACI,MAAO,CACHkG,EAAGhG,KAAKgG,EACRC,EAAGjG,KAAKiG,EAERmrB,OAAQpxB,KAAKoxB,OACbC,UAAWrxB,KAAKqxB,UAChBC,WAAYtxB,KAAKsxB,WACjBC,YAAavxB,KAAKuxB,YAClBC,aAAcxxB,KAAKwxB,cAI3B1xB,kBAAkBkG,EAAWC,GAGzB,OAFAjG,KAAKgG,EAAIA,EACThG,KAAKiG,EAAIA,EACFjG,KAGXK,YACI,OAAOL,KAAKhC,OAGhBqC,UAAUoT,GACNzT,KAAKhC,OAASyV,EACdzT,KAAKwvB,WAAa/b,EAAQ,EAG9BnT,aACI,OAAON,KAAK/B,QAGhBqC,WAAWmT,GACPzT,KAAK/B,QAAUwV,EACfzT,KAAKyvB,YAAchc,EAAQ,EAG/B3T,YAAYO,EAAgB,EAAGC,EAAiB,GAK5C,OAHAN,KAAKK,MAAQA,EACbL,KAAKM,OAASA,EACdN,KAAKoxB,YAAShe,EACPpT,KAGXqxB,gBACI,OAAOrxB,KAAKK,MAGhBgxB,cAAc5d,GACVzT,KAAKK,MAAQoT,EAGjB6d,iBACI,OAAOtxB,KAAKM,OAGhBgxB,eAAe7d,GACXzT,KAAKM,OAASmT,EAGlB3T,UAAUsxB,EAAiB,GAEvB,IAAIC,EACAC,EAUJ,OATItxB,KAAKuxB,cAAgBnD,GAAYnoB,GACjCorB,EAAY,EAAID,EAChBE,EAAahD,GAAQ8C,IAErBC,EAAY/C,GAAQ8C,EACpBE,EAAa,EAAIF,GAErBpxB,KAAK8xB,YAAYT,EAAWC,GAC5BtxB,KAAKoxB,OAASA,EACPpxB,KAGXF,mBAEI,OADAE,KAAK2rB,WAAa,EACX3rB,KAGXF,QACIyxB,EAA+C,EAC/CC,EAAkD,GAiBlD,MAd6B,qBACzBD,EAAcnD,GAAYmD,IAEA,qBAC1BC,EAAenD,GAAamD,IAGhCxxB,KAAKuxB,YAAcA,EACnBvxB,KAAKwxB,aAAeA,EAChBD,IAAgBnD,GAAYnoB,EAC5BjG,KAAK0D,KAAQ8tB,IAAiBnD,GAAa0D,KAAQnE,GAAWmB,OAASnB,GAAWkB,MAElF9uB,KAAK0D,KAAQ8tB,IAAiBnD,GAAa0D,KAAQnE,GAAWiB,OAASjB,GAAWgB,MAE/E5uB,OgB7IXgyB,YACI,OAAO,EAIX3F,oBACI,OAAO4F,GAIXC,qBACI,OAAOC,GAGXryB,iBACIsyB,EACAC,EACAzB,GAAiB,GAGjB,OdzCsB,SAC1BvB,EACA+C,EACAC,EACAzB,GAAiB,GAGjB,IAAIjH,EACJ6E,GAAQa,EAAQ3rB,KAAM0uB,EAAMpsB,EAAGosB,EAAMnsB,EAAGipB,IACxCV,GAAQa,EAAQ3rB,KAAM2uB,EAAMrsB,EAAGqsB,EAAMpsB,EAAGkpB,IACxC,IAAI4B,EAAK5B,GAAUnpB,EAAIkpB,GAAUlpB,EAC7BgrB,EAAK7B,GAAUlpB,EAAIipB,GAAUjpB,EAC7BgrB,EAAK9B,GAAU1I,EAAIyI,GAAUzI,EAwBjC,OAtBIkD,EADO,IAAPsH,EACaF,EAAK,EAAK,EAAI,EACb,IAAPA,EACME,EAAK,EAAK,EAAI,EACb,IAAPD,EACMC,EAAK,EAAK,EAAI,EACnBF,EAAK,GAAOC,EAAK,GAAOC,EAAK,EACzB,EAAKA,GAAOD,EAChBD,EAAK,GAAOC,EAAK,GAAOC,EAAK,EACzB,GAAOD,EAAMC,EACjBF,EAAK,GAAOC,EAAK,GAAOC,EAAK,EACzB,EAAKD,GAAOD,EAChBA,EAAK,GAAOC,EAAK,GAAOC,EAAK,EACzB,GAAOA,EAAMD,EACjBD,EAAK,GAAOC,EAAK,GAAOC,EAAK,EACzB,EAAKF,GAAOE,EAEZ,GAAOD,EAAMD,EAGzBH,IACAjH,EAAY1a,KAAK2hB,MAAMjH,IAEpBA,EcKI2I,CAAiBtyB,KAAMoyB,EAAOC,EAAOzB,GAGhD9wB,mBACI6pB,GAGA,OCjDwB,SAC5BuC,EACAvC,GAGA,OjCRc,SACdlW,EACA8F,EACArK,GAGA,IAAIiH,EAAQjH,EAAMqK,EAClB,OAAQA,IAAU9F,EAAQ8F,GAAOpD,EAASA,GAASA,EiCC5CsW,CAAK9C,EAAW,EAAGuC,EAAKP,YD4CpB4G,CAAmBvyB,KAAM2pB,GAGpC7pB,YACIsyB,EACAC,EACAG,GAAqB,GAGrB,ObzDiB,SACrBnD,EACA+C,EACAC,EACAG,GAAqB,GAGrBhE,GAAQa,EAAQ3rB,KAAM0uB,EAAMpsB,EAAGosB,EAAMnsB,EAAGipB,IACxCV,GAAQa,EAAQ3rB,KAAM2uB,EAAMrsB,EAAGqsB,EAAMpsB,EAAGkpB,IACxC,IAAI4B,EAAK5B,GAAUnpB,EAAIkpB,GAAUlpB,EAC7BgrB,EAAK7B,GAAUlpB,EAAIipB,GAAUjpB,EAC7BgrB,EAAK9B,GAAU1I,EAAIyI,GAAUzI,EACjC,OAAQxX,KAAKsS,IAAIwP,GAAM9hB,KAAKsS,IAAIyP,GAAM/hB,KAAKsS,IAAI0P,IAAO,Ea6C3CwB,CAAYzyB,KAAMoyB,EAAOC,EAAOG,GAG3C1yB,cACIkpB,EAA2B,EAC3BC,EAAgB,EAChBnN,EAAyB,IAGzB,OVhEmB,SACvBuT,EACArG,EAA2B,EAC3BC,EAAgB,EAChBnN,EAAyB,IAGzB,GAAuB,mBAAU,CAC7B,IAAI4W,EAAS1J,EACbC,EAAQyJ,EAAOzsB,EACf+iB,EAAQ0J,EAAO1sB,EAQnB,IAAIA,EACAC,EAGJ,IAVY,IAAR6V,IACAA,EAAM6T,IYjBiB,SAC3BjxB,EACAod,EAAkB,IAGlB,GAAIA,EAAIpd,SAAWA,QAEZ,GAAIod,EAAIpd,OAASA,EACpB,IAAK,IAAImG,EAAIiX,EAAIpd,OAAQmG,EAAInG,EAAQmG,IACjCiX,EAAIrd,KAAK,CAAEuH,EAAG,EAAGC,EAAG,SAGxB6V,EAAIpd,OAASA,EZQjBi0B,CAAkB,EAAG7W,KAIlB9V,EAAAA,EAAGC,EAAAA,GAAMmpB,GAAWC,EAASrG,EAAOC,SAEhB7V,IAAnBic,EAAQ+B,OAAsB,CAC9B,IAAIA,EAAS/B,EAAQ+B,OACjBwB,EAAevD,EAAQkC,cAAgBnD,GAAYyE,KAAQ,GAAK,GACpE,IAAK,IAAIhuB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IACIiuB,GADY,GAAKjuB,EAAK+tB,GD5BjBlD,GC8BT5T,EAAIjX,GAAGmB,EAAIA,EAAIorB,EAASniB,KAAK+L,IAAI8X,GACjChX,EAAIjX,GAAGoB,EAAIA,EAAImrB,EAASniB,KAAKgM,IAAI6X,QAGlC,CACH,IAAIC,EAAQ1D,EAAQG,WAChBwD,EAAWD,EAAQ,EACnBE,EAAQ5D,EAAQI,YAChByD,EAAWD,EAAQ,EACnB5D,EAAQkC,cAAgBnD,GAAYyE,MACpC/W,EAAI,GAAG9V,EAAIA,EAAI+sB,EACfjX,EAAI,GAAG7V,EAAIA,EAEX6V,EAAI,GAAG9V,EAAIA,EAAIgtB,EACflX,EAAI,GAAG7V,EAAIA,EAAIgtB,EAEfnX,EAAI,GAAG9V,EAAIA,EAAIgtB,EACflX,EAAI,GAAG7V,EAAIA,EAAIgtB,EAEfnX,EAAI,GAAG9V,EAAIA,EAAI+sB,EACfjX,EAAI,GAAG7V,EAAIA,EAEX6V,EAAI,GAAG9V,EAAIA,EAAIgtB,EACflX,EAAI,GAAG7V,EAAIA,EAAIgtB,EAEfnX,EAAI,GAAG9V,EAAIA,EAAIgtB,EACflX,EAAI,GAAG7V,EAAIA,EAAIgtB,IAEfnX,EAAI,GAAG9V,EAAIA,EAAI+sB,EACfjX,EAAI,GAAG7V,EAAIA,EAAIitB,EAEfpX,EAAI,GAAG9V,EAAIA,EAAI+sB,EACfjX,EAAI,GAAG7V,EAAIA,EAAIitB,EAEfpX,EAAI,GAAG9V,EAAIA,EACX8V,EAAI,GAAG7V,EAAIA,EAAIgtB,EAEfnX,EAAI,GAAG9V,EAAIA,EAAI+sB,EACfjX,EAAI,GAAG7V,EAAIA,EAAIitB,EAEfpX,EAAI,GAAG9V,EAAIA,EAAI+sB,EACfjX,EAAI,GAAG7V,EAAIA,EAAIitB,EAEfpX,EAAI,GAAG9V,EAAIA,EACX8V,EAAI,GAAG7V,EAAIA,EAAIgtB,GAIvB,OAAOnX,EUZIqX,CAAcnzB,KAAMgpB,EAAOC,EAAOnN,GAG7Chc,yBACI+rB,EACAuH,GAGA,ONzE8B,SAClC/D,EACAxD,EACAuH,GAGA,IAAI1vB,EAAO2rB,EAAQ3rB,KACfqsB,EAASD,GAAUpsB,EAAMmoB,EAAU7lB,EAAG6lB,EAAU5lB,GAChDotB,EAAsBxD,GAAuBnsB,GAAMqsB,GAEnDuD,EAAaF,EAAeptB,EAAI6lB,EAAU7lB,EAC1CutB,EAAaH,EAAentB,EAAI4lB,EAAU5lB,EAC9C,GAAIotB,EAAoBtO,eAAeuO,GAAa,CAChD,IAAIE,EAASH,EAAoBC,GACjC,GAAIE,EAAOzO,eAAewO,GACtB,OAAOC,EAAOD,GAGtB,OAAO,KMuDIE,CAAyBzzB,KAAM6rB,EAAWuH,GAGrDtzB,kBACI+rB,EACAlC,EACA7N,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OGnFuB,SAC3B+pB,EACAnE,EACAlC,EACA7N,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OAAOylB,GAAqBsE,EAAUnE,EAAWlC,EAAW,EAAG7N,GH4EpD4X,CAAkB1zB,KAAM6rB,EAAWlC,EAAW7N,GAGzDhc,qBACIkpB,EACAC,EACAU,GAGA,OI7F0B,SAC9B0F,EACArG,EACAC,EACAU,GAGA,OAAQA,EAAY,GAAK,EJsFdgK,CAAqB3zB,EAAMgpB,EAAOC,EAAOU,GAGpD7pB,UACIwvB,EACAC,EACAzT,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OAAOsqB,GAAUvwB,KAAMsvB,EAAQC,EAAQzT,GAG3Chc,qBACI+rB,EACAlC,EACAiC,EACA9P,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OAAOylB,GAAqB1rB,KAAM6rB,EAAWlC,EAAWiC,EAAU9P,GAGtEhc,WACIkpB,EACAC,EACAnN,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OAAOmpB,GAAWpvB,KAAMgpB,EAAOC,EAAOnN,GAG1Chc,OACI+rB,EACAnoB,EACAoY,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OH9HY,SAChBopB,EACAxD,EACAnoB,EACAoY,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGZ,qBAClBvC,EAAOunB,GAAWvnB,KAGV,IAARoY,IACAA,EAAM2P,IAGV,IAEI0E,EACAC,EACAC,EAJAC,EAAU9B,GAAQa,EAAQ3rB,KAAMmoB,EAAU7lB,EAAG6lB,EAAU5lB,GAAG,GAC1D2tB,EAAWvE,EAAQ3rB,OAASkqB,GAAWgB,OAAWS,EAAQ3rB,OAASkqB,GAAWiB,OA+BlF,OA1BW,EAAPnrB,IACIkwB,GACAzD,EAAWG,EAAQrqB,EACnBmqB,EAAWE,EAAQtqB,EACnBqqB,EAAWC,EAAQ7J,IAEnB0J,GAAYG,EAAQtqB,EACpBoqB,GAAYE,EAAQ7J,EACpB4J,GAAYC,EAAQrqB,GAExBqqB,EAAQtqB,EAAImqB,EACZG,EAAQrqB,EAAImqB,EACZE,EAAQ7J,EAAI4J,GAEL,EAAP3sB,IACIkwB,GACAzD,GAAYG,EAAQrqB,EACpBmqB,GAAYE,EAAQtqB,EACpBqqB,GAAYC,EAAQ7J,IAEpB0J,EAAWG,EAAQtqB,EACnBoqB,EAAWE,EAAQ7J,EACnB4J,EAAWC,EAAQrqB,IAG3B+oB,GAAQK,EAAQ3rB,KAAMysB,EAAUC,EAAUC,EAAUvU,GAC7CA,EG+EI+X,CAAO7zB,KAAM6rB,EAAWnoB,EAAMoY,GAGzChc,OACI+rB,EACAiI,EACAC,EACAjY,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OF5IY,SAChBopB,EACAxD,EACAmI,EACAC,EACAnY,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,KAGtB,IAAR6V,IACAA,EAAM2P,IAGV,IAAIyI,EAAOrI,EAAU7lB,EAAIguB,EACrBG,EAAOtI,EAAU5lB,EAAIguB,EACzB,OAAQ5E,EAAQ3rB,MACZ,KAAKkqB,GAAWgB,MACU,IAAP,EAAVqF,IACkB,IAAP,EAAPE,KACDD,GAAQ,GAGhB,MAEJ,KAAKtG,GAAWiB,OACU,IAAP,EAAVoF,IACkB,IAAP,EAAPE,KACDD,GAAQ,GAGhB,MAEJ,KAAKtG,GAAWkB,MACU,IAAP,EAAVkF,IACiB,IAAN,EAAPE,KACDC,GAAQ,GAGhB,MACJ,KAAKvG,GAAWmB,OACU,IAAP,EAAViF,IACiB,IAAN,EAAPE,KACDC,GAAQ,GAOxB,OAFArY,EAAI9V,EAAIkuB,EACRpY,EAAI7V,EAAIkuB,EACDrY,EE4FIsY,CAAOp0B,KAAM6rB,EAAWiI,EAAaC,EAAajY,GAG7Dhc,kBACIu0B,EACAjD,EACAtV,EAAkB,IAGlB,OKpJuB,SAC3BuT,EACAgF,EACAjD,EACAtV,EAAkB,IAGlB,IAIIjX,EACAyvB,EACAC,EANAC,EAAahG,GAAQa,EAAQ3rB,KAAM2wB,EAAaruB,EAAGquB,EAAapuB,GAAG,GACnEwuB,EAAKD,EAAWxuB,EAEhB0uB,GADKF,EAAWvuB,EACXuuB,EAAW/N,GAMpB,IADA8N,EAAInD,EACCvsB,EAAI,EAAGA,IAAMusB,EAAQvsB,IACtByvB,GAAKzvB,EAAI0vB,EACTzY,EAAIrd,KAAKuwB,GAAQK,EAAQ3rB,KAAM+wB,EAAK5vB,EAAG8vB,EAAQD,EAAKH,IAIxD,IADA1vB,GAAKusB,EACAkD,EAAI,EAAGA,GAAKlD,EAAQkD,IACrBC,GAAK1vB,EAAIyvB,EACTxY,EAAIrd,KAAKuwB,GAAQK,EAAQ3rB,KAAM+wB,EAAK5vB,EAAG8vB,EAAQD,EAAKH,IAIxD,IADAD,EAAIlD,EACCmD,GAAK,EAAGA,IAAMnD,EAAQmD,IACvB1vB,GAAKyvB,EAAIC,EACTzY,EAAIrd,KAAKuwB,GAAQK,EAAQ3rB,KAAM+wB,EAAK5vB,EAAG8vB,EAAQD,EAAKH,IAIxD,IADAA,GAAKnD,EACAvsB,EAAI,EAAGA,GAAKusB,EAAQvsB,IACrByvB,GAAKzvB,EAAI0vB,EACTzY,EAAIrd,KAAKuwB,GAAQK,EAAQ3rB,KAAM+wB,EAAK5vB,EAAG8vB,EAAQD,EAAKH,IAIxD,IADA1vB,EAAIusB,EACCkD,GAAK,EAAGA,IAAMlD,EAAQkD,IACvBC,GAAK1vB,EAAIyvB,EACTxY,EAAIrd,KAAKuwB,GAAQK,EAAQ3rB,KAAM+wB,EAAK5vB,EAAG8vB,EAAQD,EAAKH,IAIxD,IADAD,GAAKlD,EACAmD,EAAI,EAAGA,GAAKnD,EAAS,EAAGmD,IACzB1vB,GAAKyvB,EAAIC,EACTzY,EAAIrd,KAAKuwB,GAAQK,EAAQ3rB,KAAM+wB,EAAK5vB,EAAG8vB,EAAQD,EAAKH,IAExD,OAAOzY,ELkGI8Y,CAAkB50B,KAAMq0B,EAAcjD,EAAQtV,GAGzDhc,OAAO+rB,EACHhC,EACA/N,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OD1JY,SAChBopB,EACAxD,EACAhC,EACA/N,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,KAGtB,IAAR6V,IACAA,EAAM2P,IAGV5B,EAAM4C,GAAK5C,EAAK,EAAG,GACnB,IACIsG,EACAC,EACAC,EAHAC,EAAU9B,GAAQa,EAAQ3rB,KAAMmoB,EAAU7lB,EAAG6lB,EAAU5lB,GAAG,GAK9D,OAAQ4jB,GACJ,KAAK,EACDsG,GAAYG,EAAQ7J,EACpB2J,GAAYE,EAAQtqB,EACpBqqB,GAAYC,EAAQrqB,EACpB,MACJ,KAAK,EACDkqB,EAAWG,EAAQrqB,EACnBmqB,EAAWE,EAAQ7J,EACnB4J,EAAWC,EAAQtqB,EACnB,MACJ,KAAK,EACDmqB,GAAYG,EAAQtqB,EACpBoqB,GAAYE,EAAQrqB,EACpBoqB,GAAYC,EAAQ7J,EACpB,MACJ,KAAK,EACD0J,EAAWG,EAAQ7J,EACnB2J,EAAWE,EAAQtqB,EACnBqqB,EAAWC,EAAQrqB,EACnB,MACJ,KAAK,EACDkqB,GAAYG,EAAQrqB,EACpBmqB,GAAYE,EAAQ7J,EACpB4J,GAAYC,EAAQtqB,EACpB,MACJ,QACImqB,EAAWG,EAAQtqB,EACnBoqB,EAAWE,EAAQrqB,EACnBoqB,EAAWC,EAAQ7J,EAK3B,OADAuI,GAAQK,EAAQ3rB,KAAMysB,EAAUC,EAAUC,EAAUvU,GAC7CA,ECuGI+Y,CAAO70B,KAAM6rB,EAAWhC,EAAK/N,GAGxChc,gBM1JuB,IACvBosB,EN4JI,OM5JJA,EN2JkBlsB,MMzJbgG,EAAIkmB,EAAK4I,cACd5I,EAAKjmB,EAAIimB,EAAK6I,cNyJH/0B,KAGXF,aMvKoB,IACpBosB,ENyKI,OMzKJA,ENwKelsB,MMtKV80B,cAAgB5I,EAAKlmB,EAC1BkmB,EAAK6I,cAAgB7I,EAAKjmB,ENsKfjG,MAIf,MAAMiyB,GAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GACzBE,GAAU,CAAC,EAAG,EAAG,GOjLvB,IAAY6C,IAAZ,SAAYA,GACRA,uBACAA,2BACAA,2BACAA,mBACAA,sBACAA,uCACAA,mCAPJ,CAAYA,KAAAA,cCICC,GAQTn1B,YACIo1B,GAEAl1B,KAAKk1B,mBAAqBA,EAC1Bl1B,KAAKm1B,SAAW,IAAIhQ,GACpBnlB,KAAKo1B,MAAQ,IAAIrtB,IACjB/H,KAAKq1B,GAAK,EAGdv1B,QACIiG,EACAuvB,GAAsB,GAGtB,IAAKt1B,KAAKo1B,MAAMntB,IAAIlC,GAAM,CACtB,IAAKuvB,EACD,OAAO,KAGX,IAAIriB,EAAkBjT,KAAKm1B,SAASv0B,MACvB,OAATqS,IACAA,EAAOjT,KAAKk1B,qBACZjiB,EAAK6D,QAAU9W,MAEnBiT,EAAKoiB,GAAKr1B,KAAKq1B,GACfpiB,EAAKlS,MAAMgF,GACX/F,KAAKo1B,MAAM30B,IAAIsF,EAAKkN,GAExBjT,KAAKq1B,KACL,IAAIpiB,EAAOjT,KAAKo1B,MAAMjtB,IAAIpC,GAE1B,OADAkN,EAAKoiB,GAAKr1B,KAAKq1B,GACRpiB,EAGXnT,eAEI,IAAIy1B,EAAOv1B,KAAKm1B,SAChB,IAAK,MAAOpvB,EAAKkN,KAASjT,KAAKo1B,MAC3BniB,EAAKkR,WACLoR,EAAK92B,KAAKwU,GAId,OAFAjT,KAAKo1B,MAAM50B,QACXR,KAAKq1B,GAAK,EACHr1B,KAGXF,cAEI,OAAOE,KAAKo1B,OC1CpB,IAAII,GAAY,UCdZ11B,YAAY21B,GACRz1B,KAAK01B,QAAU,GACf11B,KAAKy1B,cAAgBA,EAGzB31B,QACIE,KAAK01B,QAAQh3B,OAAS,EAG1BoB,KAAKd,GAEDgB,KAAK01B,QAAQj3B,KAAKO,GAGlBgB,KAAK21B,SAAS31B,KAAK01B,QAAQh3B,OAAS,GAGxCoB,MAEI,IAAIsnB,EAASpnB,KAAK01B,QAAQ,GAEtBpJ,EAAMtsB,KAAK01B,QAAQ90B,MAOvB,OAJIZ,KAAK01B,QAAQh3B,OAAS,IACtBsB,KAAK01B,QAAQ,GAAKpJ,EAClBtsB,KAAK41B,SAAS,IAEXxO,EAGXtnB,OAAOmT,GAEH,IAAIpO,EAAI7E,KAAK01B,QAAQnhB,QAAQtB,GAIzBqZ,EAAMtsB,KAAK01B,QAAQ90B,MAEnBiE,IAAM7E,KAAK01B,QAAQh3B,OAAS,IAC5BsB,KAAK01B,QAAQ7wB,GAAKynB,EAEdtsB,KAAKy1B,cAAcnJ,GAAOtsB,KAAKy1B,cAAcxiB,GAC7CjT,KAAK21B,SAAS9wB,GAEd7E,KAAK41B,SAAS/wB,IAK1BmQ,WACI,OAAOhV,KAAK01B,QAAQh3B,OAGxBoB,eAAemT,GAEXjT,KAAK21B,SAAS31B,KAAK01B,QAAQnhB,QAAQtB,IAGvCnT,SAAS+1B,GAGL,IAAI72B,EAAUgB,KAAK01B,QAAQG,GAG3B,KAAOA,EAAI,GAAG,CAGV,IAAIC,GAAYD,EAAI,GAAM,GAAK,EAC3Bl3B,EAASqB,KAAK01B,QAAQI,GAE1B,KAAI91B,KAAKy1B,cAAcz2B,GAAWgB,KAAKy1B,cAAc92B,IAQjD,MAPAqB,KAAK01B,QAAQI,GAAW92B,EACxBgB,KAAK01B,QAAQG,GAAKl3B,EAElBk3B,EAAIC,GAShBh2B,SAAS+1B,GAGL,IAAIn3B,EAASsB,KAAK01B,QAAQh3B,OACtBM,EAAkBgB,KAAK01B,QAAQG,GAC/BE,EAAoB/1B,KAAKy1B,cAAcz2B,GAE3C,OAAa,CAET,IAIIg3B,EAJAC,EAAWJ,EAAI,GAAM,EACrBK,EAAUD,EAAU,EAEpBE,EAAe,KAGnB,GAAID,EAAUx3B,EAAQ,CAElB,IAAI03B,EAASp2B,KAAK01B,QAAQQ,GAC1BF,EAAch2B,KAAKy1B,cAAcW,GAG7BJ,EAAcD,IACdI,EAAOD,GAKf,GAAID,EAAUv3B,EAAQ,CAClB,IAAI23B,EAASr2B,KAAK01B,QAAQO,GACRj2B,KAAKy1B,cAAcY,IACT,OAATF,EAAgBJ,EAAYC,KAC3CG,EAAOF,GAKf,GAAa,OAATE,EAOA,MANAn2B,KAAK01B,QAAQG,GAAK71B,KAAK01B,QAAQS,GAC/Bn2B,KAAK01B,QAAQS,GAAQn3B,EACrB62B,EAAIM,KD7GYljB,GAAoBA,EAAKqjB,GAE9CC,GAAS,SAChBC,EACAC,EACAC,EACAC,GAGA,MAAMC,EAA+B,OAAfF,EAChBG,GFfyBC,EEeEN,EAAMM,YFdlB9B,GAASwB,OACzBM,IAAa9B,GAAS,eACtB8B,IAAa9B,GAAS,gBAHN,IAAU8B,EEgB/B,MAAMC,EAAqBH,IAAkBC,EACvCG,EAAaJ,GAAgBC,EAAgBL,EAAMM,SAAW,KAEpE,IAAIG,EAAcT,EAAMS,YACxBA,EAAYC,eAEZ,IAAIC,EAAYF,EAAYG,QAAQX,GAAc,GAC9CY,EAAU,EAAiBJ,EAAYG,QAAQV,GAAY,GAAQ,KACvES,EAAU3wB,EAAI2wB,EAAUG,UAAUD,EAASL,GAE3C,IAAIO,EAAyB,KAO7B,IANIX,IACAW,EAAcJ,EACdI,EAAYC,QAAUD,EAAY/wB,GAAK+wB,EAAYD,UAAUD,EAASrC,GAASwB,QAGnFhB,GAAU/2B,KAAK04B,GACR3B,GAAUxgB,KAAO,GAAG,CAEvB,IAAIyiB,EAAWjC,GAAU50B,MAIzB,GAAIg2B,GAAiBa,IAAaJ,EAAU,CACxCE,EAAcF,EACd,MAIJI,EAASC,QAAS,EAGlB,IACIC,EACAC,EAFAC,EAAyBJ,EAASK,eAGtC,IAAK,IAAIjzB,EAAI,EAAGslB,EAAM0N,EAAUn5B,OAAQmG,EAAIslB,IAAOtlB,EAAG,CAGlD,GAFA8yB,EAAWE,EAAUhzB,GACrB+yB,EAAeD,EAASI,QAAQN,GAC5BE,EAASD,QEnEF,OFmEaE,EAEpB,SAKJ,IAAII,EAASP,EAASjmB,EAAIomB,EACtBK,EAAcN,EAASO,aE1Ef9kB,IF4EPujB,GAA+BqB,EAASrB,KAIvCsB,GAAiBD,EAASL,EAASnmB,GAGrCmmB,EAASO,SAAU,EACnBP,EAASQ,UAAUz5B,OAAS,EAC5Bi5B,EAASQ,UAAU15B,KAAKg5B,QACLrkB,IAAfukB,EAASnxB,IACTmxB,EAASnxB,EAAImxB,EAASL,UAAUD,EAASL,EAAWG,IAExDQ,EAASnmB,EAAIwmB,EACbL,EAASrB,EAAIqB,EAASnmB,EAAImmB,EAASnxB,EAG/BowB,SAGyBxjB,IAArBukB,EAASH,UACTG,EAASH,QAAUG,EAASnxB,GAAKmxB,EAASL,UAAUD,EAASrC,GAASwB,SAErEmB,EAASH,QAAUD,EAAYC,SAC9BG,EAASH,UAAYD,EAAYC,SAAaG,EAASnmB,EAAI+lB,EAAY/lB,KACzE+lB,EAAcI,IAKjBM,EAKDzC,GAAU4C,eAAeT,GAHzBnC,GAAU/2B,KAAKk5B,IAKZZ,GAAuBiB,GAAUL,EAASnmB,GAEjDmmB,EAASQ,UAAU15B,KAAKg5B,KAMpCR,EAAYM,YAAcA,EAC1B/B,GAAUh1B,SGzHH63B,GAA4C,SACnDlB,EACAE,EACAvb,EAAM,IAGN,IAAI2b,EAAWJ,EACf,KAAOI,EAASU,UAAUz5B,OAAS,GAC/Bod,EAAIrd,KAAKg5B,GACTA,EAAWA,EAASU,UAAU,GAGlC,OAAOrc,EAAIwc,WCaXC,GAAoE,GACxEA,GAAqBvD,GAASwB,OAAS6B,GACvCE,GAAqBvD,GAAS,eAAiBqD,GAC/CE,GAAqBvD,GAAS,iBAAmBqD,GACjDE,GAAqBvD,GAAS5J,QC5B0B,SACpD+L,EACAE,EACAvb,EAAM,IAGN,IAAI2b,EAAWJ,EACf,KAAOI,EAASU,UAAUz5B,OAAS,GAC/Bod,EAAIrd,KAAKg5B,GAELA,EAD8B,IAA9BA,EAASU,UAAUz5B,OACR+4B,EAASU,UAAU,GAEnB9M,GAAcoM,EAASU,WAI1C,OAAOrc,EAAIwc,WDafC,GAAqBvD,GAAStS,ME9BwB,SAClDyU,EACAE,EACAvb,EAAM,IAGN,IAAI2b,EAAWJ,EACXlK,EAAckK,EAAQmB,QAAQrB,GAClC,KAAOM,EAASU,UAAUz5B,OAAS,GAE/B,GADAod,EAAIrd,KAAKg5B,GACyB,IAA9BA,EAASU,UAAUz5B,OACnB+4B,EAAWA,EAASU,UAAU,OAC3B,CACH,IAAIM,EAAgBpR,EAAAA,EACpB,IAAK,IAAIxiB,EAAI,EAAGslB,EAAMsN,EAASU,UAAUz5B,OAAQmG,EAAIslB,EAAKtlB,IAAK,CAC3D,IAAI6zB,EAAWjB,EAASU,UAAUtzB,GAC9ByoB,EAAare,KAAKsS,IAAI8V,EAAQmB,QAAQE,GAAYvL,GAClDG,EAAamL,IACbA,EAAgBnL,EAChBmK,EAAWiB,IAM3B,OAAO5c,EAAIwc,WFMfC,GAAqBvD,GAAS2D,UG9BwB,SAClDxB,EACAE,EACAvb,EAAM,IAGN,IACI8c,EADAnB,EAAWJ,EAEf,KAAOI,EAASU,UAAUz5B,OAAS,GAE/B,GADAod,EAAIrd,KAAKg5B,GAC0B,IAA9BA,EAASU,UAAUz5B,aAAmC0U,IAAjBwlB,EAA6B,CACnE,IAAIF,EAAWjB,EAASU,UAAU,GAClCS,EAAeF,EAASG,WAAWpB,GACnCA,EAAWiB,MACR,CACH,IAAIA,EACAI,EACJ,IAAK,IAAIj0B,EAAI,EAAGslB,EAAMsN,EAASU,UAAUz5B,OAAQmG,EAAIslB,IACjDuO,EAAWjB,EAASU,UAAUtzB,GAC9Bi0B,EAAeJ,EAASG,WAAWpB,GAC/BqB,IAAiBF,GAHiC/zB,KAO1D+zB,EAAeE,EACfrB,EAAWiB,EAInB,OAAO5c,EAAIwc,WHEfC,GAAqBvD,GAAS+D,UI/B4B,SACtD5B,EACAE,EACAvb,EAAM,IAGN,IACI8c,EADAnB,EAAWJ,EAEf,KAAOI,EAASU,UAAUz5B,OAAS,GAE/B,GADAod,EAAIrd,KAAKg5B,GAC0B,IAA9BA,EAASU,UAAUz5B,aAAmC0U,IAAjBwlB,EAA6B,CACnE,IAAIF,EAAWjB,EAASU,UAAU,GAClCS,EAAeF,EAASG,WAAWpB,GACnCA,EAAWiB,MACR,CACH,IAAIA,EACAI,EACJ,IAAK,IAAIj0B,EAAI,EAAGslB,EAAMsN,EAASU,UAAUz5B,OAAQmG,EAAIslB,IACjDuO,EAAWjB,EAASU,UAAUtzB,GAC9Bi0B,EAAeJ,EAASG,WAAWpB,GAC/BqB,IAAiBF,GAHiC/zB,KAO1D+zB,EAAeE,EACfrB,EAAWiB,EAInB,OAAO5c,EAAIwc,iBCrBFU,GAITl5B,YACIo1B,GAGAl1B,KAAKi3B,YAAc,IAAIhC,GAAYC,GAGvCp1B,YACI4D,GAOA,MAJsB,qBAClBA,EAAOsxB,GAAStxB,IAEpB1D,KAAK82B,SAAWpzB,EACT1D,KAGXF,UACIm5B,GAIA,OADAj5B,KAAKi3B,YAAYgC,OAASA,EACnBj5B,KAGXF,OACI22B,EACAC,EACAC,GAIA,OADAJ,GAAOv2B,KAAMy2B,EAAcC,EAAYC,GAChC32B,KAGXF,cAEI,OAAOE,KAAKi3B,YAAYiC,cAG5Bp5B,QAAQiG,GAEJ,OAAO/F,KAAKi3B,YAAYG,QAAQrxB,GAGpCjG,iBAEI,OAAOE,KAAKi3B,YAAYM,YAG5Bz3B,YACI22B,EACAC,GAGA,OL7DiB,SACrBF,EACAC,EACAC,GAGA,IAAIO,EAAcT,EAAMS,YACpBI,EAAUJ,EAAYG,QAAQV,GAC9ByC,EAAoB,GACxB,GAAgB,OAAZ9B,EACA,OAAO8B,EAGX,IAAIhC,EAAYF,EAAYG,QAAQX,GACpC,OAAO8B,GAAqB/B,EAAMM,UAAUK,EAAWE,EAAS8B,GK+CrDC,CAAYp5B,KAAMy2B,EAAcC,ICvExC,IAAI2C,GAAU,SAAU/N,GAE3B,IAAK,IAAIzmB,EAAIymB,EAAM5sB,OAAS,EAAGmG,EAAI,EAAGA,IAAK,CACvC,IAAIyvB,EAAIrlB,KAAK8b,MAAM9b,KAAKmc,UAAYvmB,EAAI,IACpC2K,EAAO8b,EAAMzmB,GACjBymB,EAAMzmB,GAAKymB,EAAMgJ,GACjBhJ,EAAMgJ,GAAK9kB,EAGf,OAAO8b,GCPAgO,GAAU,SAAUtzB,EAAWC,GACtC,MAAO,GAAGD,KAAKC,KAgBfszB,GAAmB,CAAEvzB,EAAG,EAAGC,EAAG,SCVrBuzB,iBCYT15B,cAEIE,KAAKm4B,UAAY,GAGrBr4B,WACIE,KAAK+F,SAAMqN,EACXpT,KAAKm4B,UAAUz5B,OAAS,EAG5BoB,UACIE,KAAKmkB,WAITrkB,MAAMiG,GACF/F,KAAK+F,IAAMA,EACX/F,KAAKs2B,EAAI,EACTt2B,KAAKwR,EAAI,EACTxR,KAAKwG,OAAI4M,EACTpT,KAAKw3B,aAAUpkB,EACfpT,KAAKk4B,SAAU,EACfl4B,KAAK03B,QAAS,EAGlB53B,UACIu3B,EACAL,EACAyC,GAGA,GAAkB,OAAdzC,EACA,OAAO,EAGX,IAAIxwB,EACAkzB,EAAO15B,KAAK25B,WAAWtC,GAAWr3B,KAAK8W,QAAQmiB,OAEnD,OAAQjC,GACJ,KAAKhC,GAASwB,MACVhwB,EAAIkzB,EACJ,MACJ,KAAK1E,GAAS,cACV,QAAiB5hB,IAAbqmB,EAAwB,CACxB,IAAInM,EAAa+J,EAAQmB,QAAQiB,GAAYz5B,KAAKw4B,QAAQiB,GAC1DjzB,EAAIkzB,EAAOzqB,KAAKsS,IAAI+L,QAEpB9mB,EAAIkzB,EAEZ,KAAK1E,GAAS,gBACVxuB,EAAIkzB,EAAOzqB,KAAKmc,SAChB,MACJ,QACI5kB,EAAIkzB,EAGZ,OAAOlzB,EAIX1G,eAEI,MAAO,GAIXA,QACI85B,GAGA,OX3Fe,KW+FnB95B,WACImT,GAGA,OAAO,EAIXnT,QACImT,GAGA,OAAO,EAIXnT,WACImT,GAGA,OAAO,EAGXnT,QACIiG,EACAuvB,GAAsB,GAGtB,OAAOt1B,KAAK8W,QAAQsgB,QAAQrxB,EAAKuvB,KDxGrCx1B,YAAY+5B,GAER5sB,QAVJjN,gBAAY,EAWRA,KAAK65B,WAAaA,EAGtB/5B,MACIiG,GAGAkH,MAAMlM,MAAMgF,GAEZ/F,KAAK+F,IAAMA,EDzBE,SAAUA,EAC3B+V,GAGA,IAAIge,EAAK/zB,EAAI2a,MAAM,UACPtN,IAAR0I,IACAA,EAAMyd,IAEVzd,EAAI9V,EAAI8lB,SAASgO,EAAG,IACpBhe,EAAI7V,EAAI6lB,SAASgO,EAAG,ICiBhBC,CAAQh0B,EAAK/F,MACbA,KAAKg6B,SAAM5mB,EACXpT,KAAKi6B,SAAM7mB,EACXpT,KAAKk6B,UAAO9mB,EAGhBtT,eAII,IAAIq6B,EAAkBn6B,KAAK4oB,MAAMwR,kBAAkBp6B,MAC/CA,KAAK65B,WAAWQ,kBAChBhB,GAAQc,GAGZ,IAAIG,EAAgB,GAKpB,OAJAH,EAAgBhrB,QAASujB,IACrB,IAAIzf,EAAOjT,KAAKo3B,QAAQkC,GAAQ5G,EAAO1sB,EAAG0sB,EAAOzsB,IAAI,GACrDq0B,EAAc77B,KAAKwU,KAEhBqnB,EAGXx6B,QACI85B,GAUA,OAPI55B,KAAK65B,WAAWU,eACEnnB,IAAdpT,KAAKk6B,OACLl6B,KAAKk6B,KAAOl6B,KAAK65B,WAAW9B,QAAQ/3B,KAAM45B,IAG9C55B,KAAKk6B,KAAOl6B,KAAK65B,WAAW9B,QAAQ/3B,KAAM45B,GAEvC55B,KAAKk6B,KAGhBp6B,WACImT,GAGA,OAAOjT,KAAK4oB,MAAM4R,YAAYx6B,KAAMiT,GAAM,GAG9CnT,QACImT,GAGA,OAAOwnB,GAAaz6B,KAAKsvB,OAAQtvB,KAAK06B,OAAQznB,EAAKqc,OAAQrc,EAAKqc,QAGpExvB,WACImT,GAGA,OAAOjT,KAAK4oB,MAAM+R,yBAAyB36B,KAAMiT,GAGrD2V,YAEI,OAAO5oB,KAAK65B,WAAWjR,MAG3B0G,aACI,QAAiBlc,IAAbpT,KAAKg6B,IAAmB,CACxB,IAAIY,EAAU56B,KAAK4oB,MAAMwB,gBAAgBpqB,KAAKgG,EAAGhG,KAAKiG,GAAG,GACzDjG,KAAKg6B,IAAMY,EAAQ50B,EACnBhG,KAAKi6B,IAAMW,EAAQ30B,EAEvB,OAAOjG,KAAKg6B,IAGhBU,aACI,QAAiBtnB,IAAbpT,KAAKi6B,IAAmB,CACxB,IAAIW,EAAU56B,KAAK4oB,MAAMwB,gBAAgBpqB,KAAKgG,EAAGhG,KAAKiG,GAAG,GACzDjG,KAAKg6B,IAAMY,EAAQ50B,EACnBhG,KAAKi6B,IAAMW,EAAQ30B,EAEvB,OAAOjG,KAAKi6B,KEzGb,ICGIY,GAAU,SACjBhB,EACAiB,EACAhf,EAAwB,IAGxB,IACIif,EADQlB,EAAWjR,MACOa,eAAeqR,GACzCE,EAAenB,EAAWmB,aAc9B,OAbgBnB,EAAWrD,MACtByE,YAAYpB,EAAW/C,UACvBoE,YACG5B,GAAQ0B,EAAah1B,EAAGg1B,EAAa/0B,GACrCqzB,GAAQyB,EAAU/0B,EAAG+0B,EAAU90B,IAE7BkJ,SAAQ,SAAU8D,GACxB6I,EAAIrd,KAAK,CACLuH,EAAGiN,EAAKjN,EACRC,EAAGgN,EAAKhN,EACRi0B,KAAMjnB,EAAKzB,OAGZsK,SCZEqf,GAiBTr7B,aAAY8oB,MACRA,EAAiBsR,KAEjBA,EAAO,EAACkB,aACRA,EAAwBC,kBACxBA,EAA6BC,aAE7BA,GAAe,EAAKC,YACpBA,GAAc,EAAKC,gBACnBA,GAAkB,EAAK1E,SAEvBA,EAAW9B,GAAgB,MAACuF,UAE5BA,GAAY,EAAItB,OAEhBA,EAAS,GAAEoB,iBAEXA,GAAmB,GACV,IFhDQ,IACrBR,EEiDI75B,KAAKy7B,SAAS7S,GAEVwS,EACAp7B,KAAK07B,gBAAgBN,EAAcC,IAEnCr7B,KAAK27B,aAAazB,GAClBl6B,KAAK07B,gBAAgB,OAGzB17B,KAAKi7B,YAAYnE,GACjB92B,KAAK47B,gBAAgBN,GACrBt7B,KAAK67B,eAAeN,GACpBv7B,KAAK87B,mBAAmBN,GAExBx7B,KAAK+7B,iBAAiBxB,GACtBv6B,KAAKg8B,UAAU/C,GACfj5B,KAAKi8B,wBAAwB5B,GAE7Br6B,KAAKw2B,OFnETqD,EEmE6B75B,KF7DtB,IAAIg5B,IAHc,WACrB,OAAO,IAAIQ,GAAUK,OEkEzB/5B,SACI8oB,GAIA,OADA5oB,KAAK4oB,MAAQA,EACN5oB,KAGXF,aACIo6B,GAIA,OADAl6B,KAAKk8B,UAAYhC,EACVl6B,KAGXF,gBACI8T,EACAuoB,GAKA,OAFAn8B,KAAKo7B,aAAexnB,EACpB5T,KAAKq7B,kBAAoBc,EAClBn8B,KAGXF,YACI4D,GAOA,MAJsB,qBAClBA,EAAOsxB,GAAStxB,IAEpB1D,KAAK82B,SAAWpzB,EACT1D,KAGXF,gBACI8R,GAAkB,GAIlB,OADA5R,KAAKs7B,aAAe1pB,EACb5R,KAGXF,eACI8R,GAAkB,GAIlB,OADA5R,KAAKu7B,YAAc3pB,EACZ5R,KAGXF,mBACI8R,GAAkB,GAIlB,OADA5R,KAAKw7B,gBAAkB5pB,EAChB5R,KAGXF,iBACI8R,GAAkB,GAIlB,OADA5R,KAAKu6B,UAAY3oB,EACV5R,KAGXF,UACI2T,GAIA,OADAzT,KAAKi5B,OAASxlB,EACPzT,KAGXF,wBACI8R,GAAkB,GAIlB,OADA5R,KAAKq6B,iBAAmBzoB,EACjB5R,KAGXF,QACI23B,EACAiB,GAGA,OCjKa,SACjBmB,EACApC,EACAiB,GAIA,GAAImB,EAAWyB,cACPzB,EAAWjR,MAAMwT,SAAS3E,EAASzxB,EAAGyxB,EAASxxB,EAAG4zB,EAAWmB,aAAavU,GAC1E,OfdW,KekBnB,GAAIoT,EAAW0B,aACP1B,EAAWjR,MAAMyT,WAAW5E,EAASzxB,EAAGyxB,EAASxxB,GACjD,OfpBW,KewBf4zB,EAAW2B,gBAIf,IAAI5nB,EAAWimB,EAAWuB,aAC1B,GAAIxnB,EAAU,CACV,IACIsmB,EADAiC,EAAQtC,EAAWwB,kBAUvB,OAPInB,EADAiC,EACOvoB,EAASoR,KAAKmX,EAAO1E,EAAUiB,EAAUmB,GAEzCjmB,EAAS6jB,EAAUiB,EAAUmB,QAE3BzmB,IAAT8mB,IACAA,EftCW,MewCRA,EAEP,OAAOL,EAAWqC,UD4HXI,CAAQt8B,KAAMy3B,EAAUiB,GAGnC54B,SACIy8B,EACA5F,EACA7a,EAAwB,IAGxB,OE1Kc,SAClB+d,EACA0C,EACA5F,EACA7a,EAAwB,IAGxB,IAAI8M,EAAQiR,EAAWjR,MAEvB,IAAKA,EAAM4T,SAASD,GAChB,OAAOzgB,EAGX,QAAsB1I,IAAjBujB,GAAgCA,GAAgB,EACjD,OAAO7a,EAGX,IAAI0a,EAAQqD,EAAWrD,MACnBwE,EAAepS,EAAMa,eAAe8S,GACpCE,EAAazB,EAAah1B,EAC1B02B,EAAa1B,EAAa/0B,EAC9B4zB,EAAWmB,aAAeA,EAC1B,IAAIvE,EAAe6C,GAAQmD,EAAYC,GACvClG,EAAMmG,OAAOlG,EAAc,KAAME,GAEjC,IAAIiG,EAAWpG,EAAM0C,cACjB2D,EAA0B,GAC9B,IAAK,MAAO92B,EAAKkN,KAAS2pB,EAEjB3pB,EAAKjN,IAAMy2B,GAAgBxpB,EAAKhN,IAAMy2B,GAItCzpB,EAAKykB,QAGVmF,EAAUp+B,KAAKwU,GAiBnB,OAdA4pB,EAAUC,MAAK,SAAUC,EAAOC,GAC5B,IAAIC,EAAMF,EAAM1H,GACZ6H,EAAMF,EAAM3H,GAChB,OAAQ4H,EAAMC,EAAO,EAChBD,EAAMC,GAAQ,EACX,KAEZL,EAAU1tB,SAAQ,SAAU8D,GACxB6I,EAAIrd,KAAK,CACLuH,EAAGiN,EAAKjN,EACRC,EAAGgN,EAAKhN,EACRi0B,KAAMjnB,EAAKzB,OAGZsK,EFqHIqhB,CAASn9B,KAAMu8B,EAAY5F,EAAc7a,GAGpDshB,cACI,OdnLe,KcsLnBt9B,SACIy8B,EACAzB,EACAnE,EACA0G,GAAqB,EACrBvhB,EAAwB,IAGxB,OGrLc,SAClB+d,EACA0C,EACAzB,EACAnE,EACA0G,GAAqB,EACrBvhB,EAAwB,IAGxB,IAAI8M,EAAQiR,EAAWjR,MAEvB,IAAKA,EAAM4T,SAASD,GAChB,OAAOzgB,EAGX,QAAsB1I,IAAjBujB,GAAgCA,GAAgB,EACjD,OAAO7a,EAGX,IAAI0a,EAAQqD,EAAWrD,MACnBwE,EAAepS,EAAMa,eAAe8S,GACpCxB,EAAYnS,EAAMa,eAAeqR,GACrCjB,EAAWmB,aAAeA,EAC1B,IAAIvE,EAAe6C,GAAQ0B,EAAah1B,EAAGg1B,EAAa/0B,GACpDywB,EAAa4C,GAAQyB,EAAU/0B,EAAG+0B,EAAU90B,GAEhDuwB,EACKyE,YAAYpB,EAAW/C,UACvBkF,UAAUnC,EAAWZ,QACrB0D,OAAOlG,EAAcC,EAAYC,GAEtC,IAAIU,EAAW,EAAcb,EAAM8G,iBAAmB9G,EAAMY,QAAQV,GACpE,OAAgB,OAAZW,EACOvb,EAGJ+e,GAAQhB,EAAaxC,EAAoBvb,GHiJrCyhB,CAASv9B,KAAMu8B,EAAYzB,EAAUnE,EAAc0G,EAAWvhB,GAGzEhc,QACIg7B,EACAhf,EAAwB,IAGxB,OAAO+e,GAAQ76B,KAAM86B,EAAUhf,GAGnChc,aACIkpB,EACAC,EACAuU,GAAoB,GAGpB,OI1MkB,SACtB3D,EACA7Q,EACAC,EACAuU,GAAoB,GAGpB,IAAIvqB,EAAO4mB,EAAWrD,MAAMY,QAAQkC,GAAQtQ,EAAOC,IACnD,OAAa,OAAThW,EACO,KAEJ,EAAaA,EAAKzB,EAAIyB,EAAKinB,KJ+LvBuD,CAAaz9B,KAAMgpB,EAAOC,EAAOuU,IKlMzC,ICXIE,GAAW,SAClB3sB,EACAd,EACAhP,GAGA,iBACI,IAAK,SAAU,MAAO,IAAI8P,EAAMC,SAAS,IACzC,IAAK,WAAY,OAAOD,EAAMd,EAAQhP,GACtC,QAAS,OAAO8P,ICGb4sB,GAAuB,SAC9B53B,GACA63B,OACIA,EAAMre,UACNA,EAAStH,YACTA,EAAW+H,UACXA,EAAY,EAACK,SACbA,EAAW,SACF,CAAEud,OAAQ,KAGvB,OFZ2B,SAC3B73B,EACA6N,EACAuoB,EACA1yB,EAAqB,GAGrB,IAAIjL,EACJ,GAAqB,mBAAU,CAC3B,IAAIq/B,EAAiBhmB,KAChBgmB,EAAe51B,IAAIlC,IACpB83B,EAAenxB,IAAI3G,EAAKoZ,MAE5B3gB,EAAUq/B,EAAe11B,IAAIpC,QAE7BvH,EAAUuH,EAGd,IAAIkK,EAASzR,EAAQqD,MACjBZ,EAAUgP,EAAOQ,WAAW,MAgBhC,OAdI0rB,EACAvoB,EAASoR,KAAKmX,EAAOlsB,EAAQhP,GAE7B2S,EAAS3D,EAAQhP,GAGrBzC,EAAQ8J,QACJ2H,EAAO5P,MAAQoJ,EACfwG,EAAO3P,OAASmJ,GAEhBjL,EAAQ2C,SACR3C,EAAQ2C,QAAQ8Q,SAGbzT,EEvBAs/B,CAAkB/3B,GAAK,SAAUkK,EAAQhP,GAC5C,GAAsB,IAAlB28B,EAAOl/B,OAGP,OAFAuR,EAAO5P,MAAQ,OACf4P,EAAO3P,OAAS,GAIf2X,IACD+H,EAAY,GAGhB,IAAI+d,EAAOC,GAAeJ,EAAQ,KAC9BK,EAAOD,GAAeJ,EAAQ,KAI9Bv9B,EAHO69B,GAAeN,EAAQ,KAGfG,EACfz9B,EAHO49B,GAAeN,EAAQ,KAGdK,EAEhBlL,EAAQ1yB,EAAQ,EAChB4yB,EAAQ3yB,EAAS,EACjB69B,EAASne,EAAY,EAEzB/P,EAAO5P,MAAQ4O,KAAKqS,KAAKjhB,GACzB4P,EAAO3P,OAAS2O,KAAKqS,KAAKhhB,GAE1BW,EAAQm9B,YACRn9B,EAAQof,SAAWA,EAEnB,IAAIge,EAAQT,EAAO,GAEnB38B,EAAQiX,OACJomB,GAAQD,EAAMr4B,EAAI+3B,EAAOhL,EAAOoL,GAChCG,GAAQD,EAAMp4B,EAAIg4B,EAAOhL,EAAOkL,IAGpC,IAAK,IAAIt5B,EAAI,EAAGslB,EAAMyT,EAAOl/B,OAAQmG,EAAIslB,EAAKtlB,IAC1Cw5B,EAAQT,EAAO/4B,GACf5D,EAAQkX,OACJmmB,GAAQD,EAAMr4B,EAAI+3B,EAAOhL,EAAOoL,GAChCG,GAAQD,EAAMp4B,EAAIg4B,EAAOhL,EAAOkL,IAIxCl9B,EAAQs9B,YAEJhf,IACAte,EAAQse,UAAYme,GAASne,EAAWtP,EAAQhP,GAChDA,EAAQkd,QAGRlG,IACAhX,EAAQgX,YAAcylB,GAASzlB,EAAahI,EAAQhP,GACpDA,EAAQ+e,UAAYA,EACpB/e,EAAQmX,cAMhB8lB,GAAiB,SACjB9Y,EACArf,GAGA,IAAIqhB,GAAUC,EAAAA,EACd,IAAK,IAAIxiB,EAAI,EAAGslB,EAAM/E,EAAM1mB,OAAQmG,EAAIslB,EAAKtlB,IACzCuiB,EAASnY,KAAKC,IAAIkY,EAAQhC,EAAMvgB,GAAGkB,IAEvC,OAAOqhB,GAGP4W,GAAiB,SACjB5Y,EACArf,GAGA,IAAIqhB,EAASC,EAAAA,EACb,IAAK,IAAIxiB,EAAI,EAAGslB,EAAM/E,EAAM1mB,OAAQmG,EAAIslB,EAAKtlB,IACzCuiB,EAASnY,KAAKsK,IAAI6N,EAAQhC,EAAMvgB,GAAGkB,IAEvC,OAAOqhB,GAGPkX,GAAS,SACT7qB,EACA+qB,EACA/f,GAGA,OAAIhL,EAAQ+qB,EACA/qB,EAAQgL,EACThL,EAAQ+qB,EACP/qB,EAAQgL,EAEThL,GCpHf,IAAYgrB,G9LHIznB,GHEA0nB,IiMChB,SAAYD,GACRA,qBACAA,mBACAA,mBACAA,eAJJ,CAAYA,KAAAA,QCOZ,MAAME,+BCgEF7+B,aAAYosB,KACRA,EAAgB0S,KAChBA,GAAO,EAAKC,UACZA,GAAY,EAAKx+B,MACjBA,EAAQ,EAACC,OACTA,EAAS,GACA,IAETN,KAAKinB,UAAY,IAAIO,GACrBxnB,KAAK8+B,UAAW,EAChB9+B,KAAK++B,QAAQ7S,GACblsB,KAAKg/B,YAAYJ,GACjB5+B,KAAKi/B,gBAAgBJ,GACrB7+B,KAAKk/B,aAAa7+B,EAAOC,GAG7BR,WAIAA,QAAQosB,GAGJ,OADAlsB,KAAKksB,KAAOA,EACLlsB,KAGXF,YAAY4D,GAAgB,GAGxB,OADA1D,KAAKm/B,SAAWz7B,EACT1D,KAGXF,gBAAgB4D,GAAgB,GAG5B,OADA1D,KAAK6oB,aAAenlB,EACb1D,KAGXF,aAAaO,EAAgB,EAAGC,EAAiB,GAI7C,OAFAqoB,GAAc3oB,KAAMK,GACpByoB,GAAe9oB,KAAMM,GACdN,KAGXF,SACI6lB,EACAqD,EACAC,EACAC,EACAkW,GAAiB,GAIjB,OCzHc,SAClBxW,EACAjD,EACAqD,EACAC,EACAC,EACAkW,GAAiB,GAGjB,IAAKxW,EAAMwT,SAASpT,EAAOC,GACvB,OAGJ,IAAIoW,EAAazW,EAAMa,eAAe9D,QACxBvS,IAAV8V,IAEIA,EADAmW,EACQA,EAAW5Y,EAEX,GAIZ4Y,GACCA,EAAWr5B,IAAMgjB,GAAWqW,EAAWp5B,IAAMgjB,GAAWoW,EAAW5Y,IAAMyC,IAK1DH,GAAeH,EAAOI,EAAOC,EAAOC,IAGpDN,EAAMW,YAAY,KAAMP,EAAOC,EAAOC,GAG1CN,EAAM3B,UAAUyC,SAAS/D,EAAOqD,EAAOC,EAAOC,GAE1CN,EAAMkW,UACNhV,GAAanE,GAAO8V,SAAS7S,GAG7BwW,GACApV,GAAUpB,EAAOjD,EAAOqD,EAAOC,ID+E/Bd,CAASnoB,KAAM2lB,EAAOqD,EAAOC,EAAOC,EAAOkW,GACpCp/B,KAGXF,aACI+sB,EACAC,GAGA,OEnIkB,SACtBlE,EACAiE,EACAC,GAGA,IAAIsF,EAAQxJ,EAAMa,eAAeoD,GAC7BwF,EAAQzJ,EAAMa,eAAeqD,GAC7BhR,EAAM8M,EAAMwB,gBAAgBgI,EAAMpsB,EAAGosB,EAAMnsB,GAAG,GAC9CuS,EAAKsD,EAAI9V,EACTyS,EAAKqD,EAAI7V,EACb6V,EAAM8M,EAAMwB,gBAAgBiI,EAAMrsB,EAAGqsB,EAAMpsB,GAAG,GAC9C,IAAIyS,EAAKoD,EAAI9V,EACT2S,EAAKmD,EAAI7V,EACb,OAAOq5B,GAAS9mB,EAAIC,EAAIC,EAAIC,GFqHjB8hB,CAAaz6B,KAAM6sB,EAAQC,GAGtChtB,qBACI4yB,EACArF,GAGA,OG1I0B,SAC9BzE,EACA8J,EACArF,GAGAA,EAAQ5C,GAAS4C,GACjB,IAAI1B,EAAa/C,EAAMsD,KAAKG,cACxBoM,EAAgBpR,EAAAA,EAChBsC,OAAYvW,EAChB,IAAK,IAAIvO,EAAI,EAAGslB,EAAMwB,EAAWjtB,OAAQmG,EAAIslB,EAAKtlB,IAAK,CACnD,IAAI06B,EAAgB9U,GAAS7B,EAAM4W,YAAY9M,EAAQ/G,EAAW9mB,KAC9DyoB,EAAare,KAAKsS,IAAIoJ,GAAgB0C,EAAOkS,IAC7CjS,EAAamL,IACbA,EAAgBnL,EAChB3D,EAAY9kB,GAIpB,OAAO8kB,EHuHI8V,CAAqBz/B,KAAM0yB,EAAQrF,GAG9CvtB,YACI4yB,EACA/I,GAGA,O3EpJiB,SACrBf,EACA8J,EACA/I,QAGevW,IAAXsf,IACAA,EAAS1H,IAGb,IAAI0U,EAAe9W,EAAMuW,SACrBQ,EAAmB/W,EAAMC,aAC7BD,EAAMuW,UAAW,EACjBvW,EAAMC,cAAe,EAGrB,IAAIuK,EAAiBxK,EAAMwR,kBAAkB1H,EAAQ/I,GAAW,GAKhE,OAFAf,EAAMuW,SAAWO,EACjB9W,EAAMC,aAAe8W,EACd/W,EAAMwE,aAAasF,EAAQU,G2E+HvBwM,CAAY5/B,KAAM0yB,EAAQ/I,GAGrC7pB,aACI+sB,EACAC,GAGA,OI5JkB,SACtBlE,EACAiE,EACAC,GAGA,OAA4D,OAApDlE,EAAMiX,0BAA0BhT,EAAQC,GJsJrCgT,CAAa9/B,KAAM6sB,EAAQC,GAGtChtB,eACI6lB,GAGA,OKlKoB,SACxBiD,EACAjD,GAGA,IAAIoa,EAA2BnX,EAAM3B,UAAU+Y,OAAOra,GACtD,OAAIoa,KCVyBE,EDYRta,KEdE,SAAUsa,GAKjC,GAAqB,oBAAYA,EAAI9gC,UAAY8gC,IAAQA,EAAIC,OACzD,OAAO,EAOX,IACI,GAAID,EAAIE,cAAgB,GAAKpb,eAAeC,KAAKib,EAAIE,YAAYrb,UAAW,iBACxE,OAAO,EAGf,MAAOsb,GACH,OAAO,EAKX,OAAO,EDrBKC,CAAcJ,IAAQA,EAAIK,YAC3BL,EAAIlb,eAAe,MAAQkb,EAAIlb,eAAe,KDW9CY,EAEA,MCfQ,IAAUsa,ENsKlBM,CAAevgC,KAAM2lB,GAGhC7lB,SACIkpB,EACAC,EACAC,GAIA,OQ7Kc,SAClBN,EACAI,EACAC,EACAC,GAGA,IAAI9B,EAUJ,OARIA,IADAwB,EAAMC,cAGIG,GAAS,GAAOA,EAAQJ,EAAMvoB,OACnC4oB,GAAS,GAAOA,EAAQL,EAAMtoB,OAEnC8mB,QAAqBhU,IAAV8V,IACX9B,EAASwB,EAAM3B,UAAUmV,SAASpT,EAAOC,EAAOC,IAE7C9B,ER4JI5T,CAASxT,KAAMgpB,EAAOC,EAAOC,GAGxCppB,iBACI+sB,EACAC,EACA8D,GAAiB,GAGjB,OStLsB,SAC1BhI,EACAiE,EACAC,EACA8D,GAAiB,GAGjB,IAAIwB,EAAQxJ,EAAMa,eAAeoD,GAC7BwF,EAAQzJ,EAAMa,eAAeqD,GACjC,OAAe,OAAVsF,GAA8B,OAAVC,EACd,KAGJzJ,EAAMsD,KAAKsU,iBAAiBpO,EAAOC,EAAOzB,GTyKtC0B,CAAiBtyB,KAAM6sB,EAAQC,EAAQ8D,GAGlD9wB,wBACIu0B,EACAjD,EACAqP,GAAqB,EACrB3kB,EAAgB,IAGhB,OUhM6B,SACjC8M,EACAyL,EACAjD,EACAqP,GAAqB,EACrB3kB,EAAgB,IAGhB,IAAK,IAAIjX,EAAI,EAAGA,GAAKusB,EAAQvsB,IAAK,CAC9B,IAAI67B,EAAQ,EAAc77B,EAAKusB,EAASvsB,EACxC+jB,EAAM+X,kBAAkBtM,EAAcqM,EAAO5kB,GAEjD,OAAOA,EVoLI8kB,CAAwB5gC,KAAMq0B,EAAcjD,EAAQqP,EAAW3kB,GAG1Ehc,IACI+gC,GAGA,OWtMS,SACbjY,EACAiY,GAIA,IAEInO,EAFAqL,EAAO1W,EAAAA,EACP4W,EAAO5W,EAAAA,EAEX,IAAK,IAAIxiB,EAAI,EAAGslB,EAAM0W,EAAYniC,OAAQmG,EAAIslB,EAAKtlB,IAC/C6tB,EAASmO,EAAYh8B,GACrBk5B,EAAO9uB,KAAKsK,IAAIwkB,EAAMrL,EAAO1sB,GAC7Bi4B,EAAOhvB,KAAKsK,IAAI0kB,EAAMvL,EAAOzsB,GAGjC,GAAc,IAAT83B,GAAyB,IAATE,EACjB,IAAK,IAAIp5B,EAAI,EAAGslB,EAAM0W,EAAYniC,OAAQmG,EAAIslB,EAAKtlB,IAC/C6tB,EAASmO,EAAYh8B,GACrB+jB,EAAMnK,OAAOiU,GAASqL,GAAOE,EAAMvL,GAK3C,IAAIoO,GAAQzZ,EAAAA,EACR0Z,GAAQ1Z,EAAAA,EACZ,IAAK,IAAIxiB,EAAI,EAAGslB,EAAM0W,EAAYniC,OAAQmG,EAAIslB,EAAKtlB,IAC/C6tB,EAASmO,EAAYh8B,GACrBi8B,EAAO7xB,KAAKC,IAAI4xB,EAAMpO,EAAO1sB,GAC7B+6B,EAAO9xB,KAAKC,IAAI6xB,EAAMrO,EAAOzsB,GAIjC,OADA2iB,EAAMsW,aAAa4B,EAAO,EAAGC,EAAO,GAC7BF,EXsKIG,CAAIhhC,KAAM6gC,GAGrB/gC,cACI8T,EACAuoB,EACA8E,EAAgB,GAIhB,OxEhNmB,SACvBrY,EACAhV,EACAuoB,EACA8E,EAA4B/V,GAAmB,UAG/C,IAAIwH,EAAiB,CAAE1sB,EAAG,EAAGC,EAAG,GAChC,OAAQg7B,GACJ,KAAK/V,GAAmB,SACpB,IAAK,IAAIjC,EAAQ,EAAGA,EAAQL,EAAMtoB,OAAQ2oB,IACtC,IAAK,IAAID,EAAQ,EAAGA,EAAQJ,EAAMvoB,MAAO2oB,IACrC0J,EAAO1sB,EAAIgjB,EACX0J,EAAOzsB,EAAIgjB,EACPkT,EACAvoB,EAASoR,KAAKmX,EAAOzJ,EAAQ9J,GAE7BhV,EAAS8e,EAAQ9J,GAI7B,MAEJ,KAAKsC,GAAmB,SACpB,IAAK,IAAIjC,EAAQ,EAAGA,EAAQL,EAAMtoB,OAAQ2oB,IACtC,IAAK,IAAID,EAAQJ,EAAMvoB,MAAQ,EAAG2oB,GAAS,EAAGA,IAC1C0J,EAAO1sB,EAAIgjB,EACX0J,EAAOzsB,EAAIgjB,EACPkT,EACAvoB,EAASoR,KAAKmX,EAAOzJ,EAAQ9J,GAE7BhV,EAAS8e,EAAQ9J,GAI7B,MAEJ,KAAKsC,GAAmB,SACpB,IAAK,IAAIlC,EAAQ,EAAGA,EAAQJ,EAAMvoB,MAAO2oB,IACrC,IAAK,IAAIC,EAAQ,EAAGA,EAAQL,EAAMtoB,OAAQ2oB,IACtCyJ,EAAO1sB,EAAIgjB,EACX0J,EAAOzsB,EAAIgjB,EACPkT,EACAvoB,EAASoR,KAAKmX,EAAOzJ,EAAQ9J,GAE7BhV,EAAS8e,EAAQ9J,GAI7B,MAEJ,KAAKsC,GAAmB,SACpB,IAAK,IAAIlC,EAAQ,EAAGA,EAAQJ,EAAMvoB,MAAO2oB,IACrC,IAAK,IAAIC,EAAQL,EAAMtoB,OAAS,EAAG2oB,GAAS,EAAGA,IAC3CyJ,EAAO1sB,EAAIgjB,EACX0J,EAAOzsB,EAAIgjB,EACPkT,EACAvoB,EAASoR,KAAKmX,EAAOzJ,EAAQ9J,GAE7BhV,EAAS8e,EAAQ9J,IwEoJjCsY,CAAclhC,KAAM4T,EAAUuoB,EAAO8E,GAC9BjhC,KAGXF,YACIgc,EAAgB,IAGhB,OYxNiB,SACrB8M,EACA9M,EAAgB,IAGhB,IAAI2L,EAAamB,EAAM3B,UAAUQ,WACjC,IAAK,MAAO9B,EAAOoa,KAAQtY,EACvB3L,EAAIrd,KAAKknB,GAEb,OAAO7J,EZ+MIqlB,CAAYnhC,KAAM8b,GAG7Bhc,aACI6lB,GAGA,OAAOmE,GAAanE,GAGxB7lB,YACIsyB,EACAC,EACAG,GAAqB,GAGrB,OaxOiB,SACrB5J,EACAwJ,EACAC,EACAG,GAGA,OAAO5J,EAAMsD,KAAKsO,YAAYpI,EAAOC,EAAOG,GbiOjCC,CAAYzyB,KAAMoyB,EAAOC,EAAOG,GAG3C1yB,oBACIopB,EAAyB,EACzBpN,EAAgB,IAGhB,OchPyB,SAC7B8M,EACAM,EAAyB,EACzBpN,EAAgB,IAGhB,GAAK+G,MAAMC,QAAQoG,GAWZ,CACH,IAAIkY,EAAalY,EACjB,IAAK,IAAID,EAAQ,EAAGA,EAAQL,EAAMtoB,OAAQ2oB,IACtC,IAAK,IAAID,EAAQ,EAAGA,EAAQJ,EAAMvoB,MAAO2oB,IAAS,CAC9C,IAAIqY,GAAU,EACd,IAAK,IAAI9M,EAAI,EAAG+M,EAAOF,EAAW1iC,OAAQ61B,EAAI+M,EAAM/M,IAChD,GAA0D,OAAtD3L,EAAM2Y,eAAevY,EAAOC,EAAOmY,EAAW7M,IAAc,CAC5D8M,GAAU,EACV,MAGJA,GACAvlB,EAAIrd,KAAK,CACLuH,EAAGgjB,EACH/iB,EAAGgjB,UAxBnB,IAAK,IAAIA,EAAQ,EAAGA,EAAQL,EAAMtoB,OAAQ2oB,IACtC,IAAK,IAAID,EAAQ,EAAGA,EAAQJ,EAAMvoB,MAAO2oB,IACa,OAA9CJ,EAAM2Y,eAAevY,EAAOC,EAAOC,IACnCpN,EAAIrd,KAAK,CACLuH,EAAGgjB,EACH/iB,EAAGgjB,IAyBvB,OAAOnN,Ed2MI0lB,CAAoBxhC,KAAMkpB,EAAOpN,GAG5Chc,cACIkpB,EACAC,EACAnN,GAGA,OezPmB,SACvB8M,EACAI,EACAC,EACAnN,GAGA,OAAO8M,EAAMsD,KAAKuV,cAAczY,EAAOC,EAAOnN,GfkPnCqX,CAAcnzB,KAAMgpB,EAAOC,EAAOnN,GAG7Chc,iBACI6lB,EACAgG,EACA+V,EACA5lB,GAGA,OgBnQsB,SAC1B8M,EACAjD,EACAgG,EACA+V,EACA5lB,GAGA,IAAI0N,EAAUZ,EAAMa,eAAe9D,GACnC,GAAgB,OAAZ6D,EACA,OAAO,KAGU,MAAjBkY,IACAA,EAAiBlY,EAAQzE,eAAe,KAASyE,EAAoB/C,EAAI,MAG7E,IAAI2M,EAAiBxK,EAAMwR,kBAAkB5Q,EAASmC,GAAY,GAClE,OAAuB,OAAnByH,EACO,KACAvQ,MAAMC,QAAQsQ,SACThgB,IAAR0I,IACAA,EAAM,IAEH8M,EAAM+Y,wBAAwBvO,EAAgBsO,EAAe5lB,IAE/C,MAAjB4lB,QACYtuB,IAAR0I,IACAA,EAAM,IAEH8M,EAAMgZ,mBAAmBxO,EAAeptB,EAAGotB,EAAentB,EAAG6V,IAE7D8M,EAAM2Y,eAAenO,EAAeptB,EAAGotB,EAAentB,EAAGy7B,GhBmO7DG,CAAiB7hC,KAAM2lB,EAAOgG,EAAY+V,EAAe5lB,GAGpEhc,0BACI6lB,EACAmc,GAGA,OiB3Q+B,SACnClZ,EACAjD,EACAmc,GAGA,IAAIC,EAAanZ,EAAMa,eAAe9D,GAClCqc,EAAkBpZ,EAAMa,eAAeqY,GAC3C,OAAOlZ,EAAM+R,yBAAyBoH,EAAYC,GjBmQvCC,CAA0BjiC,KAAM2lB,EAAOmc,GAGlDhiC,yBACI+rB,EACAuH,GAGA,OkBnR8B,SAClCxK,EACAiD,EACAuH,GAGA,GAAmB,OAAdvH,GAA2C,OAAnBuH,EACzB,OAAO,KAEX,GAAKvH,EAAU7lB,IAAMotB,EAAeptB,GAAO6lB,EAAU5lB,IAAMmtB,EAAentB,EACtE,OAAO,KAGX,IAAI0jB,EAAYf,EAAMsD,KAAKyO,yBAAyB9O,EAAWuH,GAC/D,GAAIxK,EAAMuW,UAA2B,OAAdxV,EAAqB,CACxC,IAAIkX,EAAcjY,EAAMwR,kBAAkBvO,EAAW,MACrD,IAAK,IAAIhnB,EAAI,EAAGslB,EAAM0W,EAAYniC,OAAQmG,EAAIslB,EAAKtlB,IAAK,CACpD,IAAI6tB,EAASmO,EAAYh8B,GACzB,GAAKuuB,EAAeptB,IAAM0sB,EAAO1sB,GAAOotB,EAAentB,IAAMysB,EAAOzsB,EAAI,CACpE0jB,EAAY9kB,EACZ,QAIZ,OAAO8kB,ElB2PI8J,CAAyBzzB,KAAM6rB,EAAWuH,GAGrDtzB,kBACI+rB,EACAF,EAAgD,KAChD7P,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,OmB5RuB,SAC3B2iB,EACAiD,EACAF,EAAgD,KAChD7P,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,OAAO2iB,EAAMuD,qBAAqBN,EAAWF,EAAY,EAAG7P,GnBqRjD4X,CAAkB1zB,KAAM6rB,EAAWF,EAAY7P,GAG1Dhc,yBACI+rB,EACAwB,EACAvR,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,OoBrS8B,SAClCi8B,EACArW,EACAwB,EACAvR,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,IAAI0jB,EAAYuY,EAAMC,qBAAqBtW,EAAWwB,GACtD,OAAO6U,EAAM/V,qBAAqBN,EAAWlC,EAAW,EAAG7N,GpB6RhDsmB,CAAyBpiC,KAAM6rB,EAAWwB,EAAOvR,GAG5Dhc,qBACIkpB,EACAC,EACAU,GAGA,OqB9S0B,SAC9B0Y,EACArZ,EACAC,EACAU,GAGA,OAAO0Y,EAAMnW,KAAKoW,qBAAqBtZ,EAAOC,EAAOU,GrBuS1CgK,CAAqB3zB,KAAMgpB,EAAOC,EAAOU,GAGpD7pB,qBACIopB,EAAe,EACfpN,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,OrEpT0B,SAC9B2iB,EACAM,EAAe,EACfpN,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,KAGpB,IAAR6V,IACAA,EAAM2P,IAIV,IAAI8W,EAAatzB,KAAK8b,MAAMnC,EAAMvoB,MAAQuoB,EAAMtoB,OAAS,IACzD,IAAI,IAAIuE,EAAG,EAAGA,EAAG09B,EAAY19B,IAAK,CAC9B,IAAImkB,EAAQmC,GAAU,EAAGvC,EAAMvoB,MAAQ,GACnC4oB,EAAQkC,GAAU,EAAGvC,EAAMtoB,OAAS,GACxC,GAAkD,OAA9CsoB,EAAM2Y,eAAevY,EAAOC,EAAOC,GAGnC,OAFApN,EAAI9V,EAAIgjB,EACRlN,EAAI7V,EAAIgjB,EACDnN,EAMf,IAAI+kB,EAAcjY,EAAM4Z,oBAAoBtZ,GAC5C,GAA2B,IAAvB2X,EAAYniC,OACZ,OAAO,KACJ,CACH,IAAIg0B,EAAiBrH,GAAcwV,GAGnC,OAFA/kB,EAAI9V,EAAI0sB,EAAO1sB,EACf8V,EAAI7V,EAAIysB,EAAOzsB,EACR6V,GqEqRA2mB,CAAqBziC,KAAMkpB,EAAOpN,GAG7Chc,qBACI6lB,EACAgG,EACAC,EACA9P,GAGA,OAAO4P,GAAqB1rB,KAAM2lB,EAAOgG,EAAYC,EAAU9P,GAGnEhc,cACIkpB,EACAC,EACAnN,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,OlExUmB,SACvB2iB,EACAI,EACAC,EACAnN,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAqBhC,OAlBY,IAAR6V,IACAA,EAAM2P,IAGN7C,EAAMuW,SACNnW,EAAQyD,GAAKzD,EAAO,EAAGJ,EAAMvoB,QACpBuoB,EAAMC,eACbG,EAAQ,GAAOA,GAASJ,EAAMvoB,SAChC2oB,EAAQ,MAERJ,EAAMuW,SACNlW,EAAQwD,GAAKxD,EAAO,EAAGL,EAAMtoB,SACpBsoB,EAAMC,eACbI,EAAQ,GAAOA,GAASL,EAAMtoB,UAChC2oB,EAAQ,MAEZnN,EAAI9V,EAAIgjB,EACRlN,EAAI7V,EAAIgjB,EACDnN,EkE+SI4mB,CAAc1iC,KAAMgpB,EAAOC,EAAOnN,GAG7Chc,UACI6lB,EACAqD,EACAC,GAIA,OADAe,GAAUhqB,KAAM2lB,EAAOqD,EAAOC,GACvBjpB,KAGXF,WACIkpB,EACAC,EACAC,GAGA,OsB5VgB,SACpBN,EACAI,EACAC,EACAC,GAGA,QAAc9V,IAAV8V,EAAqB,CAErB,IAAIe,EAAarB,EAAMgZ,mBAAmB5Y,EAAOC,GACjD,IAAK,IAAIpkB,EAAI,EAAGslB,EAAMF,EAAWvrB,OAAQmG,EAAIslB,EAAKtlB,IAAK,CAEnD,IAAgB,IADF+jB,EAAM+Z,aAAa1Y,EAAWplB,IAAIwkB,QAE5C,OAAO,EAGf,OAAO,EAEJ,CAEH,IAAI1D,EAAQiD,EAAM2Y,eAAevY,EAAOC,EAAOC,GAC/C,OAAc,OAAVvD,IAIgB,IADNiD,EAAM+Z,aAAahd,GAAO0D,StBoUjCuZ,CAAW5iC,KAAMgpB,EAAOC,EAAOC,GAG1CppB,SACI6lB,GAGA,OuBnWc,SAClBiD,EACAjD,GAGA,OAAOiD,EAAM3B,UAAUQ,WAAWxf,IAAI0d,GvB8V3B0C,CAASroB,KAAM2lB,GAG1B7lB,eACIkpB,EACAC,EACAC,EACAS,GAGA,OjE5WoB,SACxBf,EACAI,EACAC,EACAC,EACAS,GAGA,QAAcvW,IAAV8V,EAAqB,CAErB,IAAIe,EAAarB,EAAMgZ,mBAAmB5Y,EAAOC,GACjD,IAAK,IAAIpkB,EAAI,EAAGslB,EAAMF,EAAWvrB,OAAQmG,EAAIslB,EAAKtlB,IAC9C,GAAI6nB,GAAc9D,EAAM+Z,aAAa1Y,EAAWplB,IAAIwkB,QAASM,GACzD,OAAO,EAGf,OAAO,EAEJ,CAEH,IAAIhE,EAAQiD,EAAM2Y,eAAevY,EAAOC,EAAOC,GAC/C,OAAc,OAAVvD,GAGG+G,GAAc9D,EAAM+Z,aAAahd,GAAO0D,QAASM,IiEoVjDkZ,CAAe7iC,KAAMgpB,EAAOC,EAAOC,EAAOS,GAGrD7pB,cACI+sB,EACAC,EACAC,EACAC,GAGA,OAAOJ,GAAc5sB,KAAM6sB,EAAQC,EAAQC,EAAMC,GAGrDltB,kBACI+sB,EACAC,EACAC,EACAC,GAGA,O7DjYuB,SAC3BpE,EACAiE,EACAC,EACAC,EACAC,GAGA,IAAIC,EAAUrE,EAAMa,eAAeoD,GAC/BK,EAAUtE,EAAMa,eAAeqD,GAE/BgW,EAAkBla,EAAMsD,KAAKP,WACjC/C,EAAMsD,KAAKP,WAAa/C,EAAMsD,KAAK8F,MACnC,IAAIrI,EAAYf,EAAMsD,KAAKsU,iBAAiBvT,EAASC,GAAS,GAC9DtE,EAAMsD,KAAKP,WAAamX,EAExB,IAAIC,EAAiB9zB,KAAKsS,IAAIoI,EAAYoD,GAE1C,OADAgW,EAAiB9zB,KAAKsK,IAAIwpB,EAAgBna,EAAMsD,KAAKP,WAAaoX,GAC1DA,GAAmB/V,EAAO,E6D+WvBgW,CAAkBhjC,KAAM6sB,EAAQC,EAAQC,EAAMC,GAGzDltB,mBACIwvB,EACAC,EACArG,GAGA,OwB1YwB,SAC5BN,EACA0G,EACAC,EACArG,GAGA,GAAIN,EAAMC,mBAA2BzV,IAAV8V,EACvB,OAAO,EAGX,IAAIpN,EAAM8M,EAAMqa,gBAAgB3T,EAAQC,GAAQ,GAChD,OAAO3G,EAAMwT,SAAStgB,EAAI9V,EAAG8V,EAAI7V,EAAGijB,GxB8XzBga,CAAmBljC,KAAMsvB,EAAQC,EAAQrG,GAGpDppB,OACI4yB,EACAhvB,EACAy/B,EAA8B,KAC9BrnB,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,O5DnZY,SAChB2iB,EACA8J,EACAhvB,EACAy/B,EAA8B,KAC9BrnB,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAiBhC,OAdY,IAAR6V,IACAA,EAAM2P,IAGW,OAAjB0X,EACAva,EAAMnK,OAAOiU,GAASyQ,EAAan9B,GAAIm9B,EAAal9B,EAAG6V,IAEvDA,EAAI9V,EAAI0sB,EAAO1sB,EACf8V,EAAI7V,EAAIysB,EAAOzsB,GAEnB2iB,EAAMsD,KAAKkX,OAAOtnB,EAAKpY,EAAMoY,GACR,OAAjBqnB,GACAva,EAAMnK,OAAO3C,EAAKqnB,EAAan9B,EAAGm9B,EAAal9B,EAAG6V,GAE/CA,E4D6XI+X,CAAO7zB,KAAM0yB,EAAQhvB,EAAMy/B,EAAcrnB,GAGpDhc,OACI4yB,EACAoB,EACAC,EACAjY,GAGA,O3D9ZY,SAChB8M,EACA8J,EACAoB,EACAC,EACAjY,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAahC,OAVY,IAAR6V,IACAA,EAAM2P,IAGW,IAAhBqI,GAAuC,IAAhBC,GACxBjY,EAAI9V,EAAI0sB,EAAO1sB,EACf8V,EAAI7V,EAAIysB,EAAOzsB,GAEf2iB,EAAMsD,KAAKzN,OAAOiU,EAAQoB,EAAaC,EAAajY,GAEjDA,E2D4YIsY,CAAOp0B,KAAM0yB,EAAQoB,EAAaC,EAAajY,GAG1Dhc,eACIyI,GAAmB,EACnB86B,GAA2B,GAI3B,OyB1aoB,SACxBza,EACArgB,GAAmB,EACnB86B,GAA2B,GAG3B,IAAIpZ,EAAarB,EAAMsB,cACvB,IAAK,IAAIrlB,EAAI,EAAGslB,EAAMF,EAAWvrB,OAAQmG,EAAIslB,EAAKtlB,IAC9C+jB,EAAMW,YAAYU,EAAWplB,QAAIuO,OAAWA,OAAWA,EAAW7K,EAAS86B,GzBia3EC,CAAetjC,KAAMuI,EAAS86B,GACvBrjC,KAGXF,YACI6lB,EACAqD,EACAC,EACAC,EACA3gB,GAAmB,EACnB86B,GAA2B,GAI3B,O0BjbiB,SACrBza,EACAjD,EACAqD,EACAC,EACAC,EACA3gB,GAAmB,EACnB86B,GAA2B,GAG3B,GAAI1d,EAAO,CACP,IAAI6D,EAAUZ,EAAMa,eAAe9D,GACnC,IAAI6D,EAMA,OALAR,EAAQQ,EAAQxjB,EAChBijB,EAAQO,EAAQvjB,EAChBijB,EAAQM,EAAQ/C,OAOpB,KADAd,EAAQoD,GAAeH,EAAOI,EAAOC,EAAOC,IAGxC,OAIHma,GACDza,EAAM3B,UAAUsC,YAAYP,EAAOC,EAAOC,GAE1CN,EAAMkW,UACNhV,GAAanE,GAAO8V,SAAS,MAG7BlzB,GAAWod,EAAMpd,SACjBod,EAAMpd,U1B4YN6f,CAAYpoB,KAAM2lB,EAAOqD,EAAOC,EAAOC,EAAO3gB,EAAS86B,GAChDrjC,KAGXF,kBACIu0B,EACAjD,EAAiB,EACjBtV,EAAgB,IAGhB,O2B7buB,SAC3B8M,EACAyL,EACAjD,EAAiB,EACjBtV,EAAgB,IAGhB,IAAIynB,EAAY3a,EAAMsD,KAAKyU,kBAAkBtM,EAAcjD,GAC3D,IAAK,IAAIvsB,EAAI,EAAGslB,EAAMoZ,EAAU7kC,OAAQmG,EAAIslB,EAAKtlB,IAAK,CAClD,IAAI6tB,EAAS6Q,EAAU1+B,GACnB+jB,EAAMwT,SAAS1J,EAAO1sB,EAAG0sB,EAAOzsB,IAChC6V,EAAIrd,KAAKi0B,GAGjB,OAAO5W,E3B+aI8Y,CAAkB50B,KAAMq0B,EAAcjD,EAAQtV,GAGzDhc,OACI4yB,EACA/I,EACAwZ,EAA8B,KAC9BrnB,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,O1DvcY,SAChB2iB,EACA8J,EACA/I,EACAwZ,EAA8B,KAC9BrnB,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAiBhC,OAdY,IAAR6V,IACAA,EAAM2P,IAGW,OAAjB0X,EACAva,EAAMnK,OAAOiU,GAASyQ,EAAan9B,GAAIm9B,EAAal9B,EAAG6V,IAEvDA,EAAI9V,EAAI0sB,EAAO1sB,EACf8V,EAAI7V,EAAIysB,EAAOzsB,GAEnB2iB,EAAMsD,KAAKsX,OAAO1nB,EAAK6N,EAAW7N,GACb,OAAjBqnB,GACAva,EAAMnK,OAAO3C,EAAKqnB,EAAan9B,EAAGm9B,EAAal9B,EAAG6V,GAE/CA,E0DibI+Y,CAAO70B,KAAM0yB,EAAQ/I,EAAWwZ,EAAcrnB,GAGzDhc,cAAcO,EAAgB,GAG1B,OADAsoB,GAAc3oB,KAAMK,GACbL,KAGXF,eAAeQ,EAAiB,GAG5B,OADAwoB,GAAe9oB,KAAMM,GACdN,KAGXF,UACI+sB,EACAC,EACAsS,GAAiB,GAIjB,O4B7de,SACnBxW,EACAiE,EACAC,EACAsS,GAAiB,GAGjB,IAAIqE,EAAW7a,EAAMa,eAAeoD,GAChC6W,EAAW9a,EAAMa,eAAeqD,GACnB,MAAZ2W,GAAkC,MAAZC,IAG3B9a,EAAMW,YAAYsD,GAClBjE,EAAMW,YAAYuD,GAClBlE,EAAMc,SAASmD,EAAQ6W,EAAS19B,EAAG09B,EAASz9B,EAAGy9B,EAASjd,EAAG2Y,GAC3DxW,EAAMc,SAASoD,EAAQ2W,EAASz9B,EAAGy9B,EAASx9B,EAAGw9B,EAAShd,EAAG2Y,I5B6cvDuE,CAAU3jC,KAAM6sB,EAAQC,EAAQsS,GACzBp/B,KAGXF,wBACI+gC,EACA3X,EACApN,EAAgB,IAGhB,O6Bne6B,SACjC8M,EACAiY,EACA3X,EACApN,EAAgB,IAGhB,IACI4W,EACA/M,EAFAie,EAAsB,MAAT1a,EAGjB,IAAK,IAAIrkB,EAAI,EAAGslB,EAAM0W,EAAYniC,OAAQmG,EAAIslB,EAAKtlB,IAC/C6tB,EAASmO,EAAYh8B,GACjB++B,GACAje,EAAQoD,GAAeH,EAAO8J,EAAO1sB,EAAG0sB,EAAOzsB,EAAGijB,GACpC,OAAVvD,GACA7J,EAAIrd,KAAKknB,IAGb+H,GAAmB9E,EAAO8J,EAAO1sB,EAAG0sB,EAAOzsB,EAAG6V,GAGtD,OAAOA,E7B8cI+nB,CAAwB7jC,KAAM6gC,EAAa3X,EAAOpN,GAG7Dhc,mBACIkpB,EACAC,EACAnN,EAAgB,IAGhB,OAAO4R,GAAmB1tB,KAAMgpB,EAAOC,EAAOnN,GAGlDhc,eACIkpB,EACAC,EACAC,GAGA,OAAOH,GAAe/oB,KAAMgpB,EAAOC,EAAOC,GAG9CppB,kBACIopB,EACApN,EAAgB,IAGhB,O8B/fuB,SAC3B8M,EACAM,EACApN,EAAgB,IAGhB,IAAI+K,EAAW+B,EAAM3B,UAAUW,YAAYzf,IAAI+gB,GAC/C,GAAIrC,EACA,IAAK,MAAMlB,KAASkB,EAChB/K,EAAIrd,KAAKknB,GAGjB,OAAO7J,E9BmfIgoB,CAAkB9jC,KAAMkpB,EAAOpN,GAG1Chc,0BACI+gC,EACA/kB,EAAkB,IAGlB,O+BxgB+B,SACnC8M,EACAiY,EACA/kB,EAAkB,IAGlB,IAAK,IAAIjX,EAAI,EAAGslB,EAAM0W,EAAYniC,OAAQmG,EAAIslB,EAAKtlB,IAAK,CACpD,IAAI6tB,EAASmO,EAAYh8B,GACzBiX,EAAIrd,KAAKmqB,EAAMwB,gBAAgBsI,EAAO1sB,EAAG0sB,EAAOzsB,IAEpD,OAAO6V,E/B8fIioB,CAA0B/jC,KAAM6gC,EAAa/kB,GAGxDhc,gBACIkpB,EACAC,EACAnN,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OgCjhBqB,SACzB2iB,EACAI,EACAC,EACAnN,GAGA,OAAO8M,EAAMsD,KAAK8X,WAAWhb,EAAOC,EAAOnN,GhC0gBhCmoB,CAAgBjkC,KAAMgpB,EAAOC,EAAOnN,GAG/Chc,kBACIwvB,EACAC,EACAzT,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IAGlC,OxD7hBuB,SAC3B2iB,EACA0G,EACAC,EACAzT,EAAuB,CAAE9V,EAAG,EAAGC,EAAG,IASlC,OANY,IAAR6V,IACAA,EAAM6R,IAGV/E,EAAMqa,gBAAgB3T,EAAQC,EAAQzT,GACtC8M,EAAMwB,gBAAgBtO,EAAI9V,EAAG8V,EAAI7V,EAAG6V,GAC7BA,EwDghBIooB,CAAkBlkC,KAAMsvB,EAAQC,EAAQzT,GAGnDhc,eACIwvB,EACAC,EACArG,EACApN,GAGA,OiCpiBoB,SACxB8M,EACA0G,EACAC,EACArG,EACApN,GAGA,IAAI4W,EAAS9J,EAAMqa,gBAAgB3T,EAAQC,GAAQ,GACnD,YAAcnc,IAAV8V,EACON,EAAM2Y,eAAe7O,EAAO1sB,EAAG0sB,EAAOzsB,EAAGijB,GAEzCN,EAAMgZ,mBAAmBlP,EAAO1sB,EAAG0sB,EAAOzsB,EAAG6V,GjCwhB7CqoB,CAAenkC,KAAMsvB,EAAQC,EAAQrG,EAAOpN,GAGvDhc,gBACIwvB,EACAC,EACAzT,GAGA,OkC7iBqB,SACzB8M,EACA0G,EACAC,EACAzT,EAAqB,CAAE9V,EAAG,EAAGC,EAAG,IAGhC,OAAO2iB,EAAMsD,KAAKkY,UAAU9U,EAAQC,EAAQzT,GlCsiBjCuoB,CAAgBrkC,KAAMsvB,EAAQC,EAAQzT,ODpiBjDhc,YAAYqD,GACR8J,MAAM9J,GAENnD,KAAK65B,WAAa,IAAIsB,GAAW,CAC7BvS,MAAO5oB,KACP82B,SAAU,QACVwE,cAAc,IAGlBqC,GAAqB,OAAQ,CACzBC,OAAQ59B,KAAKyhC,gBACbxpB,YAAa,QACb+H,UAAW,EACXK,SAAU,UAGdsd,GAAqB,QAAS,CAC1BC,OAAQ59B,KAAKyhC,gBACbliB,UAAW,UAInBzf,WACIsU,GAQA,OALApU,KAAKskC,cAAc,CAAC5R,EAAQ9J,KACxB,IAAIgS,EAAUhS,EAAMwB,gBAAgBsI,EAAO1sB,EAAG0sB,EAAOzsB,GAAG,GACpDs+B,EAAO,IAAItmB,GAAO2c,EAAQ50B,EAAG40B,EAAQ30B,EAAG,QAC5C4P,GAASzB,EAAOmwB,KAEbvkC,KAGXF,YACIsU,EACApO,EACAC,EACAwgB,EACApV,GAGA,IAAIsU,EAAQ,IAAI1H,GAAO,EAAG,EAAG,SAM7B,OALApI,GAASzB,EAAOuR,QACFvS,IAAV/B,GoCvDZ,SAAiBoM,KAAS1K,GACtBA,EAAS5D,QAAQhI,IACb,MAAMuW,EAAavW,EAAMuW,WACzBA,EAAW,GAAKD,EAChBC,EAAW,GAAKD,EAChBC,EAAW,GAAKD,EAChBC,EAAW,GAAKD,EAChBH,GAAWnW,KpCiDPq9B,CAAQnzB,EAAOsU,GAEnB3lB,KAAK0pB,SAAS/D,EAAO3f,EAAGC,EAAGwgB,GACpBd,EAGX7lB,SACIy8B,EACAzB,EACAuC,GAAY,GAEZ,OAAOr9B,KAAK65B,WAAW4K,SAASlI,EAAYzB,OAAU1nB,EAAWiqB,IA4CzE,IqC1FA,cCxBA,MACIv9B,cACIE,KAAK+U,OAAS,IAAIhN,MDuBtBjI,eAAe4kC,GACXz3B,QACAjN,KAAK2kC,QAAU,cACf3kC,KAAK4kC,UAAW,EAChB5kC,KAAK6kC,UAAW,EAChB7kC,KAAKkc,YAAa,EAClBlc,KAAKoc,YAAa,EAClBpc,KAAK8kC,SAAW,EAChB9kC,KAAKrC,QAAU,EACfqC,KAAKtC,MAAQ,EACbE,EAAiBoC,MEnCzB,SAA0B4T,GACtB,MAAMmxB,EAAa9lC,SAAS8lC,WAC5B,GAAmB,aAAfA,GAA4C,gBAAfA,EAE7B,YADAnxB,IAGJ,MAAMoxB,EAAQ,KACV/lC,SAASgmC,oBAAoB,cAAeD,GAAO,GACnD/lC,SAASgmC,oBAAoB,mBAAoBD,GAAO,GACxD9E,OAAO+E,oBAAoB,OAAQD,GAAO,GAC1CpxB,KAEC3U,SAASG,KAGL8gC,OAAOnb,eAAe,WAC3B9lB,SAASkR,iBAAiB,cAAe60B,GAAO,IAGhD/lC,SAASkR,iBAAiB,mBAAoB60B,GAAO,GACrD9E,OAAO/vB,iBAAiB,OAAQ60B,GAAO,IAPvC9E,OAAOgF,WAAWF,EAAO,IFuBzBG,CAAiB,IAAMnlC,KAAKqX,KAAKqtB,IAErC5kC,KAAK4kC,GACDA,EAASv1B,QAAQi2B,GAAWA,KAC5B,MAAMrlC,EzOnCHtC,EyOoCHuC,KAAKD,SAAW,IAAIA,EACpBC,KAAK69B,eAAiB,IAAI/lB,GAC1B9X,KAAK0kB,aAAe,IAAI3N,GACxB,MAAMpY,EAASU,IACXV,GG3CZ,SAAkBK,EAASL,GACRG,EAAWH,GACnB0mC,YAAYrmC,GH0CXsmC,CAAStlC,KAAKD,SAASkQ,OAAQtR,GAEnCqB,KAAK4kC,UAAW,EI9BxB,WACsB,CACd,MACMW,EAAiC,KAD1B3nC,IACsC+mC,QACnDv8B,QAAQo9B,IAAI,WAAaD,yBAAoB,oFAAiE,KJ2B9GE,GACA7wB,GAAK5U,KAAM,QACXA,KAAK8kC,SAAW/4B,YAAYC,MAC5BhM,KAAKwsB,KAAKxsB,KAAK8kC,UAEnBhlC,QACIE,KAAK6kC,UAAW,EAEpB/kC,SACIE,KAAK6kC,UAAW,EAChB7kC,KAAK8kC,SAAW/4B,YAAYC,MAEhClM,KAAK0X,GACD,MAAMD,EAAQC,EAAOxX,KAAK8kC,SAC1B9kC,KAAK8kC,SAAWttB,EAChBxX,KAAKrC,SAAW4Z,EACXvX,KAAK6kC,WACF7kC,KAAKkc,aACLlc,KAAK0kB,aAAazS,OAAOsF,EAAOC,GAChC5C,GAAK5U,KAAM,SAAUuX,EAAOC,IAE5BxX,KAAKoc,YACLpc,KAAKD,SAASkkB,OAAOjkB,KAAK0kB,aAAaT,OAAOjkB,KAAKtC,SAG3DsC,KAAKtC,QACLE,EAAsBoC,KAAKtC,OAC3BE,EAAwBoC,KAAKrC,SAC7B+nC,sBAAsB15B,GAAOhM,KAAKwsB,KAAKxgB,IAE3ClM,aKhDO,K9O7BPrC,E8O8BgBkoC,GhP7BpB,SAActlC,EAAQ,IAAKC,EAAS,IAAKmJ,EAAa,GAIlD,OAHmB,IAAfA,IACAA,EAAay2B,OAAO0F,kBAEjB,KACH5nC,EAASqC,EACTpC,EAAUqC,EACVpC,EAAcuL,GsM0GlBo8B,CAAK,IAAK,MlMjHEnH,GkMkHL,OlMjHA,KACCA,KACA//B,EAASG,EAAW4/B,OLLhC,SAAyBrtB,EAAQ,GAC7B,MAAO,KACHtT,EAAUsT,GuMmHdy0B,CAAgB,U/LrHJ9uB,G+LyEhB,c2CrEA,MACIlX,YAAYqD,GACRnD,KAAKnC,KAAOD,IACZoC,KAAK+U,OAAS,IAAIhN,IAClB0c,GAAQzkB,KAAMmD,K3CkElBrD,cACImN,QAEA,MAAMmH,EAAQ,IAAIoQ,GAAYxkB,MAExB4oB,EAAQ,IAAI+V,GAAQ,CACtBzS,SAAW6Z,GAAY,CACnB//B,EAAG,GAAIC,EAAG,GACVorB,UAAW,GAAIC,WAAY,KAG/BjxB,MAAO,GAAIC,OAAQ,KAGvBsoB,EAAMod,WAAW5xB,GAEjB,IAAIyY,EAASjE,EAAMqd,YAAY7xB,EAAO,EAAG,EAAG,EAAG,UAE3C0Y,EAASlE,EAAMqd,YAAY7xB,EAAO,EAAG,EAAG,EAAG,UAE3C8xB,EAAmB7M,GAAQzQ,EAAM4Z,oBAAoB,IACzD,IAAK,IAAI39B,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAIshC,EAAcD,EAAiBrhC,GACnC+jB,EAAMqd,YAAY7xB,EAAO+xB,EAAYngC,EAAGmgC,EAAYlgC,EAAG,EAAG,SAG5C2iB,EAAM6b,SAAS5X,EAAQC,GAE7B3d,QAASujB,K4CpG7B,SAAkBjzB,KAAUsT,GACxBA,EAAS5D,QAAQhI,IACb,MAAMqW,EAAcrW,EAAMqW,YAC1BA,EAAY,GAAK/d,EACjB+d,EAAY,GAAK/d,EACjB+d,EAAY,GAAK/d,EACjB+d,EAAY,GAAK/d,EACjB6d,GAAWnW,K5C+FPi/B,CAAS,GADIxd,EAAMqd,YAAY7xB,EAAOse,EAAO1sB,EAAG0sB,EAAOzsB,GAAI,EAAG,QAG9D,IAAI20B,EAAUhS,EAAMwB,gBAAgBsI,EAAO1sB,EAAG0sB,EAAOzsB,GAAG,GACpDoZ,EAAO,IAAID,GAAKwb,EAAQ50B,EAAG40B,EAAQ30B,EAAGysB,EAAOwH,KAAKlpB,YACtD6E,GAASzB,EAAOiL,O/L3GjB,KACH/f,EAAU,GAAG+mC,OAAOrvB"}